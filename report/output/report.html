<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <title></title>
        <style type="text/css">code{white-space: pre;}</style>
                            <style type="text/css">
            div.sourceCode { overflow-x: auto; }
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
              margin: 0; padding: 0; vertical-align: baseline; border: none; }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code > span.dt { color: #902000; } /* DataType */
            code > span.dv { color: #40a070; } /* DecVal */
            code > span.bn { color: #40a070; } /* BaseN */
            code > span.fl { color: #40a070; } /* Float */
            code > span.ch { color: #4070a0; } /* Char */
            code > span.st { color: #4070a0; } /* String */
            code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code > span.ot { color: #007020; } /* Other */
            code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code > span.fu { color: #06287e; } /* Function */
            code > span.er { color: #ff0000; font-weight: bold; } /* Error */
            code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            code > span.cn { color: #880000; } /* Constant */
            code > span.sc { color: #4070a0; } /* SpecialChar */
            code > span.vs { color: #4070a0; } /* VerbatimString */
            code > span.ss { color: #bb6688; } /* SpecialString */
            code > span.im { } /* Import */
            code > span.va { color: #19177c; } /* Variable */
            code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code > span.op { color: #666666; } /* Operator */
            code > span.bu { } /* BuiltIn */
            code > span.ex { } /* Extension */
            code > span.pp { color: #bc7a00; } /* Preprocessor */
            code > span.at { color: #7d9029; } /* Attribute */
            code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            </style>
                                            <style>
            body {
                font-family: Georgia;
                max-width: 800px;
                margin: 0 auto;
                line-height: 30px;
                font-size: 18px;
                padding-left: 350px;
                padding-right: 50px;
                color: #111;
            }
            
            h1, h2, h3, h4, h5, h6 {
                font-family: Arial;
            }
            
            h1 {
                padding-top: 200px;
                line-height: 50px;
            }
            h2 {
                padding-top: 30px;
            }
            h3 {
                padding-top: 20px;
            }
            h4 {
                padding-top: 10px;
            }
            p {
                text-align: justify;
            }
            p a {
                word-wrap: break-word;
                white-space: pre;
            }
            code {
                word-wrap: break-word;
            }
            blockquote {
                border-left: 3px solid #eee;
                margin-left: 20px;
                padding-left: 20px;
            }
            
            ::selection {
                background-color: #E4E4E4;
            }
            
            table {
                width: 100%;
            }
            table caption {
                font-weight: bold;
            }
            table tr {
                padding: 0;
                margin: 0;
                background-color: #f0f0f0;
            }
            table tr.even {
                background-color: #fafafa;
            }
            table td {
                margin: 0;
                padding: 3px 5px;
            }
            
            p span.added {
                color: green;
                background-color: #FFF3C5;
            }
            p span.removed {
                color: red;
                background-color: #FFF3C5;
            }
            
            #title-page {
                padding: 80px 0;
            }
            
            #TOC {
                position: fixed;
                left: 0;
                top: 0;
                overflow-y: scroll;
                height: 100%;
                background: #fafafa;
                max-width: 300px;
                font-family: Arial;
                font-size: 15px;
                line-height: 30px;
            }
            ::-webkit-scrollbar {
                width: 8px;
            }
            ::-webkit-scrollbar-track {
                background-color: #ECECEC;
            }
            ::-webkit-scrollbar-thumb {
                background-color: #B0B0B0;
                border-radius: 8px;
            }
            #TOC > ul {
                padding-right: 10px;
            }
            #TOC ul {
                list-style: none;
                padding-left: 20px;
            }
            #TOC ul li a {
                text-decoration: none;
                color: #364149;
                text-overflow: ellipsis;
                display: block;
                white-space: nowrap;
                overflow: hidden;
            }
            #TOC ul li a:hover {
                color: #008cff;
            }
            
            .figure {
                text-align: center;
            }
            .figure p {
                text-align: center;
                font-style: italic;
            }
            .figure img {
                  width: 100%;
            }
            </style>
                <script src="js/jquery.js"></script>
        <script src="js/diff.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
                <!--
                -->
        <div id="title-page">
            <h1>This is the title of the thesis</h1>
            <h2>Firstname Surname</h2>
        </div>
                    <div id="TOC">
                <ul>
                <li><a href="#abstract">Abstract</a></li>
                <li><a href="#acknowledgements">Acknowledgements</a></li>
                <li><a href="#list-of-figures">List of figures</a></li>
                <li><a href="#list-of-tables">List of tables</a></li>
                <li><a href="#abbreviations">Abbreviations</a></li>
                <li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
                <li><a href="#background"><span class="toc-section-number">1.1</span> Background</a></li>
                <li><a href="#objectives"><span class="toc-section-number">1.2</span> Objectives</a></li>
                <li><a href="#project-outcome"><span class="toc-section-number">1.3</span> Project Outcome</a></li>
                <li><a href="#summary-of-chapters"><span class="toc-section-number">1.4</span> Summary of chapters</a></li>
                </ul></li>
                <li><a href="#related-work"><span class="toc-section-number">2</span> Related Work</a><ul>
                <li><a href="#shonky"><span class="toc-section-number">2.1</span> Shonky</a></li>
                <li><a href="#frankjnr"><span class="toc-section-number">2.2</span> Frankjnr</a><ul>
                <li><a href="#frankjnr-limitations"><span class="toc-section-number">2.2.1</span> Frankjnr limitations</a></li>
                </ul></li>
                <li><a href="#vole"><span class="toc-section-number">2.3</span> Vole</a></li>
                <li><a href="#conclusion"><span class="toc-section-number">2.4</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#problem-description-and-specification"><span class="toc-section-number">3</span> Problem Description and Specification</a><ul>
                <li><a href="#problem-overview"><span class="toc-section-number">3.1</span> Problem overview</a><ul>
                <li><a href="#project-risks"><span class="toc-section-number">3.1.1</span> Project risks</a></li>
                </ul></li>
                <li><a href="#requirements-analysis"><span class="toc-section-number">3.2</span> Requirements Analysis</a><ul>
                <li><a href="#development-tools-and-languages"><span class="toc-section-number">3.2.1</span> Development Tools and Languages</a></li>
                <li><a href="#vagrant"><span class="toc-section-number">3.2.2</span> Vagrant</a></li>
                <li><a href="#webpack"><span class="toc-section-number">3.2.3</span> Webpack</a></li>
                <li><a href="#javascript"><span class="toc-section-number">3.2.4</span> JavaScript</a></li>
                <li><a href="#haskell"><span class="toc-section-number">3.2.5</span> Haskell</a></li>
                <li><a href="#report-markdown"><span class="toc-section-number">3.2.6</span> Report Markdown</a></li>
                </ul></li>
                <li><a href="#specification"><span class="toc-section-number">3.3</span> Specification</a><ul>
                <li><a href="#functional-requirements"><span class="toc-section-number">3.3.1</span> Functional requirements</a></li>
                <li><a href="#non-functional-requirements"><span class="toc-section-number">3.3.2</span> Non-functional requirements</a></li>
                <li><a href="#use-cases"><span class="toc-section-number">3.3.3</span> Use Cases</a></li>
                </ul></li>
                <li><a href="#design-methodology"><span class="toc-section-number">3.4</span> Design Methodology</a></li>
                </ul></li>
                <li><a href="#initial-development-experimental-system"><span class="toc-section-number">4</span> Initial development &amp; experimental system</a><ul>
                <li><a href="#introduction-1"><span class="toc-section-number">4.1</span> Introduction</a></li>
                <li><a href="#simple-system"><span class="toc-section-number">4.2</span> Simple system</a><ul>
                <li><a href="#language"><span class="toc-section-number">4.2.1</span> Language</a></li>
                <li><a href="#compiler"><span class="toc-section-number">4.2.2</span> Compiler</a></li>
                <li><a href="#abstract-machine"><span class="toc-section-number">4.2.3</span> Abstract machine</a></li>
                </ul></li>
                <li><a href="#conclusion-1"><span class="toc-section-number">4.3</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#detailed-design-and-implementation-of-the-final-system"><span class="toc-section-number">5</span> Detailed Design and Implementation of the final system</a><ul>
                <li><a href="#introduction-2"><span class="toc-section-number">5.1</span> Introduction</a><ul>
                <li><a href="#disclaimer"><span class="toc-section-number">5.1.1</span> Disclaimer</a></li>
                </ul></li>
                <li><a href="#project-folder-structure"><span class="toc-section-number">5.2</span> Project folder structure</a></li>
                <li><a href="#compiler-1"><span class="toc-section-number">5.3</span> Compiler</a><ul>
                <li><a href="#helper-functions"><span class="toc-section-number">5.3.1</span> Helper functions</a></li>
                </ul></li>
                <li><a href="#abstract-machine-1"><span class="toc-section-number">5.4</span> Abstract machine</a><ul>
                <li><a href="#implementation-1"><span class="toc-section-number">5.4.1</span> Implementation</a></li>
                <li><a href="#helper-functions-1"><span class="toc-section-number">5.4.2</span> Helper functions</a></li>
                <li><a href="#javascript-type-definitions"><span class="toc-section-number">5.4.3</span> JavaScript type definitions</a></li>
                </ul></li>
                <li><a href="#built-in-functions"><span class="toc-section-number">5.5</span> Built in functions</a></li>
                <li><a href="#possible-improvements"><span class="toc-section-number">5.6</span> Possible improvements</a></li>
                </ul></li>
                <li><a href="#verification-and-validation"><span class="toc-section-number">6</span> Verification and Validation</a><ul>
                <li><a href="#experimental-testing-framework"><span class="toc-section-number">6.1</span> Experimental testing framework</a><ul>
                <li><a href="#bash-script"><span class="toc-section-number">6.1.1</span> Bash script</a></li>
                <li><a href="#expect-script"><span class="toc-section-number">6.1.2</span> Expect script</a></li>
                <li><a href="#possible-improvements-1"><span class="toc-section-number">6.1.3</span> Possible improvements</a></li>
                </ul></li>
                <li><a href="#final-testing-framework"><span class="toc-section-number">6.2</span> Final testing framework</a><ul>
                <li><a href="#implementation-2"><span class="toc-section-number">6.2.1</span> Implementation</a></li>
                <li><a href="#possible-improvements-2"><span class="toc-section-number">6.2.2</span> Possible improvements</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#results-and-evaluation"><span class="toc-section-number">7</span> Results and Evaluation</a></li>
                <li><a href="#summary-conclusion"><span class="toc-section-number">8</span> Summary &amp; Conclusion</a><ul>
                <li><a href="#summary"><span class="toc-section-number">8.1</span> Summary</a></li>
                <li><a href="#future-work"><span class="toc-section-number">8.2</span> Future work</a></li>
                </ul></li>
                <li><a href="#appendix-1-progress-log">Appendix 1: Progress log</a></li>
                <li><a href="#appendix-3-test-cases">Appendix 3: Test cases</a><ul>
                <li><a href="#experimental-system">Experimental system</a></li>
                <li><a href="#final-system">Final system</a><ul>
                <li><a href="#new-test-programs">New test programs</a></li>
                <li><a href="#old-test-programs">Old test programs</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#appendix-4-relevant-readme-files">Appendix 4: Relevant README files</a><ul>
                <li><a href="#run-frank-in-browser">Run Frank in Browser</a></li>
                <li><a href="#frankjnr-1">Frankjnr</a></li>
                <li><a href="#report-template">Report template</a></li>
                </ul></li>
                <li><a href="#references">References</a></li>
                </ul>
            </div>
                                
<h1 id="abstract" class="unnumbered">Abstract</h1>
<!-- This is the abstract -->
<p>Frank is a strongly typed, strict functional programming language invented by Sam Lindley and Conor McBride. It is influenced by Paul Blain Levy’s call-by-push-value calculus, and features a bidirectional effect type system, effect polymorphism, as well as effect handlers. This means that Frank supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when a command is complete, depending on the handler, the system could resume from the point it was suspended. Handlers are very similar to typical functions, but their argument processes can communicate in more advanced ways. The idea is to utilize this functionality in the web. Side-effects might be various events such as mouse actions, http requests, etc., and the handler would be the application in the web page.</p>
<p>The overarching goal of the project is to compile Frank to JavaScript and to run it in the browser. Users would thus be able to use Frank for web development purposes. This involves creating a Compiler and a Virtual Machine (abstract machine) which can support a compiled Frank structure.</p>
<p> </p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<!-- This is for acknowledging all of the people who helped out -->
<p>I would like to express my special thanks and gratitude to my supervisor, Conor McBride for his guidance, support and patience throughout this project.</p>
<p>Also, I would like to thank my friends for helping me think through problems during our numerous technical discussions and contemplations.</p>
<!-- Use the \newpage command to force a new page -->




<h1 id="list-of-figures" class="unnumbered">List of figures</h1>
<!--
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.


Figure 4.1  This is an example figure . . .              \hfill{pp}  
Figure x.x  Short title of the figure . . .              \hfill{pp}  
-->
<p> </p>

<h1 id="list-of-tables" class="unnumbered">List of tables</h1>
<!-- 
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.
-->
<p>Table 5.1 This is an example table . . . <br />
Table x.x Short title of the figure . . . </p>
<h1 id="abbreviations" class="unnumbered">Abbreviations</h1>


<p> </p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This chapter focuses on explaining the project motivation, objectives and outcome. Also, in the last section, the report structure is displayed.</p>
<h2 id="background"><span class="header-section-number">1.1</span> Background</h2>
<p>Functional languages are evolving and constantly changing in order to adapt to innovations and the ever-changing needs of software engineering. Stemming from this, the concept of Frank language was created by Prof. Conor McBride and Prof. Sam Lindley, followed by its implementation named “Frank” and the more recent release - “Frankjnr”.</p>
<p>“Frank”is a strongly typed, strict functional programming language designed around Plotkin and Pretnar’s effect handler abstraction, strongly influenced by <span class="citation">(B. C. Pierce and D. N. Turner 2000)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001b)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001a)</span>, <span class="citation">(G. D. Plotkin and J. Power 2002)</span>, <span class="citation">(G. D. Plotkin and J. Power 2003)</span>, <span class="citation">(G. D. Plotkin and J. Power 2009)</span>, <span class="citation">(G. D. Plotkin and M. Pretnar 2013)</span> papers on algebraic effects and handlers for algebraic effects. It is also influenced by Paul Blain Levy’s call-by-push-value calculus. Frank features a bidirectional effect type system, effect polymorphism, and effect handlers; Frank thus supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when a command is complete, depending on the handler, the system could resume from the point it was suspended. Handlers are very similar to typical functions, but their argument processes can communicate in more advanced ways.</p>
<p>Because of the distinct features of Frank, in particular its capability to support effects and handlers, it has potential to be used in the context of web development. However, neither of Frank’s implementations currently support this. Therefore, the main intention of this project is to enable the usage of Frank for web development. Using a functional language for web development could greatly ease the process of writing parsers and form validations on the web. Essentially, Frank code would be converted into JavaScript because of its support for functional programming. Frank would potentially gain all of the JavaScript functionality and could even use JavaScript third-party libraries. For example, Frank would be able to handle different http requests, such as GET or POST; it could fire events (ex. alert boxes), and handle events (ex. mouse clicks).</p>
<p>The most effective way to achieve this is to utilize the existing Frankjnr implementation, rewriting its Compiler and Abstract Machine (back end). The Compiler would take in parsed Frank code and output JavaScript which could be used by Abstract Machine at Run-time.</p>
<p>This projects requires comprehension regarding the ways Compilers and Abstract Machines work and knowledge on how to use them together. The author chose this project knowing that it would be challenging, but also recognizing the valuable learning experience.</p>
<h2 id="objectives"><span class="header-section-number">1.2</span> Objectives</h2>
<ul>
<li>Utilize Frankjnr implementation;</li>
<li>Utilize Shonky data structures;</li>
<li>Develop a compiler which compiles Shonky's data structures to JavaScript data types;</li>
<li>Develop an abstract machine implementation which supports the output of the compiler;</li>
<li>The completed system must facilitate client-side communication of events and DOM updates between Frank code and the browser.</li>
</ul>
<h2 id="project-outcome"><span class="header-section-number">1.3</span> Project Outcome</h2>
<p>During the initial development stages, an experimental system was developed with its own language, compiler, virtual machine and testing framework in order to expand the author’s insight of the subject. Lessons learned, along with the code style and a few functions of experimental system, were adapted in creation of the final system. Having done this, the author was successful in implementing a new abstract machine and compiler for Frankjnr, which were in turn integrated into the Frankjnr project. However, the newly developed components are very much in the prototype stage as some of Frank's features are still not implemented and there are no new web functions added to the machine, which could potentially handle HTTP requests and similar web operations. Moreover, the project can still improve on a variety of concerns, such as performance and building procedures as they were not initial goals of the project.</p>
<h2 id="summary-of-chapters"><span class="header-section-number">1.4</span> Summary of chapters</h2>
<p><strong>Chapter 2 - Related Work</strong></p>
<p>The aim of this chapter is to highlight work done by others that in some fashion ties in with this project. This includes work which the author directly uses as a bouncing-off point, work that shows other attempts to solve similar problems, as well as connected projects which have been partially used in the final implementation of the project.</p>
<p><strong>Chapter 3 - Problem Description and Specification</strong></p>
<p>This chapter briefly overviews the main problems and challenges of the project. It briefly explains the requirement analysis stage; the development tools and languages chosen. It also expands upon functional and non-functional requirements, followed by a detailed specification and explanation of the design methodology.</p>
<p><strong>Chapter 4 - Initial development &amp; experimental system</strong></p>
<p>This chapter is focused on an initial experimental system. It highlights the reasoning behind it, the purpose of each component, their implementation, drawbacks and any potential improvements.</p>
<p><strong>Chapter 5 - Detailed Design and Implementation of the final system</strong></p>
<p>The chapter reflects upon the implementation and design of the final compiler and the abstract machine. It also explains the project structure, the developed testing framework, project connections between Shonky and Frankjnr, as well as possible improvements and alternative approaches to be considered.</p>
<p><strong>Chapter 6 - Verification and Validation</strong></p>
<p>This chapter explains how the outcome of the project was validated and what testing procedures were followed during and after the project.</p>
<p><strong>Chapter 7 - Results and Evaluation</strong></p>
<p>The principal intention of the chapter is to summarize the outcome of the project, describing how it was evaluated and to propose relevant future work.</p>
<h1 id="related-work"><span class="header-section-number">2</span> Related Work</h1>
<h2 id="shonky"><span class="header-section-number">2.1</span> Shonky</h2>
<p>Shonky is untyped and impure functional programming language. The key feature of Shonky is that it supports local handling of computational effect, using the regular application syntax. This means one process can coroutine many other subprocesses. In that sense it is very similar to Frank, just without type support. Its interpreter is written in Haskell, although it has potential to be ported to JavaScript or PHP to support web operations.</p>
<p>In the context of the project Shonky language data structures are used by the Abstract Machine, in Chapter 5 it is explained in great detail of how exactly were they used and for what purpose. However, Shonky interpreter is completely scrapped and is only used as a reference in solving any Abstract Machine or Compiler difficulties.</p>
<h2 id="frankjnr"><span class="header-section-number">2.2</span> Frankjnr</h2>
<p>Frankjnr is an newest implementation of Frank functional programming language described in &quot;<em>Do be do be do</em>&quot; <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span> paper. Frankjnr has a parser for Frank syntax, thus the user is able to use Frank to write expressions. After parsing Frank code it performs type check and other necessary operations followed by compilation to Shonky supported data structures which are then used by Shonky interpreter to run Frank.</p>
<h3 id="frankjnr-limitations"><span class="header-section-number">2.2.1</span> Frankjnr limitations</h3>
<ul>
<li>Only top-level mutually recursive computation bindings are supported;</li>
<li>Coverage checking is not implemented;</li>
</ul>
<h2 id="vole"><span class="header-section-number">2.3</span> Vole</h2>
<p>Vole is lightweight functional programming language with its own Compiler and two Abstract Machines. One Machine is written in Haskell and provides opportunity to run compiled Vole programs on the local machine. Other Virtual Machine is written in JavaScript, because of this it is possible to run Vole programs on the web, there are few working examples in the Git repository of Vole. It, also, has some support for effects and handlers, so it utilizes the ability to communicate between compiled Vole programs and application front-end on run-time.</p>
<p>In the context of this project - Vole is a useful resource, because it essentially tries to solve the same problem but for a different language. Author had to study Vole, to understand its technical implementation, usage of resources and to expand his knowledge of Compilers and Abstract Machines. Lastly, Vole is used for evaluation purposes as another benchmark comparison.</p>
<h2 id="conclusion"><span class="header-section-number">2.4</span> Conclusion</h2>
<p>Three main related projects are Vole, Shonky and Frankjnr. Vole was used as an working example of a solution for similar problem, which got author thinking of different ways to approach the problem. Shonky and Frankjnr were used directly, because Frankjnr is the newest implementation of Frank language and it uses Shonky's Abstract Machine (interpreter). So the idea was to take existing Frankjnr and replace the Shonky's interpreter with new Compiler and Abstract Machine which would support web development while keeping Shonky's syntax data structures. Other related work were used as examples of different solutions to overcome similar obstacles.</p>
<h1 id="problem-description-and-specification"><span class="header-section-number">3</span> Problem Description and Specification</h1>
<p>This section discusses the project problem, challenges, requirements and involved risks.</p>
<h2 id="problem-overview"><span class="header-section-number">3.1</span> Problem overview</h2>
<p>The main aim of the project was to develop new Compiler and corresponding Abstract Machine for existing functional language Frank implementation called Frankjnr. The difference from the old ones was that new Compiler and Abstract Machine would support web development. Many different challenges follow from that. First one being authors initial lack of knowledge on Frank language. Frank being full and complex language author had to study it and overcome any difficulties regarding the language by researching the paper on Frank &quot;<em>Do be do be do</em>&quot; <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span>.</p>
<p>A second challenge was overcoming the complexity of existing systems. Because this project is not standalone, it strictly depends on the Shonky Syntax implementation as well as Frankjnr handling Frank's code. Author had to take time and carefully research existing systems, to understand how everything fits together and how efficiently replace exiting Shonky interpreter with new Compiler and Abstract Machine.</p>
<p>Another challenge was the difficult nature of compilers and abstract machines. This was the most difficult challenge to overcome due to the depth and the amount of detail each of them have. Thus, the incremental approach was adapted, in order to for the author to learn step by step, starting with simpler things. Author started the project by developing experimental system with its own language,compiler and virtual machine to understand the crucial concepts of compiler and abstract machines.</p>
<p>Fourth challenge was testing and validation. Because the project is focused on developing completely new system without any usage of frameworks, testing framework had to be developed which could run test cases and check their correctness without any interaction of the user. Testing framework was developed by utilizing Bash Script, Expect Script languages and Node, Webpack, Ghci commands. It was firstly, created for experimental system and then based on observation and testing, altered and improved for the final system. In the end, it dramatically improved development time by constantly locating bugs and validating the correctness of the outputs.</p>
<p>The project was extremely broad and involved great deal of initial research as well as constant analysis of next steps, thus development was slow but effective. However, due to time constrains development time had to be planned very carefully, because of this some acknowledged directions of development had to be ignored to finish the prototype in time. For example, one of those directions was Haskell enforced type checker. Haskell compiler could have had a type checker which would prevent any bugs regarding generated JavaScript programs by enforcing its types. Now such bugs are spotted by the console window of the browser or testing framework.</p>
<h3 id="project-risks"><span class="header-section-number">3.1.1</span> Project risks</h3>
<ul>
<li>Dependence on Frank implementation (Frankjnr). Instances of Frank code will be tested to make sure it behaves as expected;</li>
<li>Estimating and scheduling development time. Due to authors inexperience with the subject of the project, correctly estimating and scheduling time is difficult. However, meetings with supervisor are organized regularly, to make sure the project is on track;</li>
<li>Lack of resources, supervisor Conor McBride is the only resource of relevant and accurate information;</li>
<li>Authors lack of experience with languages being used and overall analyzed concepts (compiler and virtual machines).</li>
</ul>
<h2 id="requirements-analysis"><span class="header-section-number">3.2</span> Requirements Analysis</h2>
<p>Before any development could begin requirements needed to be gathered, author did this by discussing how the system should behave and what technologies it should utilize with the supervisor. He, also, attended programming languages seminar where Frank language was discussed, gaining different perspective on the whole project. Lastly, author read papers on relevant topics, such as &quot;Compiling Exceptions Correctly&quot; <span class="citation">(Graham Hutton and Joel Wrigh 2004)</span>, to expand his knowledge and gain more insight in what to do. Further research was made to ensure the appropriateness of chosen languages and technologies.</p>
<h3 id="development-tools-and-languages"><span class="header-section-number">3.2.1</span> Development Tools and Languages</h3>
<p>This section will briefly explain used tools and languages and reasoning behind each of them.</p>
<h3 id="vagrant"><span class="header-section-number">3.2.2</span> Vagrant</h3>
<!--https://www.vagrantup.com/-->
<p>Vagrant is an optional tool to create separate development environment for the project. It runs on Virtual Box and it is essentially a server on your local computer which you can boot up and work on. Furthermore, Vagrant comes with up to date relevant libraries out of the box. Author used it to avoid installing software and managing libraries on local machine, thus speeding up development.</p>
<h3 id="webpack"><span class="header-section-number">3.2.3</span> Webpack</h3>
<!--https://webpack.github.io/-->
<p>Webpack is a module builder and it is available as npm package. In this project it is used for Abstract Machine development as it adds some wanted features to plain JavaScript, and in the end everything is compiled to a single light JavaScript file. The most important is an ability to create and export different modules, for example, module could be a function or a variable. This lets for improved project structure as you are able to keep JavaScript components in separate files, thus making it easer to develop and navigate through code.</p>
<h3 id="javascript"><span class="header-section-number">3.2.4</span> JavaScript</h3>
<p>JavaScript is a client side scripting language. In this project output of the compiler is generated in JavaScript, which is then used by Virtual Machine which is, also, written in JavaScript so that both could cooperate on run time without any further compilations.</p>
<p>JavaScript is used because of its key features. Firstly, it has support for functional programming by letting function arguments be other functions. Secondly, it is supported by all popular browsers. And finally, there are lots of libraries and features to support web development.</p>
<h4 id="alternative---coffescript"><span class="header-section-number">3.2.4.1</span> Alternative - CoffeScript</h4>
<p>CoffeScript is much newer language and it improves upon JavaScript syntax, allowing for neater declarations, introduces new features and reinforces the structure of the code. CoffeScript can run in any environment where JavaScript can run, because in the end it is compiled to JavaScript. It is available as npm package. However, it wasn't used because author didn't want another layer of compilation going on in the background.</p>
<h3 id="haskell"><span class="header-section-number">3.2.5</span> Haskell</h3>
<!--https://wiki.haskell.org
https://www.haskell.org/-->
<p>Haskell is a statically, implicitly typed, lazy, standardized functional programming language with non-strict semantics. Haskell features include support for recursive functions, data types, pattern matching, and list comprehensions.</p>
<p>Haskell was chosen for compiler development because of its functional language features, like pattern-matching, efficient recursion, support for monadic structures. Moreover, &quot;Frankjnr&quot; and &quot;Shonky&quot; are written in Haskell as well, thus, using Haskell would provide easier compatibility with those projects.</p>
<h3 id="report-markdown"><span class="header-section-number">3.2.6</span> Report Markdown</h3>
<!--https://github.com/tompollard/phd_thesis_markdown-->
<!--http://pandoc.org/-->
<p>This report adapted the template of markdown developed by Tom Pollard, because of its flexible structure and features, such as support for Pandoc markdown and latex expressions. Report is divided into separate source files, which creates strong project structure and every source file is compiled to a single pdf file with compiler powered by <em>npm</em>.</p>
<h2 id="specification"><span class="header-section-number">3.3</span> Specification</h2>
<h3 id="functional-requirements"><span class="header-section-number">3.3.1</span> Functional requirements</h3>
<ul>
<li>To create new back end for Frankjnr implementation:
<ul>
<li>Develop Compiler which uses Shonky's language (Syntax file) and outputs a sensible and correct JavaScript code structure;</li>
<li>Develop Abstract Machine which can run previously compiled JavaScript code in the browser;</li>
</ul></li>
<li>To facilitate client-side communication of events and DOM updates between Frank code and the browser;</li>
</ul>
<h3 id="non-functional-requirements"><span class="header-section-number">3.3.2</span> Non-functional requirements</h3>
<ul>
<li>To create set of tests which should always pass, before each new release of the system. Test cases should be increased after every iteration to validate new features and ensure the previous features are not broken;</li>
<li>To develop testing framework, which tests the system using the list of predetermine test cases;</li>
<li>To measure performance (in comparison with the existing back end and with other kinds of generated JavaScript);</li>
<li>Client-side programming should become possible (example, complex parser of a text field);</li>
</ul>
<h3 id="use-cases"><span class="header-section-number">3.3.3</span> Use Cases</h3>
<p>Use cases are not really relevant to this project, since the developed compiler and abstract machine support full Frank language, which potentially can be used in infinite number of ways. But generally, the user puts sensible Frank code into a Frank file then initiate compilation by using project's compiler, the compiler will generate a JavaScript file which user can include in their web project. Furthermore, user needs to include the machine, which utilizes previously compiled code, into their project. For mode detailed information on how to use the system, check usage instruction in the Appendix ???.</p>
<h2 id="design-methodology"><span class="header-section-number">3.4</span> Design Methodology</h2>
<p>The implementation of the project is fully focused on back end development. The adopted design methodology was iterative and incremental development (IID). The main reasons behind it were the difficult nature of the project and author's initial lack of knowledge on the subject; this methodology allows the developer to focus on few features at a time building the system incrementally, thus making it easier to learn as you go.</p>
<p>Iterative and incremental development (IID) is a process which grows the system incrementally, feature by feature during self-contained cycles of analysis, design, implementation and testing which end when the system is finished. Meaning, the system is improved (more functionality added) through every iteration.</p>
<p>The core benefits of this methodology are:</p>
<ul>
<li>Regression testing is conducted after each iteration, where only few changes are made through single iteration, because of this faulty elements of the software are easily identified and fixed before starting the next iteration;</li>
<li>Testing of systems features is a bit easier, because this methodology allows for targeted testing of each element within the system;</li>
<li>System could easily shift directions of development after each iteration;</li>
<li>Learning curve is much flatter than usual, because developer is focusing on few features at a given time.</li>
</ul>
<p>Another big decision was to start with simpler system, an experimental throughout which the author could learn the basics and adapt gained knowledge in the development of the final system. The experiment took about four weeks and used the same methodology - iterative and incremental development.</p>
<h1 id="initial-development-experimental-system"><span class="header-section-number">4</span> Initial development &amp; experimental system</h1>
<h2 id="introduction-1"><span class="header-section-number">4.1</span> Introduction</h2>
<p>Because of the complexity of the project and the lack of initial author knowledge in the field, the most optimal plan was to start with small, less demanding development and expand gradually. The intricacies consist of:</p>
<ul>
<li>Frank is a complex functional language;</li>
<li>&quot;Frankjnr&quot; adds another layer of complexity, since author needs to be aware of the implementation and compilation process;</li>
<li>Dependence on Shonky's language, because the final implementation of the Compiler must be able to understand and compile Shonky's data structures;</li>
<li>Complexity of the compilers and their implementation;</li>
<li>Complexity of abstract machines and their implementation;</li>
</ul>
<p>Thus, simpler language was developed with matching compiler and abstract machine. Both, the compiler and the machine were developed while keeping in mind that their key parts will be reused for the final system. So efficiency, reliability, structure were all important factors.</p>
<h2 id="simple-system"><span class="header-section-number">4.2</span> Simple system</h2>
<p>System consists of:</p>
<ul>
<li>Compiler - written in Haskell;</li>
<li>Language - written in Haskell;</li>
<li>Machine - written in JavaScript, compiled with <em>webpack</em>;</li>
<li>Testing Framework - written in Bash and Expect scripts, overview of the framework can be found in <strong>Chapter 6</strong>;</li>
</ul>
<h3 id="language"><span class="header-section-number">4.2.1</span> Language</h3>
<p>A simple language written in Haskell, which syntax supports few specific operations, such as, sum of two expressions, Throw &amp; Catch, Set, Next, Get, new reference. Each of the operations were carefully selected, where their implementation in the abstract machine varies significantly. Thus, offering broad and important learning experience.</p>
<p><strong>Full language definition</strong></p>
<p>Language is defined as Haskell data type &quot;Expr&quot;. In this case it supports only different types of expressions. Experimental language is focused on Integer manipulation, thus it only supports integer values. Here is a definition of a Integer value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Val</span> <span class="dt">Int</span></code></pre></div>
<p>Definition of sum of two expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:+:</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of a &quot;Throw&quot; and &quot;Catch&quot; commands. If the first expression of Catch is equal to Throw, meaning an exception was raised (something went wrong), then the second expression will be evaluated.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Throw</span>
        <span class="fu">|</span> <span class="dt">Catch</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of &quot;WithRef&quot; command. It creates new reference with a given value. First string variable of the command defines name of new reference, second value is an expression which defines how to compute initial value of new reference and the third value is the context in which the reference is valid. &quot;WithRef&quot; stack frame is the handler for &quot;Get&quot; and &quot;:=&quot; commands.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">WithRef</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of getting the value of a defined reference.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Get</span> <span class="dt">String</span> </code></pre></div>
<p>Syntax definition of setting defined reference value to be equal to some new expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">String</span> <span class="fu">:=</span> <span class="dt">Expr</span> </code></pre></div>
<p>Syntax definition for evaluating two expressions one by one and taking value of the second. In most programming languages it is defined as &quot;;&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:&gt;</span> <span class="dt">Expr</span></code></pre></div>
<h3 id="compiler"><span class="header-section-number">4.2.2</span> Compiler</h3>
<p>Purpose of the Compiler is to take in an formatted expression of the experimental language described above and output a JavaScript compiling data structure (array of functions), which could be used by the abstract machine.</p>
<p>Below is a definition of code generation monad. It contains a constructor &quot;MkCodeGen&quot; and a deconstructor &quot;codeGen&quot;. It takes in an next available integer value and outputs a data structure which holds a list of integer which map to JavaScript code (string), next available number after the compilation and result of the compilation &quot;val&quot;. Usually the list of definitions will start with the input &quot;next number&quot; and go up to just before the output &quot;next number&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">CodeGen</span> val <span class="fu">=</span> <span class="dt">MkCodeGen</span> {
<span class="ot">            codeGen ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> ([(<span class="dt">Int</span>, <span class="dt">String</span>)], <span class="dt">Int</span>, val) 
        }                </code></pre></div>
<p>&quot;MkCodeGen&quot; is used to construct a definition in &quot;genDef&quot; function displayed below. &quot;genDef&quot; returns the definition number and it is used by compile function to make new function definitions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genDef ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span> 
genDef code <span class="fu">=</span> <span class="dt">MkCodeGen</span> <span class="fu">$</span> \ next <span class="ot">-&gt;</span> ([(next, code)]
                            , next <span class="fu">+</span> <span class="dv">1</span>, next)</code></pre></div>
<p>Below the type of &quot;compile&quot; function is shown. &quot;compile&quot; function takes in a valid language expression and outputs entry point of the compilation as well as compilation process which can be separated into chucks of generated JavaScript code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span></code></pre></div>
<p>&quot;compile&quot; function is either used to create new function definitions or to compile expressions to JavaScript depending on the type of &quot;Expr&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">help s (<span class="dt">Val</span> n) <span class="fu">=</span> genDef <span class="fu">$</span>
        <span class="st">&quot;function(s){return{stack:&quot;</span><span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;,</span>
<span class="st">                     tag:\&quot;num\&quot;, data:&quot;</span><span class="fu">++</span> show n <span class="fu">++</span><span class="st">&quot;}}&quot;</span>

help s (e1 <span class="fu">:+:</span> e2) <span class="fu">=</span> <span class="kw">do</span> 
    f2 <span class="ot">&lt;-</span> compile e2
    help (<span class="st">&quot;{prev:&quot;</span> <span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;, tag:\&quot;left\&quot;,</span>
<span class="st">                     data:&quot;</span><span class="fu">++</span> show f2 <span class="fu">++</span><span class="st">&quot;}&quot;</span>) e1</code></pre></div>
<h4 id="formating-and-outputting-to-file"><span class="header-section-number">4.2.2.1</span> Formating and outputting to file</h4>
<p>Output formating is done by &quot;jsSetup&quot; function. It takes the name of the array, the output of &quot;compile&quot; function and outputs a JavaScript formatted string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsSetup  ::</span>  <span class="dt">String</span>       <span class="co">-- array name</span>
         <span class="ot">-&gt;</span>  <span class="dt">CodeGen</span> x    <span class="co">-- compilation process</span>
         <span class="ot">-&gt;</span>  (  <span class="dt">String</span>    <span class="co">-- JavaScript code</span>
             ,  x         <span class="co">-- result</span>
             )</code></pre></div>
<p>&quot;jsWrite&quot; takes an output of &quot;jsSetup&quot; and writes everything to a file - &quot;generated.js&quot;, which can be safely used by the abstract machine.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsWrite ::</span> (<span class="dt">String</span>, x) <span class="ot">-&gt;</span> <span class="dt">IO</span>()
jsWrite (code, x) <span class="fu">=</span> writeFile <span class="st">&quot;dist/generated.js&quot;</span> code</code></pre></div>
<p>Example usage:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> xpr <span class="fu">=</span> <span class="dt">Val</span> <span class="dv">2</span> <span class="fu">:+:</span> (<span class="dt">Val</span> <span class="dv">4</span> <span class="fu">:+:</span> <span class="dt">Val</span> <span class="dv">8</span>)
jsWrite (jsSetup <span class="st">&quot;Add&quot;</span> (compile xpr))</code></pre></div>
<h3 id="abstract-machine"><span class="header-section-number">4.2.3</span> Abstract machine</h3>
<p>Purpose of the abstract machine is to take in a compiled program and provide semantics for the file to be runnable in the browser. It gradually builds a stack from a given data structure (located in &quot;generated.js&quot;), where each frame of the stack has a link to another frame. The elegant part of this structure is that, stack frames can be saved, updated, deleted and restored, thus, making the machine's structure flexible.</p>
<p><strong>Data Structure of compiled expression</strong></p>
<p>Each generated data structure by the compiler is an array and its entries are functions which take in a stack. This way it is possible to nest them while keeping track of the stack.</p>
<p>Below is an example of a compiled expression ready to be used by the abstract machine. This particular program is simple, it adds two numbers &quot;2 + 3&quot;, so the expected output is &quot;5&quot;. Comments are added to explain meaning of different variables. For more complicated examples see <em>main/example_programs</em>.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ProgramFoo <span class="op">=</span> []<span class="op">;</span>

ProgramFoo[<span class="dv">0</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// stack</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">//expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">3</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span>
ProgramFoo[<span class="dv">1</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span> <span class="co">// stack </span>
            <span class="dt">prev</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// link to previous frame </span>
            <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="co">// command used for adding numbers</span>
            <span class="dt">data</span><span class="op">:</span> <span class="dv">0</span> <span class="co">// index of next operation </span>
        <span class="op">},</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">// expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span></code></pre></div>
<h4 id="implementation"><span class="header-section-number">4.2.3.1</span> Implementation</h4>
<p>This section will explain detailed implementation of the experimental Abstract Machine. It is defined as a function which takes in a compiled program as an argument.</p>
<p>Initial definition of mode with starting values. Because the starting stack is empty the &quot;stack&quot; parameter is defined as &quot;null&quot;; the tag is an expression type and if it is equal to &quot;go&quot;, the Machine must evaluate next function. Finally, the &quot;data&quot; parameter holds an index of next function, so the initial value is the index of last function in a program array.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;go&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">f</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>
    <span class="op">}</span></code></pre></div>
<p>Mode is a function in a program array which takes in a stack as a parameter. Abstract Machine will operate until mode.tag is equal to &quot;go&quot;. If it is then mode must be reinitialized by getting getting a next function from program array and passing stack to it, so that the mode has access to previous stack.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">===</span> <span class="st">&quot;go&quot;</span>) <span class="op">{</span>
        mode <span class="op">=</span> f[<span class="va">mode</span>.<span class="at">data</span>](<span class="va">mode</span>.<span class="at">stack</span>)<span class="op">;</span></code></pre></div>
<p>After the mode is reinitialized mode.tag can't be equal to &quot;go&quot; and mode stack can't be empty. If these requirements aren't met then it means that execution is over.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">!=</span> <span class="st">&quot;go&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">mode</span>.<span class="at">stack</span> <span class="op">!=</span> <span class="kw">null</span>) <span class="op">{</span></code></pre></div>
<p>If the execution is still going then the behavior of the Abstract Machine will differ based on mode's tag parameter. Tag could be equal to these values:</p>
<ul>
<li><strong>&quot;num&quot;</strong> - all of the basic evaluations of given expression:
<ul>
<li>Addition (&quot;left&quot; and &quot;right&quot;) - creates a stack frame with tag &quot;right&quot;, if the top of the stack tag is equal to &quot;right&quot; it means that Abstract Machine can add two of the top frames together, because all of the other computations are done.</li>
<li>Catch - creates a stack frame with tag &quot;catcher&quot; and places it on the top of the stack. Its data parameter is equal to the index of second expression which will be evaluated if first expressions throws an exception.</li>
<li>New reference - creates a stack frame with tag &quot;WithRefRight&quot;, it is different from other stack frames because it has a &quot;name&quot; parameter, which is needed to identify between different references. It, also, holds the value of the reference in its &quot;data&quot; parameter.</li>
<li>Next (:&gt;left and :&gt;right) - implementation is similar to addition, however the key difference is that if the top stack frame tag is equal to &quot;:&gt;right&quot; the Abstract Machine will take its data without adding anything and it will delete the used stack frame.<br />
</li>
<li>Set (:=) - very similar to &quot;Get&quot; command, key difference is that it alters the stack frame which has tag &quot;WithRefRight&quot; and the given name of the reference. This command utilizes linked list stack saving to be able to restore the stack while saving any changes made. It could throw an exception if the reference is undefined.</li>
</ul></li>
<li><strong>&quot;throw&quot;</strong> - it defines that something went wrong so the Abstract Machine will look for a &quot;catch&quot; usage in the previous stack, if it doesn't find it then it will output an exception.</li>
</ul>
<p>Machine checks if the top of the stack is equal to &quot;catcher&quot;, if it is then it means exception was handled, so Abstract Machine reinitializes mode to continue executions by taking &quot;catcher&quot; values of &quot;stack&quot; and &quot;data&quot;.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">data</span>
    <span class="op">}</span></code></pre></div>
<p>Else Machine drops the top of the stack and continues to look for &quot;catcher&quot; until stack is empty.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;throw&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="st">&quot;Unhandled exception!&quot;</span>
    <span class="op">}</span></code></pre></div>
<ul>
<li><strong>&quot;get&quot;</strong> - goes through stack while looking for a reference, output's either a value of the reference if it does find it or tries to throw an exception if it doesn't. It, also, utilizes linked stack saving and restoring functions, in order to restore the stack if it does find a reference.</li>
</ul>
<p>After the Abstract Machine finishes running it will output the final stack to the console by invoking a custom printer function for the user to clearly see the stack.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">printer</span>(mode)<span class="op">;</span></code></pre></div>
<p>And finally, Abstract Machine outputs final value of the execution on the separate line for testing purposes, it is used by Testing framework to check for expected and actual output of a test.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(<span class="va">mode</span>.<span class="at">data</span>)<span class="op">;</span></code></pre></div>
<p><strong>Linked Stack Saving and Restoring</strong></p>
<p>Abstract Machine uses saver function in &quot;get&quot; and &quot;:=&quot; implementations. This function lets the Machine not only to inspect the depths of the stack but, also, to assign new values to existing frames of the stack. To achieve this, Abstract Machine saves each frame of the stack from top until it finds the frame it is looking for. Below &quot;saveStack&quot; function is displayed, the &quot;m&quot; variable represents the current stack frame.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">save <span class="op">=</span> <span class="op">{</span>
    <span class="dt">prev</span><span class="op">:</span> save<span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="va">m</span>.<span class="at">tag</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">m</span>.<span class="at">data</span><span class="op">,</span>
    <span class="dt">name</span><span class="op">:</span> <span class="va">m</span>.<span class="at">name</span>
<span class="op">}</span></code></pre></div>
<p>The save is reverse linked list of stack frames, thus it is possible to restore the original stack including all the changes made. After stack is successfully restored all of the save data must be destroyed and parameters reseted to keep future saves unaffected.</p>
<p>Limitations:</p>
<ul>
<li>Only one Stack save can exist at a given time.</li>
</ul>
<h4 id="final-remarks"><span class="header-section-number">4.2.3.2</span> Final Remarks</h4>
<p>The Abstract Machine currently supports functionality for adding expressions, creating a reference, getting the value of a reference, setting new value of a given reference, throwing &amp; catching an exception.</p>
<p>Room for improvement:</p>
<ul>
<li>Efficiency and optimization;</li>
<li>Documentation;</li>
<li>Functionality;</li>
</ul>
<p>All of these points are addressed in the final implementation.</p>
<h2 id="conclusion-1"><span class="header-section-number">4.3</span> Conclusion</h2>
<p>A preliminary experiment, implementing the essence of Frank-like execution for much simpler language, has been completed successfully. The key lessons were:</p>
<ul>
<li>Haskell syntax;</li>
<li>Language creation and its syntax development;</li>
<li>Compiler - parsing the input and generating valid JavaScript code;</li>
<li>Machine - executing given program, and managing its resources, such as mode, stack and saved stack.</li>
</ul>
<p>Key things to improve are optimization &amp; performance.</p>
<p>The further plan is to roll out the lessons learned creating compiler and VM for more of the &quot;Shonky&quot; intermediate language that is generated by Frank compiler. This will be covered in the next chapter.</p>
<h1 id="detailed-design-and-implementation-of-the-final-system"><span class="header-section-number">5</span> Detailed Design and Implementation of the final system</h1>
<p>Chapter focuses on implementation, design of the final compiler and abstract machine, as well as, any topics connected to them.</p>
<h2 id="introduction-2"><span class="header-section-number">5.1</span> Introduction</h2>
<p>Final system started to develop on week six of the second semester after the end of experimental system development. Some parts of the code were lifted from the earlier experiment and main concepts of how virtual machines and compilers should work are reused.</p>
<h3 id="disclaimer"><span class="header-section-number">5.1.1</span> Disclaimer</h3>
<p>Final system uses two other systems in its code base, thus not all of the code is written by the author of this project. Author's code will be clearly indicated. Two projects connected to the system are:</p>
<ul>
<li><strong>Frankjnr</strong> - developed by Sam Lindley, Craig McLaughlin and Conor McBride. Final system is essentially new back end for Frankjnr. So the whole Frankjnr project was used and new back end was placing in 'Backend' folder. Parts of Frankjnr code were slightly updated to let the user choose between the old back end and the new one. Updated files were: Compile.hs and Frank.hs, updates are clearly indicated with comments;</li>
<li><strong>Shonky</strong> - developed by Conor McBride. Final compiler uses Shonky's syntax file for its supported data structures and parse functions;</li>
</ul>
<p>More detailed descriptions can be found at 'Related work' section of the report or at their respective Github pages.</p>
<h2 id="project-folder-structure"><span class="header-section-number">5.2</span> Project folder structure</h2>
<p>Final system is located in &quot;final_implementation&quot; folder. And all of the code for new compiler and abstract machine is located in &quot;Backend&quot; folder.</p>
<p>Table's starting folder is <em>&quot;/final_implementation&quot;</em>.</p>
<table>
<caption>Project folder structure</caption>
<colgroup>
<col width="27%" />
<col width="18%" />
<col width="54%" />
</colgroup>
<thead>
<tr class="header">
<th>Paths and Files</th>
<th></th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td>Main directory for final implementation</td>
</tr>
<tr class="even">
<td></td>
<td>Frank.hs</td>
<td>Main Frankjnr file</td>
</tr>
<tr class="odd">
<td></td>
<td>Compile.hs</td>
<td>Compiles Frank to Shonky data structures</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend</em></td>
<td></td>
<td>Machine and Compiler files</td>
</tr>
<tr class="even">
<td></td>
<td>Compiler.hs</td>
<td>Main compiler</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/machine</em></td>
<td></td>
<td>Abstract Machine files</td>
</tr>
<tr class="odd">
<td></td>
<td>webpack.js</td>
<td>Webpack configuration file</td>
</tr>
<tr class="even">
<td></td>
<td>tester.html</td>
<td>HTML which includes output.js (testing purposes)</td>
</tr>
<tr class="odd">
<td></td>
<td>main.js</td>
<td>Main machine function</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/machine/components</em></td>
<td></td>
<td>Includes all components to construct Virtual Machine</td>
</tr>
<tr class="even">
<td></td>
<td>machine.js</td>
<td>Main component for Virtual Machine</td>
</tr>
<tr class="odd">
<td></td>
<td>printer.js</td>
<td>Component responsible for result printing</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/machine/dist</em></td>
<td></td>
<td>Generated files</td>
</tr>
<tr class="even">
<td></td>
<td>gen.js</td>
<td>Compiler generated code</td>
</tr>
<tr class="odd">
<td></td>
<td>output.js</td>
<td>Webpack generated code (every JS file is packed into one)</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/Shonky</em></td>
<td></td>
<td>Shonky project directory</td>
</tr>
<tr class="even">
<td></td>
<td>Syntax.hs</td>
<td>Contains needed data structures</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/tests</em></td>
<td></td>
<td>Test framework</td>
</tr>
<tr class="odd">
<td></td>
<td>main.sh</td>
<td>Main file (launch file)</td>
</tr>
<tr class="even">
<td></td>
<td>testcases.sh</td>
<td>Contains all of the test cases</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/tests/test_cases</em></td>
<td></td>
<td>Actual programs to test</td>
</tr>
<tr class="odd">
<td><em>/Backend/tests/test_cases/old</em></td>
<td></td>
<td>Test programs lifted from Frankjnr</td>
</tr>
<tr class="even">
<td><em>/Backend/tests/test_cases/new</em></td>
<td></td>
<td>New test programs</td>
</tr>
</tbody>
</table>
<h2 id="compiler-1"><span class="header-section-number">5.3</span> Compiler</h2>
<p>Compiler is located in <em>final_implementation/Backend/Compiler.hs</em> and it is written in Haskell. It is initiated when frank program compilation is called with flag &quot;output-js&quot;. Example with program named &quot;foo.fk&quot;:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> foo.fk --output-js</code></pre></div>
<p>Developed compiler constatly uses Shonky data sctructures, located in <em>Syntax.hs</em> file, because it receives a list of program definitions from Frankjnr compiler in a form of Shonky syntax data structure, in particular - &quot;[Def Exp]&quot;. &quot;Def Exp&quot; can be either &quot;:=&quot; or &quot;DF&quot;, however Frank compiler always gives back list of &quot;DF&quot;, thus this compiler will only support them as well. &quot;DF&quot; means functions definitions and they consist of:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">DF</span> <span class="dt">String</span>   <span class="co">-- name of operator being defined</span>
  [[<span class="dt">String</span>]]    <span class="co">-- list of commands handled on each port</span>
  [([<span class="dt">Pat</span>], <span class="dt">Exp</span>)]  <span class="co">-- list of pattern matching rules</span></code></pre></div>
<p>Goal for the compiler is to compile data type &quot;Exp&quot; (type of expression, such as atom or application) to working JavaScript, generating functions that do intermediate steps. The code for compiling &quot;Exp&quot; will expect a lookup table which maps the &quot;environment&quot; array (stores values of pattern values) to array indices. In order to find out if certain values are in scope, otherwise compilation will fail.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EnvTable</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]</code></pre></div>
<p>Furthermore, there are two types of patterns. Pattern for computation - &quot;Pat&quot; and pattern for value - &quot;VPat&quot;. Patterns for computation can be thunk, command or &quot;VPat&quot;, such as variable &quot;VPV&quot;, pair &quot;VPat :&amp;: VPat&quot; and so on. Compiler has to build an &quot;EnvTable&quot; from these patterns, hence these two functions: &quot;patCompile&quot; and &quot;vpatCompile&quot;. They have been implemented using counter monad &quot;Counter&quot;, which is there to count each patern and is used for &quot;environment&quot; lookup table. And the core pattern maching priciple used was &quot;match-this-or-bust&quot; described in PhD thesis &quot;Computer Aided Manipulation of Symbols&quot; <span class="citation">(F.V. McBride 1970)</span>. Therefore, these functions will generate series of checks for each individual pattern and if everything is fine and the pattern is a variable and not, for example, an atom or integer, add them to the &quot;environment&quot;, else it will throw an expection. In the code snippet below the patern is an integer so we don't need to add them to the environemnt, but it still has to pass these tests in order to match. Value &quot;next&quot; is just a counter to arange correct indeces for &quot;environment&quot; lookup table:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">vpatCompile v (<span class="dt">VPI</span> x) <span class="fu">=</span> <span class="kw">do</span> <span class="co">-- integer value</span>
  i <span class="ot">&lt;-</span> next
  return ([],
    <span class="st">&quot;if (&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;.tag!==\&quot;int\&quot;) ++</span>
<span class="st">        {&quot;</span> <span class="fu">++</span> matchFail <span class="fu">++</span><span class="st">&quot;};\n&quot;</span> <span class="fu">++</span>
    <span class="st">&quot;if (&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;.int!==&quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot;) ++</span>
<span class="st">        {&quot;</span> <span class="fu">++</span> matchFail <span class="fu">++</span><span class="st">&quot;};\n&quot;</span>
    )</code></pre></div>
<p>After &quot;environment&quot; lookup table is compiled and ready to go, compiler now needs to use it to compile expressions - &quot;Exp&quot;. This is achieved in &quot;expCompile&quot; function, which takes in an &quot;environment&quot; lookup table, function lookup table, stack (string data structure), expression and outputs an JavaScript data structure encapsulated in monad &quot;CodeGen&quot;. This monad is lifted from earlier experiment and it is used here for the same reason, to construct function definitions and track their indeces in &quot;funCompile&quot; function. The compilation process will differ for each type of expression, because each of them have to follow different rules to be compiled correctly, for instance &quot;EA&quot; (atoms) type is straightforward, because atoms are simple and compiler only needs to compile the actual atom. It looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class="fu">$</span> <span class="st">&quot;{stack:&quot;</span> <span class="fu">++</span> stk <span class="fu">++</span> <span class="st">&quot;, comp:{tag:\&quot;value\&quot;,&quot;</span> <span class="fu">++</span>
           <span class="st">&quot;value:{tag:\&quot;atom\&quot;, atom:\&quot;&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot;\&quot;}}}&quot;</span></code></pre></div>
<p>However, for example &quot;pair&quot; type of expressions are more complicated, because the &quot;pair&quot; contains two expressions, so the compiler has to compile them both separately:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">expCompile xis ftable stk (ecar <span class="fu">:&amp;</span> ecdr) <span class="fu">=</span> <span class="kw">do</span>
  fcdr <span class="ot">&lt;-</span> expFun xis ftable ecdr
  expCompile xis ftable 
    (<span class="st">&quot;{prev: &quot;</span> <span class="fu">++</span> stk <span class="fu">++</span> <span class="st">&quot;, frame:{ tag:\&quot;car\&quot;, env:env, cdr:&quot;</span>
     <span class="fu">++</span> show fcdr <span class="fu">++</span> <span class="st">&quot;}}&quot;</span>)
    ecar</code></pre></div>
<p>Another interesting and crucial type of expression compilation is function application. Here, because the function is applied to list of arguments, compiler has to compile each of the arguments by forming a linked list data structure. And to do this it utilizes the helper function named &quot;tailCompile&quot;, which recursivly builds a linked list.</p>
<p>However, before any of individual expression compilation or &quot;environement&quot; building can begin, compiler needs to combine everything into one JavaScript data structure, forming resumptions and operators arrays in the process. The function for this is &quot;operatorCompile&quot;, which initiates chain reaction of function calls for each function definision and concatines the results into one data structure. This chain reaction of function calls consist of &quot;oneCompile&quot;, which starts to compile single fuction definition and forms an &quot;operators&quot; array entry. Then it calls &quot;makeOperator&quot;, which sets the &quot;interface&quot; (all available commands for given operator) by calling &quot;availableCommands&quot; and &quot;implementation&quot; (JavaScript function definision) by calling &quot;funCompile&quot;. &quot;funCompile&quot; is responsible for forming the actual function definition of the operator and it procedes to initiate &quot;linesCompile&quot;, which forms a &quot;try&quot; and &quot;catch&quot; blocks and calls the final function &quot;lineCompile&quot;, who fills the lines with compiled expression data by actually calling &quot;patCompile&quot; and &quot;expCompile&quot; functions with data on functions patterns and expressions; finally, &quot;lineCompile&quot; forms a return statement of the function. To see how these expressions and paterns look compiled, see &quot;gen.js&quot; file.</p>
<h3 id="helper-functions"><span class="header-section-number">5.3.1</span> Helper functions</h3>
<p>This section will briefly explain functionality of few helper functions.</p>
<p><strong>parseShonky</strong> - is used for testing purposes, it takes Shonky syntax file (ending with &quot;uf&quot;), reads it, parses it utilizing the parse function located in <em>Syntax.hs</em> and runs the compiler on the result. Thus, generating new &quot;gen.js&quot; file.</p>
<p><strong>jsComplete</strong> - wraps everything into one function, it takes the output of &quot;operatorCompile&quot;, formats it and writes the result of the compilation to the &quot;gen.js&quot; file.</p>
<h2 id="abstract-machine-1"><span class="header-section-number">5.4</span> Abstract machine</h2>
<p>Purpose of the abstract machine is to take in generated output of the compiler and run it in the web, thus completing the task of running Frank code in the browser. For full usage &amp; installation instructions see Appendix 2.</p>
<p>Abstract machine modules are located in<br />
<em>final_implementation/Backend/machine</em> folder. They are written in JavaScript and are compiled to a single file<br />
<em>final_implementation/Backend/machine/dist/output.js</em> by utilizing webpack.</p>
<h3 id="implementation-1"><span class="header-section-number">5.4.1</span> Implementation</h3>
<p>Abstract machine takes contents of gen.js as an input, which contains two different arrays: operators and resumptions. Operators are equivalent to functions in Haskell, resumptions are computations waiting to be executed. In current implementation starting operator is always the first function, so main method should be at the top of file. And they return modes which are computation who store stack, here the machine defines initial mode with initial empty stack, no arguments and no environment:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mode <span class="op">=</span> operators[<span class="dv">0</span>].<span class="at">implementation</span>(<span class="kw">null</span><span class="op">,</span> []<span class="op">,</span> [])<span class="op">;</span></code></pre></div>
<p>The machine will keep executing in a while loop until stack becomes empty; before halting it will return the final mode and call printer helper function to display the output. In each while cycle machine check the current computation tag, it can either be a &quot;value&quot; or a &quot;command&quot; and depending on which one it is, machine will act accordingly.</p>
<h4 id="computation---value"><span class="header-section-number">5.4.1.1</span> Computation - &quot;value&quot;</h4>
<p>If the &quot;mode.comp.tag&quot; is equal to &quot;value&quot; then machine will look at the first frame of the stack to receive information on what to do next. There are four options depending on the frame tags, each of them will construct new mode building or reducing the stack in the process (look at <em>JavaScript type definitions</em> section to see their structure):</p>
<ul>
<li><p><strong>&quot;car&quot;</strong> - will construct mode out of calling a resumption based on &quot;mode.stack.frame.cdr&quot; value. For resumption to construct a new mode they need two values, stack and an environment. Therefore, machine will pass in the stack and the environment as well. Although, it will alter the stack by removing top stack frame and creating a new one with a &quot;cdr&quot; tag and a car value.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"> frame<span class="op">:</span> <span class="op">{</span>
   <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;cdr&quot;</span><span class="op">,</span>
   <span class="dt">car</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">value</span>
 <span class="op">},</span></code></pre></div></li>
<li><p><strong>&quot;cdr&quot;</strong> - will reduce the stack and return a pair of <em>car</em> and <em>cdr</em> as its computation. It will take <em>car</em> value from the current stack frame and cdr from current computation value.</p></li>
<li><p><strong>&quot;fun&quot;</strong> - means application, so some function needs to be applied to a list of arguments, which is essentially list of resumptions. If the list of arguments is empty that means the machine is ready to initiate the function application by calling helper &quot;apply&quot; function without any arguments. If, however, the argument list is not empty machine needs to construct new mode with frame tag &quot;arg&quot;. It creates new mode out of first argument resumption &quot;resumptions[mode.stack.frame.args.head]&quot; and passes all the needed information in the new stack frame:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"> frame<span class="op">:</span> <span class="op">{</span>
   <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;arg&quot;</span><span class="op">,</span>
   <span class="dt">fun</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">value</span><span class="op">,</span>
   <span class="dt">env</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">env</span><span class="op">,</span>
   <span class="dt">ready</span><span class="op">:</span> []<span class="op">,</span>
   <span class="dt">waiting</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="va">args</span>.<span class="at">tail</span><span class="op">,</span>
   <span class="dt">handles</span><span class="op">:</span> <span class="at">headHandles</span>(intf)<span class="op">,</span>
   <span class="dt">waitingHandles</span><span class="op">:</span> <span class="at">tailHandles</span>(intf)
 <span class="op">},</span></code></pre></div>
<p>&quot;fun&quot; field to keep the function that will be applied when the arguments &quot;waiting&quot; list is empty. &quot;env&quot; to keep the environment, &quot;ready&quot; list to know which arguments have been parsed, initially it is empty. &quot;waiting&quot; to keep track of list of arguments that are left unchecked. And, lastly, &quot;handles&quot; with &quot;waitingHandles&quot; to keep track which argument handle what commands, so if handles list is empty it means that this argument doesn't handle any commands. It gets these values by applying helper functions, which return head and tail of the list. And the initial handle list is extracted from operators interface with helper function &quot;interfaceF&quot;, which simply returns given operators interface (list of commands that it can handle).</p></li>
<li><p><strong>&quot;arg&quot;</strong> - simply adds current head of arguments to the ready list and initiates helper function &quot;argRight&quot; which will return new mode (its functionality in detail is described in &quot;Helper functions&quot; section).</p></li>
</ul>
<h4 id="computation---command"><span class="header-section-number">5.4.1.2</span> Computation - &quot;command&quot;</h4>
<p>Because of &quot;command&quot; type of computations Frank is different from other functional languages. When command computation appears the current execution is interrupted and the control is given to the handler, which looks for the requested command in the stack while building a callback (checked stack frames) to restore the stack when the command is found and finished executing.</p>
<p>In this implementation, computations with tag equal to &quot;command&quot; are created in a case when an atom is applied to a list arguments. Then the abstract machine goes down the stack while looking for the command. Each time it doesn't find it, it will place top frame in the callback and move down by one frame:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">mode</span>.<span class="va">comp</span>.<span class="at">callback</span> <span class="op">=</span> <span class="op">{</span>
  <span class="dt">frame</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">frame</span><span class="op">,</span>
  <span class="dt">callback</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">callback</span>
<span class="op">}</span>
<span class="va">mode</span>.<span class="at">stack</span> <span class="op">=</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span></code></pre></div>
<p>For the machine to find a command in a frame, it must be an &quot;arg&quot; frame. And it must contain the command that the handler is looking for in its &quot;handles&quot; list (it indicates which commands does given &quot;arg&quot; handle).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">tag</span> <span class="op">===</span> <span class="st">&quot;arg&quot;</span>) <span class="op">{</span>
  <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="va">handles</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">handles</span>[i] <span class="op">===</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">command</span>) <span class="op">{</span>
      ...</code></pre></div>
<p>When these conditions are met, the command handler is found. Therefore it will place the computation of the command on the &quot;ready&quot; argument list and will try to apply it by calling &quot;argRight&quot; helper function, which in turn will call &quot;apply&quot; helper function if there are no waiting resumptions.</p>
<h3 id="helper-functions-1"><span class="header-section-number">5.4.2</span> Helper functions</h3>
<p>This section will describe the functionality of two main helper functions.</p>
<p><strong>argRight</strong> - takes in stack tail, function to be applied, list of arguments that are ready, environment, list of arguments which are still waiting to be checked and list of handled commands. List of handled commands is kept for the machine to know what commands does the resumption handle. Same as in the &quot;fun&quot; case if the waiting list of resumptions (arguments) is empty then the machine is ready to apply the function, thus call apply function, if it is not then create new &quot;arg&quot; frame in the same fashion as in &quot;fun&quot; option. The key difference is that &quot;fun&quot; could be instantly applied if it didn't have any arguments, thus not creating any &quot;arg&quot; frames. Moreover, there is potential to move all logic to &quot;argRight&quot; function without having any in &quot;fun&quot; case, improving code reuse and optimization.</p>
<p><strong>apply</strong> - Depending on a &quot;fun&quot; computation value, constructs a mode from which to continue execution. &quot;fun&quot; computation could be one of the following:</p>
<ul>
<li><p><strong>&quot;int&quot;</strong> - Applying int to an argument is not really sensible, however in this case it is possible because of built in operations (see <em>Built in functions</em> section). This custom functionality lets machine add and subtract integer values.</p></li>
<li><p><strong>&quot;local&quot;</strong> - Means a local function, and the machine is turning it into top level operator, concept introduced by <span class="citation">(Thomas Jonson 1985)</span> and it is named &quot;Lambda Lifting&quot;. Therefore, mode is constructed out of an operator variable.</p></li>
<li><p><strong>&quot;operator&quot;</strong> - Means top level function, mode is constructed from an operator depending on &quot;fun.operator&quot; value which is an index for operators array.</p></li>
<li><p><strong>&quot;atom&quot;</strong> - Applications of atoms mean a command is initiated; mode with command tag and command value should be created. It, also keeps the arguments and creates a &quot;callback&quot; value to be able to restore the stack successfully after finding required command in the stack. Thus new mode looks like this:</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stk<span class="op">,</span>
      comp<span class="op">:</span> <span class="op">{</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;command&quot;</span><span class="op">,</span>
        <span class="dt">command</span><span class="op">:</span> <span class="va">fun</span>.<span class="at">atom</span><span class="op">,</span>
        <span class="dt">args</span><span class="op">:</span> vargs<span class="op">,</span>
        <span class="dt">callback</span><span class="op">:</span> <span class="kw">null</span>
      <span class="op">}</span></code></pre></div>
<ul>
<li><strong>&quot;thunk&quot;</strong> - Application of thunk pattern (suspended computation). Constructs a mode while ignoring any arguments; computation expression comes from &quot;fun.thunk&quot;. New mode is equal to:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stk<span class="op">,</span>
      comp<span class="op">:</span> <span class="va">fun</span>.<span class="at">thunk</span></code></pre></div>
<ul>
<li><strong>&quot;callback&quot;</strong> - This means command has been found and executed and now the machine has to restore the stack to its original position. It does this looping through the &quot;callback&quot; while building the stack with callback's frames. When it is done, machine returns a mode constructed of the restored stack and first argument.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stack<span class="op">,</span>
      comp<span class="op">:</span> args[<span class="dv">0</span>]</code></pre></div>
<p><strong>printer</strong> - takes the mode of finished execution, parses it to make it readable and displays it on the screen.</p>
<h3 id="javascript-type-definitions"><span class="header-section-number">5.4.3</span> JavaScript type definitions</h3>
<p>This section explains the JavaScript types used to enforce the data structure of programs.</p>
<p>&quot;JSRun&quot; is an operator, who always return mode. They are located in operators array in the generated program (&quot;gen.js&quot;). Mode has a stack and current computation; top stack frame and current computation both determine what to do next.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSRun <span class="op">=</span> (JSStack<span class="op">,</span> JSEnv<span class="op">,</span> JSVal[]) <span class="op">-&gt;</span> JSMode
jstype JSMode <span class="op">=</span> <span class="op">{</span><span class="dt">stack</span><span class="op">:</span> JSStack<span class="op">,</span> <span class="dt">comp</span><span class="op">:</span> JSComp<span class="op">}</span>     </code></pre></div>
<p>Stack could be empty or consist of a frame and a link to previous frame. The idea of these links are applied from linked list data structure, where each element of the list has a link to the next element. This structure is used regularly throughout the project.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSStack 
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">prev</span><span class="op">:</span> JSStack<span class="op">,</span> <span class="dt">frame</span><span class="op">:</span> JSFrame <span class="op">}</span></code></pre></div>
<p>Stacks frame type, which determines the operation that needs to be done when current computation is equal to &quot;value&quot;.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSFrame 
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;car&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">cdr</span><span class="op">:</span> Int <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;cdr&quot;</span><span class="op">,</span> <span class="dt">car</span><span class="op">:</span> JSVal <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;fun&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">args</span><span class="op">:</span> JSList Int <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;arg&quot;</span><span class="op">,</span> <span class="dt">fun</span><span class="op">:</span> JSVal<span class="op">,</span> <span class="dt">ready</span><span class="op">:</span> JSComp[]<span class="op">,</span>
     <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">waiting</span><span class="op">:</span> JSList Int<span class="op">,</span>
     <span class="dt">headles</span><span class="op">:</span> Int<span class="op">,</span> <span class="dt">waitingHandles</span><span class="op">:</span> JSList Int <span class="op">}</span></code></pre></div>
<p>List data structure, where it could be empty or have an current element and tailing list of elements.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSList x
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">head </span><span class="op">:</span> x<span class="op">,</span> <span class="dt">tail </span><span class="op">:</span> JSList x<span class="op">}</span>    </code></pre></div>
<p>Computation could either be a &quot;value&quot; or a &quot;command&quot;.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSComp
  <span class="op">=</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;value&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> JSVal<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;command&quot;</span><span class="op">,</span> <span class="dt">command</span><span class="op">:</span> String<span class="op">,</span>
     <span class="dt">args</span><span class="op">:</span> JSVal[]<span class="op">,</span> <span class="dt">callback</span><span class="op">:</span>JSCallBack<span class="op">}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSCallBack
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">frame</span><span class="op">:</span> JSFrame<span class="op">,</span> <span class="dt">callback</span><span class="op">:</span>JSCallBack<span class="op">}</span></code></pre></div>
<p>These are the types of what value can be. &quot;atom&quot; is just an value that cannot be deconstructed any further. &quot;int&quot; represents an integer value. &quot;pair&quot; is a pair of two values, one is held in &quot;car&quot; object and the other is in &quot;cdr&quot;. &quot;operator&quot; is a top level function. &quot;callback&quot; holds a &quot;callback&quot; object which has stack frames waiting to be restored after machine finds definition of command that it was looking for. &quot;thunk&quot; represents a suspended computation. And &quot;local&quot; means local function, which do to procedure called &quot;Lambda Lifting&quot; <span class="citation">(Thomas Jonson 1985)</span>, abstract machine will turn it into a top level function and execute.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSVal
  <span class="op">=</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;atom&quot;</span><span class="op">,</span> <span class="dt">atom</span><span class="op">:</span> String<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;int&quot;</span><span class="op">,</span> <span class="dt">int</span><span class="op">:</span> Int<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;pair&quot;</span><span class="op">,</span> <span class="dt">car</span><span class="op">:</span> JSVal<span class="op">,</span> <span class="dt">cdr</span><span class="op">:</span> JSVal<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;operator&quot;</span><span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> Int<span class="op">,</span> <span class="dt">env</span><span class="op">:</span>JSEnv<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;callback&quot;</span><span class="op">,</span> <span class="dt">callback</span><span class="op">:</span> JSCallBack<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;thunk&quot;</span><span class="op">,</span> <span class="dt">thunk</span><span class="op">:</span>JSComp<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;local&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span>JSEnv<span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> JSVal<span class="op">}</span></code></pre></div>
<h2 id="built-in-functions"><span class="header-section-number">5.5</span> Built in functions</h2>
<p>Current built in functions are &quot;plus&quot; and &quot;minus&quot;, in order to make integer manipulation possible. They are defined before the top-level function compilation begins in function <em>operatorCompile</em> and then just initialized together with them, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> fs <span class="fu">=</span> [(f, (h, pse)) <span class="fu">|</span> <span class="dt">DF</span> f h pse <span class="ot">&lt;-</span> ds] <span class="fu">++</span> builtins</code></pre></div>
<p>However their current definitions are a bit different compared to others which are generated. Compiler is not able to give them meaning because he does not know how to manipulate two integer expressions; instead compiler must pass this functionality to the abstract machine, which can interpret those expressions and apply wanted arithmetic operation. Compiler codes wanted arithmetic operation into the function definition, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">DF</span> <span class="st">&quot;minus&quot;</span> [] [<span class="fu">...</span>], <span class="dt">EV</span> <span class="st">&quot;x&quot;</span> <span class="fu">:$</span> [<span class="dt">EV</span> <span class="st">&quot;y&quot;</span>, <span class="dt">EV</span> <span class="st">&quot;y&quot;</span>]</code></pre></div>
<p>&quot;:$&quot; means application, compiler tries to apply integer variable &quot;x&quot; to list of integer variables &quot;y&quot;, which initially does not make any sense. However, machine has encoded semantics for this situation, therefore if integer is applied to a list of arguments that could only mean one of two things, either that integer needs to be added to first element of the list or substracted from it. Machine determinse this by looking how many elements are in the list and applies the correct opperation accordingly.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">args</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">2</span>) <span class="op">{</span> <span class="co">// minus</span>
  answ <span class="op">=</span> <span class="va">fun</span>.<span class="at">int</span> <span class="op">-</span> args[<span class="dv">0</span>].<span class="va">value</span>.<span class="at">int</span><span class="op">;</span>
<span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="co">// plus</span>
  answ <span class="op">=</span> <span class="va">fun</span>.<span class="at">int</span> <span class="op">+</span> args[<span class="dv">0</span>].<span class="va">value</span>.<span class="at">int</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Those were special cases when compiler is not able to deal with them, however other built in functions, which do not require arithmetic operations can easily be added without machine knowing about them. Such as, pairing two elements or getting first element out of a pair.</p>
<h2 id="possible-improvements"><span class="header-section-number">5.6</span> Possible improvements</h2>
<p><strong>Abstract machine</strong></p>
<ul>
<li>To store stack frames in chunks of frames, where only the top frame of a given chunk could potentially handle a command. This would skip checking all frames, which tags are not equal to &quot;arg&quot;, therefore improving performance.</li>
</ul>
<p><strong>Compiler</strong></p>
<ul>
<li><p>Current state of JavaScript type definitions are not enforced by the compiler; so compiler trusts the programmer to encode them correctly. The improvement would be to enforce types with Haskell data structures, thus minimizing the risk of bugs in production.</p></li>
<li><p>To change pattern matching procedures from &quot;match-this-or-bust&quot; <span class="citation">(F.V. McBride 1970)</span> to building a tree of switches described in &quot;Functional Programming and Computer Architecture&quot; <span class="citation">(Lennart Augustsson 1985)</span>, in order to increase efficiency.</p></li>
</ul>
<h1 id="verification-and-validation"><span class="header-section-number">6</span> Verification and Validation</h1>
<p>This project's verification and validation were done strictly throughout testing. Development was done in two parts, development of experimental system (for learning purposes) and development of final system. Initial testing started at very early stage of the project, by testing experimental system's abstract machine behavior without the interaction of the compiler. At that point it was done manually, by the author typing in expressions and looking through the output, however as development went on it quickly became too inefficient. Thus a experimental testing framework was developed (February 10th, 2017), which would go through pre-set test cases one by one without any human interaction; giving feedback for the user in the process. Author then adapted the system and applied lessons learned to create similar but improved framework for the final system.</p>
<p>During the implementation of both systems test cases were added regularly, after each newly developed component. Moreover, on account of iterative and incremental development methodology (IDD) author was able to write targeted test cases for every component of the system. Because of this, new bugs were identified and tracked faster, thus leading for faster software development. Test cases were initiated before every content push to git and during development to check for any broken parts of the system.</p>
<p>After the implementation has ended, test framework was initiated one last time to see if all tests still pass, as well as some manual testing was done by the author to verify the state of the system. Furthermore, test programs from &quot;Frankjnr&quot; implementation were lifted and used to verify the behavior of the final system by confirming that the output of the tests are the same in both systems. More on this in <strong>Chapter 7</strong>.</p>
<p>Possible improvement would to be to use service similar to <em>Jenkins</em>, in order to automate tests even more by automatically launching them and giving back feedback. But only on certain conditions, for example, after every push to git or once a day regularly.</p>
<p>For full list of test case expressions and programs see <strong>Appendix 3</strong>.</p>
<h2 id="experimental-testing-framework"><span class="header-section-number">6.1</span> Experimental testing framework</h2>
<p>This section will describe the implementation of the experimental testing framework. It consists of two files utilizing two different scripts: Bash script and Expect script. Its purpose is to automate the testing process. Below each of these scripts will be reviewed.</p>
<h3 id="bash-script"><span class="header-section-number">6.1.1</span> Bash script</h3>
<p>Bash script is the main script in the testing framework which stores all test cases, then goes through them one by one. To launch it simply type <em>./tester.sh</em> in the terminal window. For full guide on installation and usage see <strong>Appendix 2</strong>.</p>
<p>Test cases are arrays which store free values: expression to be tested, the name of the test and expected output. Below sample test case is displayed:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test0=(</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 10&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_num&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;10&#39;</span>
)</code></pre></div>
<p>For each test case Bash script launches Expect script and passes test case parameters to it, in particular it passes the expression to be tested and the name of the test:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tests/helper.sh</span> <span class="va">${test[expr]}</span> <span class="va">${test[name]</span></code></pre></div>
<p>After, Expect script &quot;helper.sh&quot; finishes computing new program is generated, system must recompile abstract machine's code to use newly generated program. <em>Webpack</em> is used to compile JavaScript files to one and to manage their structure.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span> --hide-modules <span class="co">#recompile to output.js </span></code></pre></div>
<p>After successful recompilation of JavaScript Bash script has to retrieve the output of the program by getting the last line of the console output, it does this by utilizing Node functionality and some string manipulation.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">output=$(</span><span class="ex">node</span> ./dist/output.js<span class="va">)</span>; <span class="co">#get output</span>
<span class="va">output=</span><span class="st">&quot;</span><span class="va">${output##</span>*<span class="st">$&#39;</span><span class="dt">\n</span><span class="st">&#39;</span><span class="va">}</span><span class="st">&quot;</span> <span class="co">#take only last line</span></code></pre></div>
<p>Finally, Bash script just compares the expected output with actual output and gives back the result for the user to see.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">if</span><span class="bu"> [</span> <span class="st">&quot;</span><span class="va">$output</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;</span><span class="va">${test[expected]}</span><span class="st">&quot;</span><span class="bu"> ]</span>; <span class="kw">then</span>
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${GREEN}</span><span class="st">Test passed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">else</span> 
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${RED}</span><span class="st">Test failed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre></div>
<h3 id="expect-script"><span class="header-section-number">6.1.2</span> Expect script</h3>
<p>Expect script is used because of its ability to send and receive commands to systems which have their own terminal, in this case <em>GHCI</em>. Developed script takes the name of the test and the expression to be tested. Since it is only possible to pass one array to Expect script, the script performs some array manipulation to retrieve the name and the expression which was passed by the Bash script.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">set</span> <span class="fu">expr</span> [lrange <span class="va">$argv</span> 0 end-1]
<span class="kw">set</span> <span class="ex">name</span> [lindex <span class="va">$argv</span> end 0]</code></pre></div>
<p>After that it launches <em>GHCI</em> terminal.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">spawn</span> ghci</code></pre></div>
<p>And waits for &quot;&gt;&quot; character before sending the command to load the &quot;Compiler.hs&quot; file, which is experimental system's compiler.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;:load Compiler.hs\r&quot;</span></code></pre></div>
<p>Finally, Expect script sends the two following commands with some variables (taken form the array) to generate the output of the compiler and quits to resume the Bash script execution.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;</span><span class="va">$b</span><span class="st">\r&quot;</span>

<span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;jsWrite (jsSetup </span><span class="dt">\&quot;</span><span class="va">$name</span><span class="dt">\&quot;</span><span class="st"> (compile xpr))\r&quot;</span> </code></pre></div>
<h3 id="possible-improvements-1"><span class="header-section-number">6.1.3</span> Possible improvements</h3>
<ul>
<li>Speed and efficiency;</li>
<li>Move test cases into separate file to improve structure;</li>
<li>More useful statistics at the end of test framework computation;</li>
</ul>
<h2 id="final-testing-framework"><span class="header-section-number">6.2</span> Final testing framework</h2>
<p>Contained in <em>final_implementation/Backend/tests</em> folder. Framework is designed to launch number of programs, located in <em>test_cases</em> folder, and give back feedback to the user, which test programs succeeded and which ones failed. This framework eliminates manual testing, lets identify bugs faster, thus speeding up development process and easing maintenance. And it is fully written in Bash Script.</p>
<p>Some parts of the test framework were lifted from earlier experiment, however the key differences are that it is not using GHC compiler directly; so it eliminates the need for Expect script (previously located in &quot;helper.sh&quot; file),thus improving performance of the framework. Another change is that test cases don't take in expressions anymore, instead they take in paths to actual programs, therefore providing ability to launch them and check their outputs.</p>
<p>For all test case programs see <strong>Appendix 3</strong>. For usage and installation instructions see <strong>Appendix 2</strong>.</p>
<h3 id="implementation-2"><span class="header-section-number">6.2.1</span> Implementation</h3>
<p>Similarly like in experimental system's testing framework, test cases are stored in array. Each of them are objects which store three values: path of the test program, name of the test and expected output. They are looped through one by one, displaying the name of the test to the user and recompiling the test with:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> <span class="va">${test[path]}</span> --output-js</code></pre></div>
<p>It generates the &quot;gen.js&quot; in <em>Backend/machine/dist</em> folder. At this point <em>Backend/machine/dist/output.js</em> needs to be recompiled to include new &quot;gen.js&quot; file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span> --hide-modules</code></pre></div>
<p>Then it just retrieves the output with <em>Node</em> and checks if it as expected or not; letting the user know if test failed or passed (same way as in experimental testing framework). Finally, some statistics are shown on how many tests in total have passed and failed with corresponding percentages.</p>
<h3 id="possible-improvements-2"><span class="header-section-number">6.2.2</span> Possible improvements</h3>
<ul>
<li>Providing more statistics when all tests are executed;</li>
<li>Timestamp tests, letting the user know how much time it took to run individual tests and all of them together;</li>
<li>Improve performance by not trying to launch programs which fail to compile by &quot;Frankjnr&quot; compiler.</li>
</ul>
<h1 id="results-and-evaluation"><span class="header-section-number">7</span> Results and Evaluation</h1>
<h1 id="summary-conclusion"><span class="header-section-number">8</span> Summary &amp; Conclusion</h1>
<h2 id="summary"><span class="header-section-number">8.1</span> Summary</h2>
<h2 id="future-work"><span class="header-section-number">8.2</span> Future work</h2>
<h1 id="appendix-1-progress-log" class="unnumbered">Appendix 1: Progress log</h1>
<p><strong>JANUARY</strong></p>
<p>January 4th:<br />
<em>Research:</em><br />
Looked over Frankjnr, Shonky, Vole implementations.</p>
<p>January 5th:<br />
Tried to install Frankjnr for a period of time, however couldn’t resolve all the errors.</p>
<p>January 7th:<br />
<em>Research:</em><br />
Looked at Vole with a bit more detail.</p>
<p>January 9th:<br />
Tried to install Frankjnr by using Cabal dependency management tool, no success (deprecated dependencies).<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 10th:<br />
<em>Research:</em><br />
Looked at Vole, in particular Machine.lhs, Compile.lhs and Vole.js.</p>
<p>January 11th:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 16th:<br />
<em>Research:</em><br />
Looked at Shonky stack implementation, tried to output it on the screen.</p>
<p>January 17th:<br />
<em>Machine Development:</em><br />
Implemented simple linked list stack in JavaScript, just as a practice.</p>
<p>January 18th:<br />
<em>Research:</em><br />
Looked again at Shonky’s Abstract Machine, particularly the order the input is parsed.</p>
<p>January 24th:<br />
<em>Machine Development:</em><br />
Implemented simple Abstract Machine, which can sum 2 numbers.</p>
<p>January 25th:<br />
<em>Machine Development:</em><br />
Machine now works with stack larger than 2.<br />
Updated the way it stores functions, now it uses Array data structure.<br />
<em>Research:</em><br />
Looking into how to implement throw, catch and compiler.</p>
<p>January 26th:<br />
<em>Compiler Development:</em><br />
Created basic language in Haskell. Which supports expressions and sum of expressions.<br />
Developed monadic structure for the compiler.</p>
<p>January 30th:<br />
<em>Compiler Development:</em><br />
Finished the basic layout, however it doesn’t display any results yet.<br />
Presentation &amp; Report Work:<br />
Setup of latex with lex2tex.</p>
<p>January 31th:<br />
<em>Machine Development:</em><br />
Implemented Throw and Catch for Abstract Machine.<br />
Presentation &amp; Report work:<br />
Worked on structure of the report.</p>
<p><strong>FEBRUARY</strong></p>
<p>February 01:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on latex configurations.</p>
<p>February 02:<br />
<em>Machine Development:</em><br />
Implemented early versions of stack saving, restoring and support for Set command.</p>
<p>February 04:<br />
<em>Presentation &amp; Report work:</em><br />
Report work - Introduction sections.</p>
<p>February 06:<br />
<em>Compiler Development:</em><br />
Tried to implement Show instance for CodeGen function.</p>
<p>February 07:<br />
<em>Research:</em><br />
Looked at the lifecycle and expected behaviour of the Compiler.<br />
<em>Compiler Development:</em><br />
Implemented Compiler Catch and Throw.</p>
<p>February 08:<br />
<em>Compiler Development:</em><br />
Implemented Get, Next, WithRef commands.<br />
<em>Machine Development:</em><br />
Implemented support for Next commands.<br />
Added new examples of working programs.</p>
<p>February 09:<br />
<em>Machine development:</em><br />
Implemented early version of stack saving and restoring.<br />
Implemented support for Set commands.<br />
Added new working examples.<br />
Reworked Next command support, should work as expected.</p>
<p>February 10:<br />
<em>Test Framework development:</em><br />
Implemented test framework by utilizing Bash and Expect scripts.<br />
<em>Machine development:</em><br />
Divided code into separate classes and files.<br />
Added printer class, which just outputs the current stack to the console.</p>
<p>February 13:<br />
Started to rework Abstract Machine, to closer match the implementation required.<br />
<em>Machine development:</em><br />
Reworked Catch and Throw command support.<br />
<em>Compiler development:</em><br />
Small efficiency adjustments.<br />
Test Framework development:<br />
Added more test cases.<br />
General bug fixes.</p>
<p>February 14: <em>Test Framework development:</em><br />
Fixed major bug with string parsing.<br />
Added more test cases.<br />
<em>Machine development:</em><br />
Completely reworked support for Get, Set and WithRef commands.<br />
General bug fixes.</p>
<p>February 15:<br />
Progress report.</p>
<p>February 16:<br />
Progress report.</p>
<p>February 24:<br />
<em>Final Compiler development:</em><br />
Outputting generated code to js file.<br />
Researched top level functions.<br />
<em>Project</em><br />
Updated project structure.</p>
<p><strong>March</strong></p>
<p>March 05:<br />
<em>Report</em><br />
Chapter 4 almost done.<br />
<em>Project</em><br />
Improvements all around: bug fixes, documentation updates.</p>
<p>March 07:<br />
<em>Report</em><br />
Related work section<br />
Introduction chapter summarization<br />
<em>Final Compiler development:</em><br />
Attempt to implement operators array<br />
Looking into how to compile operator variables</p>
<p>March 08:<br />
<em>Report</em><br />
Background section<br />
<em>Final Compiler development:</em><br />
Various fixes<br />
operatorCompile function adjustment<br />
File Writer adjustment</p>
<p>March 09:<br />
<em>Report</em><br />
Related work section<br />
<em>Final Compiler development:</em><br />
Adjusted file generation<br />
Fixed operatorCompile function<br />
<em>Final Abstract Machine development:</em><br />
Initialized project structure with webpack<br />
Initial implementation of final Machine (support for CAR and CDR operations)</p>
<p>March 10:<br />
<em>Final Compiler development:</em><br />
Adjusted type definitions<br />
Added one layer of structure to Computations<br />
<em>Final Abstract Machine development:</em><br />
Fixed bugs regarding CAR and CDR<br />
Optimization- &quot;go&quot; tag is not needed, creating modes directly<br />
CDR now returns pair</p>
<p>March 11:<br />
<em>Final Compiler development:</em><br />
Added needed functionality to compiler to support 'application' operations<br />
<em>Final Abstract Machine development:</em><br />
Added functionality for FUN and ARG, still need to figure out how to apply a function to ready list</p>
<p>March 12:<br />
<em>Final Compiler development:</em><br />
Added parser functions, now the compiler is able to covert Shonky language to its syntax<br />
<em>Final Testing Framework development:</em><br />
Created initial structure of the framework as well as sample test case<br />
<em>Report</em><br />
Problem overview section</p>
<p>March 13:<br />
<em>Final Compiler development:</em><br />
Commands development<br />
<em>Final Abstract Machine development:</em><br />
Commands development<br />
<em>Report</em><br />
Specification section</p>
<p>March 14:<br />
<em>Final Compiler development:</em><br />
Bug fixes<br />
<em>Final Abstract Machine development:</em><br />
Bug fixes, command support implemented<br />
<em>Report</em><br />
Requirement analysis section<br />
<em>Project structure</em><br />
Frankjnr now uses new back end</p>
<p>March 15:<br />
</p>
<p>March 16:<br />
</p>
<p>March 17:<br />
Test framework development<br />
Compiler and Machine - added Built in function support<br />
Machine Print function development</p>
<p>March 18:<br />
Report work - Final implementation section and appendixes</p>
<p>March 19:<br />
Report:<br />
Abstract machine sections<br />
March 20:<br />
Report:<br />
Testing and validation sections<br />
# Appendix 2: Usage &amp; installation instructions {.unnumbered}</p>
<p><strong>Experimental test framework</strong></p>
<p><em>Pre-requirements</em></p>
<ul>
<li>Node;</li>
<li>npm;</li>
<li>Webpack;</li>
<li>GHC;</li>
<li>Expect Script - install by typing this command:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    <span class="ex">apt-get</span> install expect</code></pre></div>
<p><em>Usage</em></p>
<p>To run simply type in the terminal window:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tester.sh</span></code></pre></div>
<p><em>Troubleshooting</em></p>
<p>If files don't have permission, do:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">chmod</span> +x tester.sh
<span class="fu">chmod</span> +x helper.sh</code></pre></div>
<p><strong>Final test framework</strong></p>
<p><em>Pre-requirements</em></p>
<ul>
<li>Node;</li>
<li>npm;</li>
<li>Webpack;</li>
<li>GHC;</li>
<li>Frank - instructions how to setup are on Frankjnr Github <em>readme.md</em> fie or in the Appendix 4 of this report.</li>
</ul>
<p><em>Usage</em></p>
<p>To run simply type in the terminal window:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tester.sh</span></code></pre></div>
<p>You should be able to see tests going through with some feedback.</p>
<p><em>Troubleshooting</em></p>
<p>If <em>tester.sh</em> have issues with permission, do:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">chmod</span> +x tester.sh</code></pre></div>
<h1 id="appendix-3-test-cases" class="unnumbered">Appendix 3: Test cases</h1>
<h2 id="experimental-system" class="unnumbered">Experimental system</h2>
<p>This is a full list of experimental system's test cases. &quot;expr&quot; - is expression to be tested, &quot;name&quot; - the name of the test and &quot;expected&quot; is expected output.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test0=(</span> <span class="co">#value</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 10&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_num&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;10&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test1=(</span> <span class="co">#addition</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :+: (Val 4 :+: Val 8)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_sum&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;14&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test2=(</span> <span class="co"># Throw</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :+: (Val 4 :+: Throw)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_throw&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;Unhandled exception!&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test3=(</span> <span class="co"># Catch</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Catch (Val 2 :+:</span>
<span class="st">             (Val 4 :+: Throw)) (Val 2)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_catch&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;2&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test4=(</span> <span class="co"># Catch with previous stack</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = ((Val 5) :+: (Catch (Val 2 :+:</span>
<span class="st">                         (Val 4 :+: Throw)) (Val 2)))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_catch_stack&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;7&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test5=(</span> <span class="co"># Simple WithRef, value is not used</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2) </span>
<span class="st">                            (Val 5 :+: Val 3)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_simple_withref&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;8&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test6=(</span> <span class="co">#undifined variable</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Get &quot;x&quot; :+: Val 2&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_get_false&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;Exception: Undifined expression: x&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test7=(</span> <span class="co">#adding defined variable </span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2)</span>
<span class="st">                         (Val 5 :+: (Get &quot;x&quot;))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;7&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test8=(</span> <span class="co"># composition and variable defintion</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2)</span>
<span class="st">                 ((&quot;x&quot; := (Get &quot;x&quot; :+: Val 11))</span>
<span class="st">                  :&gt; Get &quot;x&quot;)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get_set&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;13&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test9=(</span> <span class="co"># same as test 8 but plus addition </span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 22)</span>
<span class="st">                         (&quot;x&quot; := (Get &quot;x&quot; :+: Val 11)</span>
<span class="st">                             :&gt; (Get &quot;x&quot; :+: Val 30))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get_set_next&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;63&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test10=(</span> <span class="co"># composition test</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :&gt; Val 5 :+: Val 8</span>
<span class="st">                     :&gt; Val 1000 :&gt; Val 20 :+: Val 3&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_next&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;23&#39;</span>
)</code></pre></div>
<h2 id="final-system" class="unnumbered">Final system</h2>
<p>Below is a list of all test programs for the final system:</p>
<h3 id="new-test-programs" class="unnumbered">New test programs</h3>
<p><strong>Test program 1:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/add.fk&quot;.<br />
Description: Peano number addition.<br />
Expected result: suc suc zero.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> add (suc zero) (suc zero) 

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero <span class="fu">|</span> suc <span class="dt">Nat</span>

add <span class="fu">:</span> {<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>}
add zero b <span class="fu">=</span> b
add (suc a) b <span class="fu">=</span> suc (add a b)   </code></pre></div>
<p><strong>Test program 2:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/command.fk&quot;.<br />
Description: command test.<br />
Expected result: pr zero (suc zero).<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 3:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/int.fk&quot;.<br />
Description: integer value test.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p><strong>Test program 4:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intAdd.fk&quot;.<br />
Description: integer addition test.<br />
Expected result: 20.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">10</span> <span class="fu">+</span> <span class="dv">10</span></code></pre></div>
<p><strong>Test program 5:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intMinus.fk&quot;.<br />
Description: integer minus test.<br />
Expected result: 10.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">20</span> <span class="fu">-</span> <span class="dv">10</span></code></pre></div>
<p><strong>Test program 6:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intCommand.fk&quot;.<br />
Description: integer values with commands.<br />
Expected result: pr 0 1.<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 7:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intList.fk&quot;.<br />
Description: list with integer values.<br />
Expected result: 1 2 3.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">List</span> <span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p><strong>Test program 8:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intLocal.fk&quot;.<br />
Description: local functions with integer values.<br />
Expected result: pr [0, 1, 2] [0, 1, 2].<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 9:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intOperator.fk&quot;.<br />
Description: operator call with integer value.<br />
Expected result: 3.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> plusOne(<span class="dv">2</span>)

plusOne <span class="fu">:</span> {<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>}
plusOne x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p><strong>Test program 10:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/lists.fk&quot;.<br />
Description: list test.<br />
Expected result: zero, suc zero, suc suc zero.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">List</span> <span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> [zero, suc zero, zero]

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero 
         <span class="fu">|</span> suc <span class="dt">Nat</span></code></pre></div>
<p><strong>Test program 11:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/local.fk&quot;.<br />
Description: local function test.<br />
Expected result:<br />
pr [zero, suc zero, suc suc zero] [zero, suc zero, suc suc zero].<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 12:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/operator.fk&quot;.<br />
Description: list test.<br />
Expected result: suc zero.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> plusOne(zero)

plusOne <span class="fu">:</span> {<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>}
plusOne x <span class="fu">=</span> suc x

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero 
         <span class="fu">|</span> suc <span class="dt">Nat</span></code></pre></div>
<h3 id="old-test-programs" class="unnumbered">Old test programs</h3>
<p>These programs are all lifted from &quot;Frankjnr&quot; implementation tests folder.</p>
<p><strong>Test program 13:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/app.fk&quot;.<br />
Description: application test.<br />
Expected result: 42.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> app {f <span class="ot">-&gt;</span> f <span class="dv">42</span>} {x <span class="ot">-&gt;</span> x}

app <span class="fu">:</span> {{<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>} <span class="ot">-&gt;</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>}
app f x <span class="fu">=</span> f x</code></pre></div>
<p><strong>Test program 14:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/evalState.fk&quot;.<br />
Description: hello world.<br />
Expected result: &quot;Hello World!&quot;.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">String</span>
main<span class="fu">!</span> <span class="fu">=</span> evalState <span class="st">&quot;Hello&quot;</span> (put (append get<span class="fu">!</span> <span class="st">&quot; World!&quot;</span>); get<span class="fu">!</span>)

append <span class="fu">:</span> <span class="dt">List</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">X</span>
append nil ys <span class="fu">=</span> ys
append (cons x xs) ys <span class="fu">=</span> cons x (append xs ys)

interface <span class="dt">State</span> <span class="dt">X</span> <span class="fu">=</span> get <span class="fu">:</span> <span class="dt">X</span>
              <span class="fu">|</span> put <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>

evalState <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="fu">&lt;</span><span class="dt">State</span> <span class="dt">X</span><span class="fu">&gt;</span><span class="dt">Y</span>    <span class="ot">-&gt;</span> <span class="dt">Y</span>
evalState   x    <span class="fu">&lt;</span>put x&#39; <span class="ot">-&gt;</span> k<span class="fu">&gt;</span>  <span class="fu">=</span> evalState x&#39; (k unit)
evalState   x    <span class="fu">&lt;</span>get    <span class="ot">-&gt;</span> k<span class="fu">&gt;</span>  <span class="fu">=</span> evalState x (k x)
evalState   x         y         <span class="fu">=</span> y</code></pre></div>
<p><strong>Test program 15:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/fact.fk&quot;.<br />
Description: factorial.<br />
Expected result: 120.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> fact <span class="dv">5</span>

mult <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
mult <span class="dv">0</span> y <span class="fu">=</span> <span class="dv">0</span>
mult x y <span class="fu">=</span> y <span class="fu">+</span> mult (x<span class="fu">-</span><span class="dv">1</span>) y

fact <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> mult n (fact (n <span class="fu">-</span> <span class="dv">1</span>))</code></pre></div>
<p><strong>Test program 16:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/fib.fk&quot;.<br />
Description: Fibonacci generation and negative integer test.<br />
Expected result: 5.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> fib <span class="dv">5</span>

fib <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib <span class="dv">2</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)

minusTwoOnZero <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
minusTwoOnZero <span class="dv">0</span> <span class="fu">=</span> <span class="fu">-</span><span class="dv">2</span>
minusTwoOnZero n <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p><strong>Test program 17:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/flex-ab-eq.fk&quot;.<br />
Description: Regression for unifying effect-parametric datatype with flexible.<br />
Expected result: unit.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Unit</span>}
main<span class="fu">!</span> <span class="fu">=</span> boo foo<span class="fu">!</span>

interface <span class="dt">Eff</span> <span class="dt">X</span> <span class="fu">=</span> bang <span class="fu">:</span> <span class="dt">Unit</span>

<span class="kw">data</span> <span class="dt">Bar</span> <span class="fu">=</span> bar {<span class="dt">Unit</span>}

foo <span class="fu">:</span> [<span class="dt">Eff</span> <span class="dt">Bar</span>]<span class="dt">Unit</span>
foo<span class="fu">!</span> <span class="fu">=</span> unit

boo <span class="fu">:</span> <span class="fu">&lt;</span><span class="dt">Eff</span> <span class="dt">S</span><span class="fu">&gt;</span><span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>
boo   <span class="fu">&lt;</span>bang <span class="ot">-&gt;</span> k<span class="fu">&gt;</span> <span class="fu">=</span> boo k<span class="fu">!</span>
boo   unit        <span class="fu">=</span> unit</code></pre></div>
<p><strong>Test program 18:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/listMap.fk&quot;.<br />
Description: map a pure (addition) function over a list.<br />
Expected result: [[2], [3], [4]].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">List</span> (<span class="dt">List</span> <span class="dt">Int</span>)
main<span class="fu">!</span> <span class="fu">=</span> map {x <span class="ot">-&gt;</span> cons (x<span class="fu">+</span><span class="dv">1</span>) nil} (cons <span class="dv">1</span> (cons <span class="dv">2</span> (cons <span class="dv">3</span> nil)))

interface <span class="dt">State</span> <span class="dt">X</span> <span class="fu">=</span> get <span class="fu">:</span> <span class="dt">X</span>
              <span class="fu">|</span> put <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>

map <span class="fu">:</span> {a <span class="ot">-&gt;</span> b} <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
map f nil <span class="fu">=</span> nil
map f (cons x xs) <span class="fu">=</span> cons (f x) (map f xs)</code></pre></div>
<p><strong>Test program 19:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/paper.fk&quot;.<br />
Description: examples from the paper<br />
Expected result: &quot;do be &quot;.<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 20:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r3.fk&quot;.<br />
Description: compiler Nontermination Issue No. 3.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> iffy <span class="dt">True</span> {<span class="dv">1</span>} {<span class="dv">2</span>}

<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>

iffy <span class="fu">:</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> {<span class="dt">X</span>} <span class="ot">-&gt;</span> {<span class="dt">X</span>} <span class="ot">-&gt;</span> <span class="dt">X</span>
iffy <span class="dt">True</span> t _  <span class="fu">=</span> t<span class="fu">!</span>
iffy <span class="dt">False</span> _ f <span class="fu">=</span> f<span class="fu">!</span></code></pre></div>
<p><strong>Test program 21:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r4.fk&quot;.<br />
Description: problem with unifying abilities identified by Jack Williams (No. 4).<br />
Expected result: 42.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> [<span class="dt">Console</span>]<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> apply foo<span class="fu">!</span>

<span class="kw">data</span> <span class="dt">Bar</span> <span class="fu">=</span> <span class="dt">One</span> {<span class="dt">Int</span>}

apply <span class="fu">:</span> <span class="dt">Bar</span> [<span class="dt">Console</span>] <span class="ot">-&gt;</span> [<span class="dt">Console</span>]<span class="dt">Int</span>
apply (<span class="dt">One</span> f) <span class="fu">=</span> f<span class="fu">!</span>

foo <span class="fu">:</span> {<span class="dt">Bar</span> [<span class="dt">Console</span>]}
foo<span class="fu">!</span> <span class="fu">=</span> <span class="dt">One</span> {<span class="dv">42</span>}</code></pre></div>
<p><strong>Test program 22:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r5.fk&quot;.<br />
Description: Suspended computation datatype argument.<br />
Expected result: unit.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Unit</span>
main<span class="fu">!</span> <span class="fu">=</span> foo (just {unit})

<span class="kw">data</span> <span class="dt">Maybe</span> <span class="dt">X</span> <span class="fu">=</span> just <span class="dt">X</span> <span class="fu">|</span> nothing

foo <span class="fu">:</span> <span class="dt">Maybe</span> {<span class="dt">Unit</span>} <span class="ot">-&gt;</span> <span class="dt">Unit</span>
foo (just x) <span class="fu">=</span> x<span class="fu">!</span></code></pre></div>
<p><strong>Test program 23:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r7.fk&quot;.<br />
Description: issue with recursive call in suspended comp..<br />
Expected result: unit.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Unit</span>
main<span class="fu">!</span> <span class="fu">=</span> unit

interface <span class="dt">Receive</span> <span class="dt">X</span> <span class="fu">=</span> receive <span class="fu">:</span> <span class="dt">X</span>

on <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> {<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>} <span class="ot">-&gt;</span> <span class="dt">Y</span>
on x f <span class="fu">=</span> f x

receivePassthrough <span class="fu">:</span> <span class="fu">&lt;</span><span class="dt">Receive</span> <span class="dt">String</span><span class="fu">&gt;</span><span class="dt">X</span> <span class="ot">-&gt;</span> [<span class="dt">Receive</span> <span class="dt">String</span>]<span class="dt">X</span>
receivePassthrough x              <span class="fu">=</span> x
receivePassthrough <span class="fu">&lt;</span>receive <span class="ot">-&gt;</span> r<span class="fu">&gt;</span> <span class="fu">=</span>
  on receive<span class="fu">!</span> { s <span class="ot">-&gt;</span> receivePassthrough (r s) }</code></pre></div>
<p><strong>Test program 24:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/str.fk&quot;.<br />
Description: pattern matching list of strings.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> foo (cons <span class="st">&quot;abcd&quot;</span> nil)

foo <span class="fu">:</span> <span class="dt">List</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
foo (cons <span class="st">&quot;ab&quot;</span> (cons <span class="st">&quot;cd&quot;</span> nil)) <span class="fu">=</span> <span class="dv">0</span>
foo (cons <span class="st">&quot;abcd&quot;</span> nil) <span class="fu">=</span> <span class="dv">1</span>
foo _ <span class="fu">=</span> <span class="dv">2</span></code></pre></div>
<h1 id="appendix-4-relevant-readme-files" class="unnumbered">Appendix 4: Relevant README files</h1>
<h2 id="run-frank-in-browser" class="unnumbered">Run Frank in Browser</h2>
<h2 id="frankjnr-1" class="unnumbered">Frankjnr</h2>
<p>An implementation of the Frank programming language described in the paper ``Do be do be do'' by Sam Lindley, Conor McBride, and Craig McLaughlin, to appear at POPL 2017; preprint: https://arxiv.org/abs/1611.09259</p>
<p>Installation procedure</p>
<p>The easiest way to install <code>frank</code> is to use stack https://www.haskellstack.org), https://github.com/commercialhaskell/stack):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">stack</span> setup</code></pre></div>
<p>The above command will setup a sandboxed GHC system with the required dependencies for the project.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">stack</span> install</code></pre></div>
<p>The above command builds the project locally (<code>./.stack-work/...</code>) and then installs the executable <code>frank</code> to the local bin path (executing <code>stack path --local-bin</code> will display the path).</p>
<p>Running a Frank program</p>
<p>To run a <code>frank</code> program <code>foo.fk</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> foo.fk</code></pre></div>
<p>By default the entry point is <code>main</code>. Alternative entry points can be selected using the <code>--entry-point</code> option.</p>
<p>Some example <code>frank</code> programs can be found in <code>examples</code>. They should each be invoked with <code>--entry-point tXX</code> for an appropriate number <code>XX</code>. See the source code for details.</p>
<p>Optionally a https://github.com/pigworker/shonky file can be output with the <code>--output-shonky</code> option.</p>
<p>Limitations with respect to the paper</p>
<ul>
<li><p>Only top-level mutually recursive computation bindings are supported</p></li>
<li><p>Coverage checking is not implemented</p></li>
</ul>
<h2 id="report-template" class="unnumbered">Report template</h2>
<p>Template for writing a PhD thesis in Markdown</p>
<p>This repository provides a framework for writing a PhD thesis in Markdown. I used the template for my PhD submission to University College London (UCL), but it should be straightforward to adapt suit other universities too.</p>
<p>Citing the template</p>
<p>If you have used this template in your work, please cite the following publication:</p>
<blockquote>
<p>Tom Pollard et al. (2016). Template for writing a PhD thesis in Markdown. Zenodo. http://dx.doi.org/10.5281/zenodo.58490</p>
</blockquote>
<p>Why write my thesis in Markdown?</p>
<p>Markdown is a super-friendly plain text format that can be easily converted to a bunch of other formats like PDF, Word and Latex. You'll enjoy working in Markdown because:</p>
<ul>
<li>it is a clean, plain-text format...</li>
<li>...but you can use Latex when you need it (for example, in laying out mathematical formula).</li>
<li>it doesn't suffer from the freezes and crashes that some of us experience when working with large, image-heavy Word documents.</li>
<li>it automatically handles the table of contents, bibliography etc with Pandoc.</li>
<li>comments, drafts of text, etc can be added to the document by wrapping them in &lt;!-- --&gt;</li>
<li>it works well with Git, so keeping backups is straightforward. Just commit the changes and then push them to your repository.</li>
<li>there is no lock-in. If you decide that Markdown isn't for you, then just output to Word, or whatever, and continue working in the new format.</li>
</ul>
<p>Are there any reasons not to use Markdown?</p>
<p>There are some minor annoyances:</p>
<ul>
<li>if you haven't worked with Markdown before then you'll find yourself referring to the style-guide fairly often at first.</li>
<li>it isn't possible to add a short caption to tables <del>and figures</del> (<a href="https://github.com/tompollard/phd_thesis_markdown/pull/47">figures are now fixed</a>). This means that /listoftables includes the long-caption, which probably isn't what you want. If you want to include the list of tables, then you'll need to write it manually.</li>
<li>the style documents in this framework could be improved. The PDF and HTML outputs are acceptable, but <del>HTML and</del> Word needs work if you plan to output to this format.</li>
<li>... if there are more, please add them here.</li>
</ul>
<p>How is the template organised?</p>
<ul>
<li>README.md =&gt; these instructions.</li>
<li>License.md =&gt; terms of reuse (MIT license).</li>
<li>Makefile =&gt; contains instructions for using Pandoc to produce the final thesis.</li>
<li>output/ =&gt; directory to hold the final version.</li>
<li>source/ =&gt; directory to hold the thesis content. Includes the references.bib file.</li>
<li>source/figures/ =&gt; directory to hold the figures.</li>
<li>style/ =&gt; directory to hold the style documents.</li>
</ul>
<p>How do I get started?</p>
<ol style="list-style-type: decimal">
<li>Install the following software:
<ul>
<li>A text editor, like Sublime, which is what you'll use write the thesis.</li>
<li>A LaTex distribution.</li>
<li>Pandoc, for converting the Markdown to the output format of your choice. You may also need to install <a href="http://pandoc.org/demo/example19/Extension-citations.html">Pandoc cite-proc</a> to create the bibliography.</li>
<li>Install shortcaption module for Pandoc, with <code>pip install pandoc-shortcaption</code></li>
<li>Git, for version control.</li>
</ul></li>
<li>https://github.com/tompollard/phd_thesis_markdown/fork<br />
</li>
<li>Clone the repository onto your local computer (or <a href="https://github.com/tompollard/phd_thesis_markdown/archive/master.zip">download the Zip file</a>).<br />
</li>
<li><p>Navigate to the directory that contains the Makefile and type &quot;make pdf&quot; (or &quot;make html&quot;) at the command line to update the PDF (or HTML) in the output directory.<br />
<strong>In case of an error</strong> (e.g. <code>make: *** [pdf] Error 43</code>) run the following commands:</p>
<pre><code>sudo tlmgr install truncate
sudo tlmgr install tocloft
sudo tlmgr install wallpaper
sudo tlmgr install morefloats
sudo tlmgr install sectsty
sudo tlmgr install siunitx
sudo tlmgr install threeparttable
sudo tlmgr update l3packages
sudo tlmgr update l3kernel
sudo tlmgr update l3experimental</code></pre></li>
<li><p>Edit the files in the 'source' directory, then goto step 4.</p></li>
</ol>
<p>What else do I need to know?</p>
<p>Some useful points, in a random order:</p>
<ul>
<li>each chapter must finish with at least one blank line, otherwise the header of the following chapter may not be picked up.</li>
<li>add two spaces at the end of a line to force a line break.</li>
<li>the template uses <a href="http://johnmacfarlane.net/pandoc/README.html">John Macfarlane's Pandoc</a> to generate the output documents. Refer to this page for Markdown formatting guidelines.</li>
<li>PDFs are generated using the Latex templates in the style directory. Fonts etc can be changed in the tex templates.</li>
<li>To change the citation style, just overwrite ref_format.csl with the new style. Style files can be obtained from <a href="http://citationstyles.org/">citationstyles.org/</a></li>
<li>For fellow web developers, there is a Grunt task file (Gruntfile.js) which can be used to 'watch' the markdown files. By running <code>$ npm install</code> and then <code>$ npm run watch</code> the PDF and HTML export is done automatically when saving a Markdown file.</li>
<li>You can automatically reload the HTML page on your browser using LiveReload with the command <code>$ npm run livereload</code>. The HTML page will automatically reload when saving a Markdown file after the export is done.</li>
</ul>
<p>Contributing</p>
<p>Contributions to the template are encouraged! There are lots of things that could improved, like:</p>
<ul>
<li>finding a way to add short captions for the tables, so that the lists of tables can be automatically generated.</li>
<li>cleaning up the Latex templates, which are messy at the moment.</li>
<li>improving the style of Word and Tex outputs.</li>
</ul>
<p>Please fork and edit the project, then send a pull request.</p>

<!-- 
Do not edit this page.

References are automatically generated from the BibTex file (References.bib)

...which you should create using your reference manager.
-->
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Plotkin5">
<p>B. C. Pierce and D. N. Turner, 2000. <em>Local type inference</em>,</p>
</div>
<div id="ref-Match-bust">
<p>F.V. McBride, 1970. <em>Computer Aided Manipulation of Symbols</em>,</p>
</div>
<div id="ref-Plotkin7">
<p>G. D. Plotkin and J. Power, 2001a. <em>Adequacy for algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin2">
<p>G. D. Plotkin and J. Power, 2003. <em>Algebraic operations and generic effects</em>,</p>
</div>
<div id="ref-Plotkin3">
<p>G. D. Plotkin and J. Power, 2009. <em>Handlers of algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin">
<p>G. D. Plotkin and J. Power, 2002. <em>Notions of computation determine monads</em>,</p>
</div>
<div id="ref-Plotkin6">
<p>G. D. Plotkin and J. Power, 2001b. <em>Semantics for algebraic operations</em>,</p>
</div>
<div id="ref-Plotkin4">
<p>G. D. Plotkin and M. Pretnar, 2013. <em>Handling algebraic effects</em>,</p>
</div>
<div id="ref-CompilingCorrectly">
<p>Graham Hutton and Joel Wrigh, 2004. <em>Compiling Exceptions Correctly</em>,</p>
</div>
<div id="ref-Tree-switching">
<p>Lennart Augustsson, 1985. <em>Functional Programming and Computer Architecture</em>,</p>
</div>
<div id="ref-FrankPaper">
<p>Sam Lindley, Conor McBride &amp; Craig McLaughlin, 2016. <em>Do be do be do</em>,</p>
</div>
<div id="ref-LambdaLifting">
<p>Thomas Jonson, 1985. <em>Springer LNCS 201</em>,</p>
</div>
</div>
            </body>
</html>

