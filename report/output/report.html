<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <title></title>
        <style type="text/css">code{white-space: pre;}</style>
                            <style type="text/css">
            div.sourceCode { overflow-x: auto; }
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
              margin: 0; padding: 0; vertical-align: baseline; border: none; }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code > span.dt { color: #902000; } /* DataType */
            code > span.dv { color: #40a070; } /* DecVal */
            code > span.bn { color: #40a070; } /* BaseN */
            code > span.fl { color: #40a070; } /* Float */
            code > span.ch { color: #4070a0; } /* Char */
            code > span.st { color: #4070a0; } /* String */
            code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code > span.ot { color: #007020; } /* Other */
            code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code > span.fu { color: #06287e; } /* Function */
            code > span.er { color: #ff0000; font-weight: bold; } /* Error */
            code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            code > span.cn { color: #880000; } /* Constant */
            code > span.sc { color: #4070a0; } /* SpecialChar */
            code > span.vs { color: #4070a0; } /* VerbatimString */
            code > span.ss { color: #bb6688; } /* SpecialString */
            code > span.im { } /* Import */
            code > span.va { color: #19177c; } /* Variable */
            code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code > span.op { color: #666666; } /* Operator */
            code > span.bu { } /* BuiltIn */
            code > span.ex { } /* Extension */
            code > span.pp { color: #bc7a00; } /* Preprocessor */
            code > span.at { color: #7d9029; } /* Attribute */
            code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            </style>
                                            <style>
            body {
                font-family: Georgia;
                max-width: 800px;
                margin: 0 auto;
                line-height: 30px;
                font-size: 18px;
                padding-left: 350px;
                padding-right: 50px;
                color: #111;
            }
            
            h1, h2, h3, h4, h5, h6 {
                font-family: Arial;
            }
            
            h1 {
                padding-top: 200px;
                line-height: 50px;
            }
            h2 {
                padding-top: 30px;
            }
            h3 {
                padding-top: 20px;
            }
            h4 {
                padding-top: 10px;
            }
            p {
                text-align: justify;
            }
            p a {
                word-wrap: break-word;
                white-space: pre;
            }
            code {
                word-wrap: break-word;
            }
            blockquote {
                border-left: 3px solid #eee;
                margin-left: 20px;
                padding-left: 20px;
            }
            
            ::selection {
                background-color: #E4E4E4;
            }
            
            table {
                width: 100%;
            }
            table caption {
                font-weight: bold;
            }
            table tr {
                padding: 0;
                margin: 0;
                background-color: #f0f0f0;
            }
            table tr.even {
                background-color: #fafafa;
            }
            table td {
                margin: 0;
                padding: 3px 5px;
            }
            
            p span.added {
                color: green;
                background-color: #FFF3C5;
            }
            p span.removed {
                color: red;
                background-color: #FFF3C5;
            }
            
            #title-page {
                padding: 80px 0;
            }
            
            #TOC {
                position: fixed;
                left: 0;
                top: 0;
                overflow-y: scroll;
                height: 100%;
                background: #fafafa;
                max-width: 300px;
                font-family: Arial;
                font-size: 15px;
                line-height: 30px;
            }
            ::-webkit-scrollbar {
                width: 8px;
            }
            ::-webkit-scrollbar-track {
                background-color: #ECECEC;
            }
            ::-webkit-scrollbar-thumb {
                background-color: #B0B0B0;
                border-radius: 8px;
            }
            #TOC > ul {
                padding-right: 10px;
            }
            #TOC ul {
                list-style: none;
                padding-left: 20px;
            }
            #TOC ul li a {
                text-decoration: none;
                color: #364149;
                text-overflow: ellipsis;
                display: block;
                white-space: nowrap;
                overflow: hidden;
            }
            #TOC ul li a:hover {
                color: #008cff;
            }
            
            .figure {
                text-align: center;
            }
            .figure p {
                text-align: center;
                font-style: italic;
            }
            .figure img {
                  width: 100%;
            }
            </style>
                <script src="js/jquery.js"></script>
        <script src="js/diff.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
                <!--
                -->
        <div id="title-page">
            <h1>This is the title of the thesis</h1>
            <h2>Firstname Surname</h2>
        </div>
                    <div id="TOC">
                <ul>
                <li><a href="#abstract">Abstract</a></li>
                <li><a href="#acknowledgements">Acknowledgements</a></li>
                <li><a href="#list-of-figures">List of figures</a></li>
                <li><a href="#list-of-tables">List of tables</a></li>
                <li><a href="#abbreviations">Abbreviations</a></li>
                <li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
                <li><a href="#background"><span class="toc-section-number">1.1</span> Background</a></li>
                <li><a href="#objectives"><span class="toc-section-number">1.2</span> Objectives</a></li>
                <li><a href="#summary-of-chapters"><span class="toc-section-number">1.3</span> Summary of chapters</a></li>
                </ul></li>
                <li><a href="#related-work"><span class="toc-section-number">2</span> Related Work</a><ul>
                <li><a href="#shonky"><span class="toc-section-number">2.1</span> <a href="https://github.com/pigworker/shonky">Shonky</a></a></li>
                <li><a href="#frankjnr"><span class="toc-section-number">2.2</span> <a href="https://github.com/cmcl/frankjnr">Frankjnr</a></a></li>
                <li><a href="#vole"><span class="toc-section-number">2.3</span> <a href="https://github.com/pigworker/Vole">Vole</a></a></li>
                <li><a href="#development-tools-and-languages"><span class="toc-section-number">2.4</span> Development Tools and Languages</a><ul>
                <li><a href="#vagrant"><span class="toc-section-number">2.4.1</span> <a href="https://www.vagrantup.com/">Vagrant</a></a></li>
                <li><a href="#webpack"><span class="toc-section-number">2.4.2</span> <a href="https://webpack.github.io/">Webpack</a></a></li>
                <li><a href="#javascript"><span class="toc-section-number">2.4.3</span> JavaScript</a></li>
                <li><a href="#haskell"><span class="toc-section-number">2.4.4</span> <a href="https://wiki.haskell.org">Haskell</a></a></li>
                <li><a href="#report-markdown"><span class="toc-section-number">2.4.5</span> <a href="https://github.com/tompollard/phd_thesis_markdown">Report Markdown</a></a></li>
                <li><a href="#bash-script"><span class="toc-section-number">2.4.6</span> Bash script</a></li>
                </ul></li>
                <li><a href="#conclusion"><span class="toc-section-number">2.5</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#problem-description-and-specification"><span class="toc-section-number">3</span> Problem Description and Specification</a><ul>
                <li><a href="#problem-overview"><span class="toc-section-number">3.1</span> Problem overview</a><ul>
                <li><a href="#project-risks"><span class="toc-section-number">3.1.1</span> Project risks</a></li>
                </ul></li>
                <li><a href="#requirements-analysis"><span class="toc-section-number">3.2</span> Requirements Analysis</a></li>
                <li><a href="#specification"><span class="toc-section-number">3.3</span> Specification</a><ul>
                <li><a href="#functional-requirements"><span class="toc-section-number">3.3.1</span> Functional requirements</a></li>
                <li><a href="#non-functional-requirements"><span class="toc-section-number">3.3.2</span> Non-functional requirements</a></li>
                <li><a href="#use-cases"><span class="toc-section-number">3.3.3</span> Use Cases</a></li>
                </ul></li>
                <li><a href="#design-methodology"><span class="toc-section-number">3.4</span> Design Methodology</a></li>
                </ul></li>
                <li><a href="#initial-development-experimental-system"><span class="toc-section-number">4</span> Initial development &amp; experimental system</a><ul>
                <li><a href="#introduction-1"><span class="toc-section-number">4.1</span> Introduction</a></li>
                <li><a href="#experimental-system"><span class="toc-section-number">4.2</span> Experimental system</a><ul>
                <li><a href="#language"><span class="toc-section-number">4.2.1</span> Language</a></li>
                <li><a href="#compiler"><span class="toc-section-number">4.2.2</span> Compiler</a></li>
                <li><a href="#abstract-machine"><span class="toc-section-number">4.2.3</span> Abstract machine</a></li>
                </ul></li>
                <li><a href="#conclusion-1"><span class="toc-section-number">4.3</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#detailed-design-and-implementation-of-the-final-system"><span class="toc-section-number">5</span> Detailed Design and Implementation of the final system</a><ul>
                <li><a href="#introduction-2"><span class="toc-section-number">5.1</span> Introduction</a><ul>
                <li><a href="#disclaimer"><span class="toc-section-number">5.1.1</span> Disclaimer</a></li>
                </ul></li>
                <li><a href="#projects-folder-structure"><span class="toc-section-number">5.2</span> Project's folder structure</a></li>
                <li><a href="#compiler-1"><span class="toc-section-number">5.3</span> Compiler</a><ul>
                <li><a href="#full-compilation-example"><span class="toc-section-number">5.3.1</span> Full compilation example</a></li>
                <li><a href="#helper-functions"><span class="toc-section-number">5.3.2</span> Helper functions</a></li>
                </ul></li>
                <li><a href="#abstract-machine-1"><span class="toc-section-number">5.4</span> Abstract machine</a><ul>
                <li><a href="#javascript-type-definitions"><span class="toc-section-number">5.4.1</span> JavaScript type definitions</a></li>
                <li><a href="#implementation-1"><span class="toc-section-number">5.4.2</span> Implementation</a></li>
                <li><a href="#helper-functions-1"><span class="toc-section-number">5.4.3</span> Helper functions</a></li>
                </ul></li>
                <li><a href="#built-in-functions"><span class="toc-section-number">5.5</span> Built-in functions</a></li>
                <li><a href="#possible-improvements"><span class="toc-section-number">5.6</span> Possible improvements</a></li>
                </ul></li>
                <li><a href="#verification-and-validation"><span class="toc-section-number">6</span> Verification and Validation</a><ul>
                <li><a href="#experimental-testing-framework"><span class="toc-section-number">6.1</span> Experimental testing framework</a><ul>
                <li><a href="#bash-script-1"><span class="toc-section-number">6.1.1</span> Bash script</a></li>
                <li><a href="#expect-script"><span class="toc-section-number">6.1.2</span> Expect script</a></li>
                <li><a href="#possible-improvements-1"><span class="toc-section-number">6.1.3</span> Possible improvements</a></li>
                </ul></li>
                <li><a href="#final-testing-framework"><span class="toc-section-number">6.2</span> Final testing framework</a><ul>
                <li><a href="#implementation-2"><span class="toc-section-number">6.2.1</span> Implementation</a></li>
                <li><a href="#possible-improvements-2"><span class="toc-section-number">6.2.2</span> Possible improvements</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#results-and-evaluation"><span class="toc-section-number">7</span> Results and Evaluation</a><ul>
                <li><a href="#outcome"><span class="toc-section-number">7.1</span> Outcome</a><ul>
                <li><a href="#experimental-system-1"><span class="toc-section-number">7.1.1</span> Experimental system</a></li>
                <li><a href="#final-system"><span class="toc-section-number">7.1.2</span> Final system</a></li>
                </ul></li>
                <li><a href="#evaluation"><span class="toc-section-number">7.2</span> Evaluation</a><ul>
                <li><a href="#benchmark"><span class="toc-section-number">7.2.1</span> Benchmark</a></li>
                <li><a href="#functionality-comparison"><span class="toc-section-number">7.2.2</span> Functionality comparison</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#summary-conclusion"><span class="toc-section-number">8</span> Summary &amp; Conclusion</a><ul>
                <li><a href="#summary"><span class="toc-section-number">8.1</span> Summary</a></li>
                <li><a href="#future-work"><span class="toc-section-number">8.2</span> Future work</a></li>
                </ul></li>
                <li><a href="#appendix-1-progress-log">Appendix 1: Progress log</a></li>
                <li><a href="#appendix-2-usage-installation-instructions">Appendix 2: Usage &amp; installation instructions</a><ul>
                <li><a href="#final-system-1">Final system</a><ul>
                <li><a href="#requirements">Requirements</a></li>
                <li><a href="#setup-frank">Setup Frank</a></li>
                <li><a href="#compiling-and-executing-programs">Compiling and executing programs</a></li>
                <li><a href="#tests">Tests</a></li>
                <li><a href="#benchmark-1">Benchmark</a></li>
                </ul></li>
                <li><a href="#experimental-system-2">Experimental system</a><ul>
                <li><a href="#requirements-1">Requirements</a></li>
                <li><a href="#usage-1">Usage</a></li>
                <li><a href="#tests-1">Tests</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#appendix-3-test-cases">Appendix 3: Test cases</a><ul>
                <li><a href="#experimental-system-3">Experimental system</a></li>
                <li><a href="#final-system-2">Final system</a><ul>
                <li><a href="#new-test-programs">New test programs</a></li>
                <li><a href="#old-test-programs">Old test programs</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#appendix-4-relevant-readme-files">Appendix 4: Relevant README files</a><ul>
                <li><a href="#run-frank-in-browser">Run Frank in Browser</a></li>
                <li><a href="#frankjnr-1">Frankjnr</a></li>
                <li><a href="#report-template">Report template</a></li>
                </ul></li>
                <li><a href="#appendix-5-initial-project-specification-and-plan">Appendix 5: Initial project specification and plan</a><ul>
                <li><a href="#functional-requirements-1">Functional requirements</a></li>
                <li><a href="#non-functional-requirements-1">Non-functional requirements</a></li>
                <li><a href="#technologies">Technologies</a></li>
                <li><a href="#software-development-process">Software development process</a></li>
                <li><a href="#project-evaluation">Project evaluation</a></li>
                <li><a href="#risks">Risks</a></li>
                </ul></li>
                <li><a href="#references">References</a></li>
                </ul>
            </div>
                                
<h1 id="abstract" class="unnumbered">Abstract</h1>
<!-- This is the abstract -->
<p>Frank is a strongly typed, strict functional programming language invented by Dr. Sam Lindley and Dr. Conor McBride. It is influenced by Paul Blain Levy’s call-by-push-value calculus, and features a bidirectional effect type system, effect polymorphism, as well as effect handlers. This means that Frank supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when a command is complete, depending on the handler, the system could resume from the point it was suspended. Handlers are very similar to typical functions, but their argument processes can communicate in more advanced ways. The idea is to utilize this functionality in the web. Side-effects might be various events such as mouse actions, http requests, etc., and the handler would be the application in the web page.</p>
<p>The overarching goal of the project is to compile Frank to JavaScript and to run it in the browser. Users would thus be able to use Frank for web development purposes. This involves creating a Compiler and a Virtual Machine (abstract machine) which can support a compiled Frank structure.</p>
<p> </p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<!-- This is for acknowledging all of the people who helped out -->
<p>I would like to express my special thanks and gratitude to my supervisor, Conor McBride for his guidance, support and patience throughout this project.</p>
<p>Also, I would like to thank my friends for helping me think through problems during our numerous technical discussions and contemplations.</p>
<!-- Use the \newpage command to force a new page -->




<h1 id="list-of-figures" class="unnumbered">List of figures</h1>
<!--
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.


Figure 4.1  This is an example figure . . .              \hfill{pp}  
Figure x.x  Short title of the figure . . .              \hfill{pp}  
-->
<p> </p>

<h1 id="list-of-tables" class="unnumbered">List of tables</h1>
<!-- 
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.
-->
<p>Table 5.1 This is an example table . . . <br />
Table x.x Short title of the figure . . . </p>
<h1 id="abbreviations" class="unnumbered">Abbreviations</h1>


<p> </p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This chapter focuses on explaining the project motivation and objectives. Also, in the last section, the report structure is displayed.</p>
<h2 id="background"><span class="header-section-number">1.1</span> Background</h2>
<p>Functional languages are evolving and constantly changing in order to adapt to innovations and the ever-changing needs of software engineering. Stemming from this, the concept of Frank language was created by Dr. Conor McBride and Dr. Sam Lindley, followed by its implementation named “Frank” and the more recent release - “Frankjnr”.</p>
<p>“Frank”is a strongly typed, strict functional programming language designed around Plotkin and Pretnar’s effect handler abstraction, strongly influenced by <span class="citation">(B. C. Pierce and D. N. Turner 2000)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001b)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001a)</span>, <span class="citation">(G. D. Plotkin and J. Power 2002)</span>, <span class="citation">(G. D. Plotkin and J. Power 2003)</span>, <span class="citation">(G. D. Plotkin and J. Power 2009)</span>, <span class="citation">(G. D. Plotkin and M. Pretnar 2013)</span> papers on algebraic effects and handlers for algebraic effects. It is also influenced by Paul Blain Levy’s call-by-push-value calculus. Frank features a bidirectional effect type system, effect polymorphism, and effect handlers; Frank thus supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when a command is complete, depending on the handler, the system could resume from the point it was suspended. Handlers are very similar to typical functions, but their argument processes can communicate in more advanced ways.</p>
<p>Because of the distinct features of Frank, in particular its capability to support effects and handlers, it has potential to be used in the context of web development. However, neither of Frank’s implementations currently support this. Therefore, the main intention of this project is to enable the usage of Frank for web development. Using a functional language for web development could greatly ease the process of writing parsers and form validations on the web. Essentially, Frank code would be converted into JavaScript because of its support for functional programming. Frank would potentially gain all of the JavaScript functionality and could even use JavaScript third-party libraries. For example, Frank would be able to handle different http requests, such as GET or POST; it could fire events (ex. alert boxes), and handle events (ex. mouse clicks).</p>
<p>The most effective way to achieve this is to utilize the existing Frankjnr implementation, rewriting its Compiler and Abstract Machine (back end). The Compiler would take in parsed Frank code and output JavaScript which could be used by Abstract Machine at Run-time.</p>
<p>This projects requires comprehension regarding the ways Compilers and Abstract Machines work and knowledge on how to use them together. The author chose this project knowing that it would be challenging, but also recognizing the valuable learning experience.</p>
<h2 id="objectives"><span class="header-section-number">1.2</span> Objectives</h2>
<ul>
<li>Utilize Frankjnr implementation;</li>
<li>Utilize Shonky data structures;</li>
<li>Develop a compiler which compiles Shonky's data structures to JavaScript data types;</li>
<li>Develop an abstract machine implementation which supports the output of the compiler;</li>
<li>The completed system must facilitate client-side communication of events and DOM updates between Frank code and the browser.</li>
</ul>
<h2 id="summary-of-chapters"><span class="header-section-number">1.3</span> Summary of chapters</h2>
<p><strong>Chapter 2 - Related Work</strong></p>
<p>The aim of this chapter is to highlight work done by others that in some fashion ties in with this project. This includes work which the author directly uses as a bouncing-off point, work that shows other attempts to solve similar problems, as well as connected projects which have been partially used in the final implementation of the project. Moreover, chapter explains chosen development tools and languages and reasoning behind them.</p>
<p><strong>Chapter 3 - Problem Description and Specification</strong></p>
<p>This chapter briefly overviews the main problems and challenges of the project. It briefly explains the requirement analysis stage. It, also, expands upon functional and non-functional requirements, followed by a detailed specification and explanation of the design methodology.</p>
<p><strong>Chapter 4 - Initial development &amp; experimental system</strong></p>
<p>This chapter is focused on an initial experimental system. It highlights the reasoning behind it, the purpose of each component, their implementation, drawbacks and any potential improvements.</p>
<p><strong>Chapter 5 - Detailed Design and Implementation of the final system</strong></p>
<p>The chapter reflects upon the implementation and design of the final compiler and the abstract machine. It also explains the project structure, the developed testing framework, project connections between Shonky and Frankjnr, as well as possible improvements and alternative approaches to be considered.</p>
<p><strong>Chapter 6 - Verification and Validation</strong></p>
<p>This chapter explains how the outcome of the project was validated and what testing procedures were followed during and after the project.</p>
<p><strong>Chapter 7 - Results and Evaluation</strong></p>
<p>The principal intention of the chapter is to summarize the outcome of the project and to describing how it was evaluated.</p>
<p><strong>Chapter 8 - Summary &amp; Conclusion</strong></p>
<p>This chapter summarizes the project while highlighting valuable lessons learned by the author and proposes relevant future work.</p>
<h1 id="related-work"><span class="header-section-number">2</span> Related Work</h1>
<h2 id="shonky"><span class="header-section-number">2.1</span> <a href="https://github.com/pigworker/shonky">Shonky</a></h2>
<p>Shonky is an untyped and impure functional programming language created by Conor McBride. The key feature of Shonky is that it supports the local handling of the computational effect, using a regular application syntax. This means that a single process can coroutine multiple other sub-processes; apart from the fact that it does not have type support, it is very similar to Frank. Its interpreter is written in Haskell, although it has potential to be ported to JavaScript or PHP to support web operations.</p>
<p>In the project, Shonky language data structures are used by the abstract machine; <strong>Chapter 5</strong> covers in detail both how and why they are used. However, Shonky interpreter is completely scrapped and is only used as a reference in solving any Abstract Machine or Compiler difficulties.</p>
<h2 id="frankjnr"><span class="header-section-number">2.2</span> <a href="https://github.com/cmcl/frankjnr">Frankjnr</a></h2>
<p>Frankjnr is the newest implementation of Frank functional programming language described in &quot;<em>Do be do be do</em>&quot; <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span> paper. Frankjnr has a parser for Frank syntax, thus allowing the user to utilize Frank in writing expressions. After parsing Frank code it performs a type check and other necessary operations followed by a compilation to Shonky-supported data structures, which are then used by Shonky interpreter to run Frank.</p>
<h2 id="vole"><span class="header-section-number">2.3</span> <a href="https://github.com/pigworker/Vole">Vole</a></h2>
<p>Vole is a lightweight functional programming language implemented by Conor McBride. It has its own compiler and two matching interpreters. One of the abstract machines is written in Haskell and provides the opportunity to run compiled Vole programs on the local environment. The other machine is written in JavaScript, thus making it possible to run Vole programs on the web. There are a few working examples in the git repository of Vole. It also has some support for effects and handlers, so it utilizes the ability to communicate between compiled Vole programs and the front-end of applications, on run-time.</p>
<p>In terms of its relevance to this project, Vole is a useful resource because it essentially tries to solve the same problem, only for a different language. The author had to study Vole in order to understand its technical implementation, along with its usage of resources, while also enhancing his knowledge of compilers and abstract machines. Lastly, Vole is used for evaluation purposes as another benchmark comparison.</p>
<h2 id="development-tools-and-languages"><span class="header-section-number">2.4</span> Development Tools and Languages</h2>
<p>This section will briefly explain tools and languages used, and the reasoning behind each of them.</p>
<h3 id="vagrant"><span class="header-section-number">2.4.1</span> <a href="https://www.vagrantup.com/">Vagrant</a></h3>
<p>Vagrant is an optional tool which was used to create a separate development environment for the project. It runs on Virtual Box and is essentially a server on one’s local computer for booting up and working. Vagrant comes with up-to-date, relevant libraries out of the box. The author used it to maintain a clean environment and to avoid the installation of software and library management on the local machine, thus speeding up development.</p>
<h3 id="webpack"><span class="header-section-number">2.4.2</span> <a href="https://webpack.github.io/">Webpack</a></h3>
<p>Webpack is a module builder and is available as an npm package. In this project, it is used for abstract machine development, as it adds desired flexibility to plain JavaScript, and compiles everything into a single light JavaScript file. The most important feature of webpack is its ability to create and export different modules; for example, a module could be either a function or a variable. This feature allows for an improved project structure as the user is able to keep JavaScript components in separate files, which makes it easier to develop, maintain and navigate through code.</p>
<h3 id="javascript"><span class="header-section-number">2.4.3</span> JavaScript</h3>
<p>JavaScript is a client side scripting language. In this project, the output of the compiler is generated in JavaScript, which is then used by the virtual machine, also written in JavaScript, so that both can cooperate on run time without any further compilations.</p>
<p>JavaScript is used because of its key features. Firstly, it has support for functional programming by letting function arguments be other functions. Secondly, it is supported by all popular browsers. JavaScript also has lots of libraries and features which support web development.</p>
<h3 id="haskell"><span class="header-section-number">2.4.4</span> <a href="https://wiki.haskell.org">Haskell</a></h3>
<p>Haskell is a static, implicitly-typed, and standardized functional programming language with non-strict semantics. Haskell’s features include support for recursive functions, data types, pattern matching, and list comprehensions. Haskell was chosen for compiler development because of its functional language features, such as pattern-matching, efficient recursion, and support for monadic structures. Frankjnr and Shonky are written in Haskell as well; so using Haskell provides an easier compatibility with those projects.</p>
<h3 id="report-markdown"><span class="header-section-number">2.4.5</span> <a href="https://github.com/tompollard/phd_thesis_markdown">Report Markdown</a></h3>
<p>This report adapted the template of a markdown developed by Tom Pollard, because of its flexible structure and features, such as its support for Pandoc markdown and latex expressions. The report is divided into separate source files, which produces a cohesive project structure, and every source file is compiled into a single pdf file using a compiler powered by <em>npm</em>.</p>
<h3 id="bash-script"><span class="header-section-number">2.4.6</span> Bash script</h3>
<p>Bash script is a series of command line instructions placed into a single file. It is generally used for automation and, in this project, it is used to build automated test cases.</p>
<h2 id="conclusion"><span class="header-section-number">2.5</span> Conclusion</h2>
<p>The main three related projects are Vole, Shonky and Frankjnr. Vole is employed as a working example of a solution to address a similar problem, which encouraged the author to experiment with different approaches. Shonky and Frankjnr are used directly, because Frankjnr is the newest implementation of Frank language and it uses Shonky’s interpreter for executing Frank programs. The intention was to take the existing Frankjnr and replace Shonky’s interpreter with a new compiler and abstract machine, which would support web development while keeping Shonky’s syntax data structures.</p>
<h1 id="problem-description-and-specification"><span class="header-section-number">3</span> Problem Description and Specification</h1>
<p>This section discusses the project’s problem, challenges, requirements and risks involved.</p>
<h2 id="problem-overview"><span class="header-section-number">3.1</span> Problem overview</h2>
<p>The main aim of the project was to develop a new compiler and a corresponding abstract machine for the new implementation of the functional language Frank, called Frankjnr. The differential characteristic for the new compiler and abstract machine is the fact that they would support web development. This gives rise to multiple challenges, the initial one being the author’s initial lack of knowledge of Frank. As it is a complex language, the author had to invest effort in order to comprehend it, enquiring the paper on Frank, “Do be do be do” <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span>.</p>
<p>Another challenge was overcoming the complexity of the existing systems. Due to the fact that this project is not a standalone, it depends largely on Shonky’s syntax implementation as well as Frankjnr’s handling of Frank code. The author had to take time to scrupulously research the existing systems to discern all the intricacies and interconnections, and to devise means to efficiently replace the existing Shonky interpreter with a new compiler and abstract machine.</p>
<p>One of the challenges was the complex nature of compilers and abstract machines. This was the most difficult challenge to overcome due to the breadth of conceptual detail both of them contain. An incremental approach was therefore adapted, in order for the author to learn gradually, starting from less sophisticated concepts. The author thus started the project by developing an experimental system with its own language, compiler and virtual machine in order to understand the crucial concepts of a compiler and abstract machines. During the early course of development, the author regularly consulted his supervisor Conor McBride regarding various issues relating to compilers and abstract machines.</p>
<p>Testing and validation also proved to be a challenge. As the project is focused on developing a completely new system without any usage of frameworks, a testing framework had to be developed; one which could run test cases and validate them without any interaction on the part of the user. The testing framework was developed by utilizing Bash script, Expect script languages, along with Node, webpack, and ghci commands. It was at first created for an experimental system and then progressively altered and improved for the final system, based on continuous observation and testing. In the end, it dramatically contributed in decreasing development time by locating bugs, especially through targeted test cases.</p>
<p>The project was extremely broad and involved a great deal of initial research as well as in-depth planning; development time was therefore slow, but productive. However, due to time constraints, some of the intended directions of development had to be disregarded, in order to to finish the prototype in time. One of these was the Haskell-enforced type checker. The Haskell compiler could have a type checker which would prevent any bugs related to generated JavaScript programs by enforcing its types. Such bugs are currently spotted by the console window of the browser or the testing framework. A Haskell-enforced type checker could potentially be one of key future developments.</p>
<h3 id="project-risks"><span class="header-section-number">3.1.1</span> Project risks</h3>
<ul>
<li>The dependence on Frank implementation (Frankjnr);</li>
<li>Estimating and scheduling development time. Due to author’s limited previous exposure to the subject, it proved difficult to anticipate the time and the resources required; however, regular meetings with the supervisor ensured that the project was kept on track.</li>
<li>The lack of available resources;</li>
<li>The author’s initial lack of experience with languages used, and the analyzed concepts (compilers and virtual machines).</li>
</ul>
<h2 id="requirements-analysis"><span class="header-section-number">3.2</span> Requirements Analysis</h2>
<p>Before development, requirements needed to be gathered. These were set out during a consultation with the supervisor regarding how the system should behave and what technologies it should utilize. In addition, the author attended a programming languages seminar where Frank language was discussed, thus gaining a practical perspective on the entire project. The author also read papers on relevant topics, such as &quot;Compiling Exceptions Correctly&quot; <span class="citation">(Graham Hutton and Joel J. Wright 2004)</span> in order to broaden his subject knowledge, which assisted in mapping out the direction of the project. Further research was done to ensure the appropriateness of chosen languages and technologies.</p>
<h2 id="specification"><span class="header-section-number">3.3</span> Specification</h2>
<h3 id="functional-requirements"><span class="header-section-number">3.3.1</span> Functional requirements</h3>
<ul>
<li>To create a new back end for Frankjnr implementation:
<ul>
<li>Develop a compiler which uses Shonky’s language (Syntax file) and outputs a sensible and correct JavaScript code structure;</li>
<li>Develop an abstract machine which can run previously compiled JavaScript code in the browser;</li>
</ul></li>
<li>To facilitate client-side communication of events and DOM updates between Frank code and the browser.</li>
</ul>
<h3 id="non-functional-requirements"><span class="header-section-number">3.3.2</span> Non-functional requirements</h3>
<ul>
<li>To create a set of tests which should pass before each new release of the system. Test cases should be increased after every iteration to validate new features and to ensure that previous features are not broken;</li>
<li>To develop a testing framework, which would test the system using the list of predetermined test cases;</li>
<li>To measure performance (in comparison with the existing back end and with other kinds of generated JavaScript);</li>
<li>Client-side programming should become possible (ex. complex parser of a text field).</li>
</ul>
<h3 id="use-cases"><span class="header-section-number">3.3.3</span> Use Cases</h3>
<p>Since the developed compiler and abstract machine support Frank language, which can potentially be used in an infinite number of ways, use cases are not relevant to this project. Generally, the user writes Frank programs; then compiles them in order to generate a JavaScript file. The user needs to include the re-compiled machine, which utilizes previously compiled code, into their project. For more detailed information on how to use the system, check the usage instructions in <strong>Appendix 2</strong>.</p>
<h2 id="design-methodology"><span class="header-section-number">3.4</span> Design Methodology</h2>
<p>The implementation of the project is fully focused on back-end development. The adopted design methodology was iterative and incremental development (IID). The main reasons behind choosing it included the difficult nature of the project and the author’s initial lack of knowledge on the subject. This particular methodology allows the developer to focus on a few features at a time, building the system incrementally, allowing for progressive learning.</p>
<p>Iterative and incremental development (IID) is a process which grows the system incrementally, one feature after another, during self-contained cycles of analysis, design, implementation and testing which end when the system is finished. This means that the system is improved (with more functionality added) through every Iteration.</p>
<p>The core benefits of this methodology include:</p>
<ul>
<li>Regression testing is conducted after each iteration, with only a few changes made through a single repetition; because of this, faulty elements of the software are easily identified and fixed before starting the subsequent iteration;</li>
<li>The testing of a system’s features is easier, because this methodology allows for targeted testing of each element within the system;</li>
<li>The system could easily shift directions of development after each iteration;</li>
<li>The learning curve is much flatter than usual, because the developer focuses on a selected few features at any given time.</li>
</ul>
<p>One of the other principal decisions was to start with a different system, an experiment throughout which the author could learn the fundamental concepts related to compilers and virtual machines and later on adapt the knowledge gained during the development of the final system. The experiment was conducted over approximately four weeks and used the same methodology - iterative and incremental development.</p>
<h1 id="initial-development-experimental-system"><span class="header-section-number">4</span> Initial development &amp; experimental system</h1>
<h2 id="introduction-1"><span class="header-section-number">4.1</span> Introduction</h2>
<p>Because of the complexity of the project and the lack of initial author knowledge of the field, the most optimal plan was to start with small, less demanding development and expand gradually. The intricacies consist of:</p>
<ul>
<li>Frank is a complex functional language;</li>
<li>&quot;Frankjnr&quot; adds another layer of complexity, since author needs to be aware of the implementation and compilation process;</li>
<li>Dependence on Shonky's language, because the final implementation of the Compiler must be able to understand and compile Shonky's data structures;</li>
<li>Complexity of the compilers and their implementation;</li>
<li>Complexity of abstract machines and their implementation;</li>
</ul>
<p>Thus, experimental language was developed with matching compiler and abstract machine. Both, the compiler and the machine were developed while keeping in mind that their key parts will be reused for the final system. So efficiency, reliability, structure were all important factors. Furthermore, experimental system was vastly influenced on concepts described in &quot;Compiling Exceptions Correctly&quot; <span class="citation">(Dexter Kozen and Carron Shankland 2004)</span> and &quot;Mathematics of Program Construction&quot; <span class="citation">(Graham Hutton and Joel J. Wright 2004)</span>.</p>
<h2 id="experimental-system"><span class="header-section-number">4.2</span> Experimental system</h2>
<p>System consists of:</p>
<ul>
<li>Compiler - written in Haskell;</li>
<li>Language - written in Haskell;</li>
<li>Machine - written in JavaScript, compiled with <em>webpack</em>;</li>
<li>Testing framework - written in Bash and Expect scripts, overview of the framework can be found in <strong>Chapter 6</strong>.</li>
</ul>
<h3 id="language"><span class="header-section-number">4.2.1</span> Language</h3>
<p>A simple language written in Haskell, which syntax supports few specific operations, such as, sum of two expressions, &quot;Throw&quot; &amp; &quot;Catch&quot;, &quot;Set&quot;, &quot;Next&quot;, &quot;Get&quot;, new reference. Each of the operations were carefully selected, where their implementation in the abstract machine varies significantly. Thus, offering broad and important learning experience.</p>
<p><strong>Full language definition</strong></p>
<p>Language is defined as Haskell data type &quot;Expr&quot;. In this case it supports only different types of expressions. Experimental language is focused on Integer manipulation, thus it only supports integer values. Here is a definition of a Integer value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Val</span> <span class="dt">Int</span></code></pre></div>
<p>Definition of sum of two expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:+:</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of a &quot;Throw&quot; and &quot;Catch&quot; commands. If the first expression of Catch is equal to Throw, meaning an exception was raised (something went wrong), then the second expression will be evaluated, otherwise it will be left unchecked.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Throw</span>
        <span class="fu">|</span> <span class="dt">Catch</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of &quot;WithRef&quot; command. It creates new reference with a given value. First string variable of the command defines name of new reference, second value is an expression which defines how to compute initial value of new reference and the third value is the context in which the reference is valid. &quot;WithRef&quot; stack frame is the handler for &quot;Get&quot; and &quot;:=&quot; commands. Example expression would be: <em>WithRef &quot;x&quot; (Val 2) (Val 5 :+: Get &quot;x&quot;)</em>. From the example we can see that &quot;x&quot; is a new reference with initial value of &quot;Val 2&quot; and its valid in a context <em>Val 5 :+: Get &quot;x&quot;</em>, which would return &quot;7&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">WithRef</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of getting the value of a defined reference.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Get</span> <span class="dt">String</span> </code></pre></div>
<p>Syntax definition of setting defined reference value to be equal to some new expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">String</span> <span class="fu">:=</span> <span class="dt">Expr</span> </code></pre></div>
<p>Syntax definition for evaluating two expressions one by one and taking value of the second. In most programming languages it is defined as &quot;;&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:&gt;</span> <span class="dt">Expr</span></code></pre></div>
<h3 id="compiler"><span class="header-section-number">4.2.2</span> Compiler</h3>
<p>Purpose of the compiler is to take in an formatted expression of the experimental language described above and output a JavaScript compiled data structure (array of functions, called resumptions), which could be used by the abstract machine.</p>
<p>Below is a definition of code generation monad. It contains a constructor &quot;MkCodeGen&quot; and a deconstructor &quot;codeGen&quot;. It takes in an next available integer value and outputs a data structure which holds a list of integers which map to JavaScript code of string type, next available number after the compilation and result of the compilation &quot;val&quot;. Usually, the list of definitions will start with the input &quot;next number&quot; and go up to just before the output &quot;next number&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">CodeGen</span> val <span class="fu">=</span> <span class="dt">MkCodeGen</span> {
<span class="ot">            codeGen ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> ([(<span class="dt">Int</span>, <span class="dt">String</span>)], <span class="dt">Int</span>, val) 
        }                </code></pre></div>
<p>&quot;MkCodeGen&quot; is used to construct a definition in &quot;genDef&quot; function displayed below. &quot;genDef&quot; returns the definition number and it is used by compile function to make new function definitions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genDef ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span> 
genDef code <span class="fu">=</span> <span class="dt">MkCodeGen</span> <span class="fu">$</span> \ next <span class="ot">-&gt;</span> ([(next, code)]
                            , next <span class="fu">+</span> <span class="dv">1</span>, next)</code></pre></div>
<p>Below the type of &quot;compile&quot; function is shown. &quot;compile&quot; function takes in a valid language expression and outputs entry point of the compilation as well as compilation process which can be separated into chucks of generated JavaScript code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span></code></pre></div>
<p>&quot;compile&quot; function is either used to create new function definitions or to compile expressions to JavaScript depending on the type of &quot;Expr&quot;. For example, if &quot;compile&quot; takes initial expression of <em>Val 2 :+: (Val 4 :+: Val 8)</em>, through pattern matching the case for &quot;:+:&quot; will be executed and through recursion it will be executed again for the right side (<em>Val 4 :+: Val 8</em>) as well. Below definition of the &quot;:+:&quot; case is shown.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">help s (e1 <span class="fu">:+:</span> e2) <span class="fu">=</span> <span class="kw">do</span> 
    f2 <span class="ot">&lt;-</span> compile e2
    help (<span class="st">&quot;{prev:&quot;</span> <span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;, tag:\&quot;left\&quot;,</span>
<span class="st">                     data:&quot;</span><span class="fu">++</span> show f2 <span class="fu">++</span><span class="st">&quot;}&quot;</span>) e1</code></pre></div>
<p>Furthermore, for each value of the expression (&quot;Val 2&quot;, &quot;Val 4&quot; and &quot;Val 8&quot;) the function definition will be generated, because &quot;compile&quot; function has a case for that.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">help s (<span class="dt">Val</span> n) <span class="fu">=</span> genDef <span class="fu">$</span>
        <span class="st">&quot;function(s){return{stack:&quot;</span><span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;,</span>
<span class="st">                     tag:\&quot;num\&quot;, data:&quot;</span><span class="fu">++</span> show n <span class="fu">++</span><span class="st">&quot;}}&quot;</span></code></pre></div>
<p>After &quot;compile&quot; function is done executing the structure is compiled and ready to be outputted to the file.</p>
<h4 id="formating-and-outputting-to-file"><span class="header-section-number">4.2.2.1</span> Formating and outputting to file</h4>
<p>Output formating is done by &quot;jsSetup&quot; function. It takes the name of the array, the result of &quot;compile&quot; function and outputs a JavaScript formatted string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsSetup  ::</span>  <span class="dt">String</span>       <span class="co">-- array name</span>
         <span class="ot">-&gt;</span>  <span class="dt">CodeGen</span> x    <span class="co">-- compilation process</span>
         <span class="ot">-&gt;</span>  (  <span class="dt">String</span>    <span class="co">-- JavaScript code</span>
             ,  x         <span class="co">-- result</span>
             )</code></pre></div>
<p>&quot;jsWrite&quot; takes an output of &quot;jsSetup&quot; and writes everything to a file - &quot;generated.js&quot;, which is ready to be used by the abstract machine.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsWrite ::</span> (<span class="dt">String</span>, x) <span class="ot">-&gt;</span> <span class="dt">IO</span>()
jsWrite (code, x) <span class="fu">=</span> writeFile <span class="st">&quot;dist/generated.js&quot;</span> code</code></pre></div>
<p>Example usage:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> xpr <span class="fu">=</span> <span class="dt">Val</span> <span class="dv">2</span> <span class="fu">:+:</span> (<span class="dt">Val</span> <span class="dv">4</span> <span class="fu">:+:</span> <span class="dt">Val</span> <span class="dv">8</span>)
jsWrite (jsSetup <span class="st">&quot;Add&quot;</span> (compile xpr))</code></pre></div>
<h3 id="abstract-machine"><span class="header-section-number">4.2.3</span> Abstract machine</h3>
<p>Purpose of the abstract machine is to take in a compiled program and provide semantics for the file to be runnable in the browser. It gradually builds a stack from a given data structure (located in &quot;generated.js&quot;), where each frame of the stack has a link to another frame. The elegant part of this structure is that, stack frames can be saved, updated, deleted and restored, thus, making the machine's structure flexible.</p>
<p><strong>Data Structure of compiled expression</strong></p>
<p>Each generated data structure by the compiler is an array called <em>resumptions</em>. Its entries are functions which take in a stack. This way it is possible to nest them while keeping track of the stack. Below is an example of array of resumptions ready to be used by the abstract machine; it was constructed from the expression <em>Val 3 :+: Val 2</em>. The semantics of this particular structure are simple, to add two numbers &quot;2 + 3&quot;, so the expected output is &quot;5&quot;. Comments in the code snippet below explain meaning of different variables in the structure. For more complicated examples see <em>main/example_programs</em> or test cases.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> foo <span class="op">=</span> []<span class="op">;</span>
foo[<span class="dv">0</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// stack</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">//expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">3</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span>
foo[<span class="dv">1</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span> <span class="co">// stack </span>
            <span class="dt">prev</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// link to previous frame </span>
            <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="co">// command used for adding numbers</span>
            <span class="dt">data</span><span class="op">:</span> <span class="dv">0</span> <span class="co">// index of next operation </span>
        <span class="op">},</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">// expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span></code></pre></div>
<h4 id="implementation"><span class="header-section-number">4.2.3.1</span> Implementation</h4>
<p>This section focuses on explaining detailed implementation of the experimental abstract machine. It is defined as a function which takes in array of resumptions as an argument. The array &quot;foo&quot;, described above will be used as a reference throughout this section.</p>
<p>Modes are objects, which store current stack and computation. Below initial definition of mode is shown with pre-set starting values. Because the starting stack is empty the &quot;stack&quot; parameter is defined as &quot;null&quot;; the &quot;tag&quot; is an expression type and if it is equal to &quot;go&quot;, the machine must take &quot;data&quot; parameter, which is an index of the last element in array of resumptions, in order to retrieve next mode.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;go&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">f</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>
    <span class="op">}</span></code></pre></div>
<p>Each resumption is a function, which takes in a stack as a parameter and return a mode. Abstract machine will finish compilation if &quot;mode.tag&quot; is not equal to &quot;go&quot;. However, if it is equal to &quot;go&quot; then mode must be reinitialized, because the current mode is not a final value. Therefore, machine retrieves the next mode from resumptions array and passes stack to it, so that the mode has access to previous stack frames.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">===</span> <span class="st">&quot;go&quot;</span>) <span class="op">{</span>
        mode <span class="op">=</span> f[<span class="va">mode</span>.<span class="at">data</span>](<span class="va">mode</span>.<span class="at">stack</span>)<span class="op">;</span></code></pre></div>
<p>&quot;f&quot; represents an resumptions array, thus, considering example of &quot;foo&quot; array, the code above would create the following mode.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span> 
            <span class="dt">prev</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span> 
            <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> 
            <span class="dt">data</span><span class="op">:</span> <span class="dv">0</span> 
        <span class="op">},</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> 
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span> 
    <span class="op">}</span></code></pre></div>
<p>Abstract machine will continue executing while reinitializing mode's value every time &quot;mode.tag&quot; changes to &quot;go&quot; until the &quot;mode.tag&quot; becomes not equal to &quot;go&quot; and the stack is empty. It means that mode is a value and that the machine is done computing.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">!=</span> <span class="st">&quot;go&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">mode</span>.<span class="at">stack</span> <span class="op">!=</span> <span class="kw">null</span>) <span class="op">{</span></code></pre></div>
<p>If the execution is still going then the behavior of the abstract machine will differ based on mode's &quot;tag&quot; parameter. In example of &quot;foo&quot; computation, the &quot;mode.tag&quot; is equal to &quot;num&quot;. Overall, &quot;mode.tag&quot; could be equal to these values:</p>
<ul>
<li><strong>&quot;num&quot;</strong> - all of the basic evaluations of given expression. Further machine's actions depend on the value of &quot;mode.stack.tag&quot;. In the case of the example &quot;foo&quot; its value would be &quot;left&quot;.
<ul>
<li><p>Addition (&quot;<strong>left</strong>&quot; and &quot;<strong>right</strong>&quot; tags) - &quot;left&quot; tag creates a stack frame with tag &quot;right&quot;, thus preparing a frame for addition by placing the current value on the top of the stack and preparing to evaluate other expression. If the top of the stack &quot;tag&quot; is equal to &quot;right&quot; the abstract machine can add two of the top frames together, therefore creating new &quot;num&quot; mode (contains the answer of the addition) and deleting the top frame of the stack. In the case of &quot;foo&quot; example, the &quot;left&quot; case would change its mode to:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">prev</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span>
        <span class="op">},</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;go&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="dv">0</span>
<span class="op">}</span></code></pre></div>
<p>Then it would be reinitialized to:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">prev</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span>
        <span class="op">},</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="dv">3</span>
<span class="op">}</span></code></pre></div>
<p>And because the &quot;mode.stack.tag&quot; is equal to &quot;right&quot;, the &quot;mode.data&quot; and &quot;mode.stack.data&quot; would be added together and a new mode created:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">2</span>
<span class="op">}</span></code></pre></div>
<p>This would be a final mode, because the stack is empty and the &quot;tag&quot; is not equal to &quot;go&quot;, so the machine would return &quot;5&quot; as the result of the computation. Other instructions manipulate mode's data in similar fashion, building or destroying stack in the process.</p></li>
<li>&quot;<strong>Catch</strong>&quot; - creates a stack frame with tag &quot;catcher&quot; and places it on the top of the stack. Its data parameter is equal to the index of second expression which will be evaluated if first expressions throws an exception.</li>
<li>New reference - creates a stack frame with tag &quot;<strong>WithRefRight</strong>&quot;, it is different from other stack frames because it has a &quot;name&quot; parameter, which is needed to identify between different references. It, also, holds the value of the reference in its &quot;data&quot; parameter.</li>
<li>Next (&quot;<strong>:&gt;left</strong>&quot; and &quot;<strong>:&gt;right</strong>&quot;) - implementation is similar to addition, however the key difference is that if the top stack frame tag is equal to &quot;:&gt;right&quot; the abstract machine will take its data without adding anything and it will delete the previous stack frame. These operations evaluate two expressions but return the value of the second.</li>
<li><p>Set (&quot;<strong>:=</strong>&quot;) - very similar to &quot;Get&quot; command (described below), key difference is that it alters the value of stack frame which has tag &quot;WithRefRight&quot; with given name of the reference. This command utilizes linked list stack saving structure to be able to restore the stack while saving any changes made. Exception could be thrown if the reference is undefined.</p></li>
</ul></li>
<li><p><strong>&quot;throw&quot;</strong> - defines that something went wrong so the abstract machine will look for a &quot;catcher&quot; frame in the previous stack frames; if it does not find it then it will output an exception.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;throw&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="st">&quot;Unhandled exception!&quot;</span>
<span class="op">}</span></code></pre></div>
<p>However, if it does then it means exception was handled, therefore the abstract machine will reinitialize mode to continue executions by taking &quot;catcher&quot; values of &quot;stack&quot; and &quot;data&quot; (some expression).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">data</span>
<span class="op">}</span></code></pre></div></li>
<li><p><strong>&quot;get&quot;</strong> - goes through the stack while looking for a reference, output's either a value of the reference if it does find it, or tries to throw an exception if it does not. It, also, utilizes linked stack saving and restoring structure, in order to restore the stack if it does find a reference.</p></li>
</ul>
<p>After the abstract machine finishes running, the &quot;mode.tag&quot; is not equal to &quot;go&quot; and the stack is empty, it will output the final mode to the console by invoking a &quot;printer&quot; function for the user to clearly see the results. And finally, abstract machine outputs final value of the execution on the separate line for testing purposes, it is used by testing framework to check for expected and actual output of a test.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(<span class="va">mode</span>.<span class="at">data</span>)<span class="op">;</span></code></pre></div>
<h4 id="linked-stack-saving-and-restoring"><span class="header-section-number">4.2.3.2</span> Linked Stack Saving and Restoring</h4>
<p>Abstract machine uses &quot;saver&quot; helper function in &quot;get&quot; and &quot;:=&quot; implementations. This function lets the machine to inspect the depths of the stack and to assign new values to existing frames of the stack by remembering changes made. To achieve this, abstract machine saves each frame of the stack by linking frames together, thus each newly saved frame has a link to previous saved frame. Below &quot;saveStack&quot; function is displayed, the &quot;m&quot; variable represents the current stack frame and &quot;prev&quot; field is a link to previous saved frame.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">save <span class="op">=</span> <span class="op">{</span>
    <span class="dt">prev</span><span class="op">:</span> save<span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="va">m</span>.<span class="at">tag</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">m</span>.<span class="at">data</span><span class="op">,</span>
    <span class="dt">name</span><span class="op">:</span> <span class="va">m</span>.<span class="at">name</span>
<span class="op">}</span></code></pre></div>
<p>The save is reverse linked list of stack frames, thus it is possible to restore the original stack including all the changes made by reverse engineering the stack. After stack is successfully restored, all of the save data must be destroyed and parameters reseted to keep future saves unaffected. Finally, current limitation is that only one instance of stack save can exist at a given time, however this is addressed in the final system.</p>
<h4 id="final-remarks"><span class="header-section-number">4.2.3.3</span> Final Remarks</h4>
<p>The abstract machine currently supports functionality for adding expressions, creating a reference, getting the value of a reference, setting new value of a given reference and throwing &amp; catching exceptions.</p>
<p>Room for improvement:</p>
<ul>
<li>Efficiency and optimization, for example, by removing &quot;go&quot; tag and calling resumptions array directly;</li>
<li>Documentation;</li>
<li>Functionality;</li>
</ul>
<p>All of these points are addressed in the final implementation.</p>
<h2 id="conclusion-1"><span class="header-section-number">4.3</span> Conclusion</h2>
<p>A preliminary experiment, implementing the essence of Frank-like execution for much simpler language, has been completed successfully. The key lessons were:</p>
<ul>
<li>Haskell syntax;</li>
<li>Language creation and its syntax development;</li>
<li>Compiler - parsing the input and generating valid JavaScript code;</li>
<li>Machine - executing compiled expression array and managing its resources, such as mode, stack and saved stack.</li>
</ul>
<p>Key things to improve are optimization &amp; performance.</p>
<p>The further plan was to roll out the lessons learned creating compiler and virtual machine for more of the &quot;Shonky&quot; intermediate language that is generated by Frank compiler. This will be covered in the next chapter.</p>
<h1 id="detailed-design-and-implementation-of-the-final-system"><span class="header-section-number">5</span> Detailed Design and Implementation of the final system</h1>
<p>Chapter focuses on implementation, design of the final compiler and abstract machine, as well as, any topics connected to them.</p>
<h2 id="introduction-2"><span class="header-section-number">5.1</span> Introduction</h2>
<p>The development of the final system started on week six of the second semester, after the end of experimental system's development. Some parts of the code were lifted from the earlier experiment and main concepts of how virtual machines and compilers should work were reused.</p>
<h3 id="disclaimer"><span class="header-section-number">5.1.1</span> Disclaimer</h3>
<p>Final system uses two other systems in its code base, thus not all of the code is written by the author of this project. Author's code will be clearly indicated. Two projects connected to the system are:</p>
<ul>
<li><strong>Frankjnr</strong> - developed by Sam Lindley, Craig McLaughlin and Conor McBride. Final system is essentially new back end for Frankjnr. Thus, the whole Frankjnr project was used and new back end was placed in <em>Backend</em> folder. Parts of Frankjnr code were slightly updated to let the user choose between the old back end and the new one. Updated files were: Compile.hs and Frank.hs; updated functions are clearly indicated with comments;</li>
<li><strong>Shonky</strong> - developed by Conor McBride. Final compiler uses Shonky's syntax file for its supported data structures and parse functions. However, developed system does not use <em>semantics</em> module, since it is replacing it.</li>
</ul>
<p>More detailed descriptions the projects can be found at <strong>Related work</strong> section of the report or at their respective git pages.</p>
<h2 id="projects-folder-structure"><span class="header-section-number">5.2</span> Project's folder structure</h2>
<p>Final system is located in <em>final_implementation</em> folder. And all of the code for new compiler and abstract machine is located in &quot;Backend&quot; folder.</p>
<p>Table's starting folder is <em>/final_implementation</em>.</p>
<table>
<caption>Project folder structure</caption>
<colgroup>
<col width="27%" />
<col width="18%" />
<col width="54%" />
</colgroup>
<thead>
<tr class="header">
<th>Paths and Files</th>
<th></th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td>Main directory for final implementation</td>
</tr>
<tr class="even">
<td></td>
<td>Frank.hs</td>
<td>Main Frankjnr file</td>
</tr>
<tr class="odd">
<td></td>
<td>Compile.hs</td>
<td>Compiles Frank to Shonky data structures</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend</em></td>
<td></td>
<td>Machine and Compiler files</td>
</tr>
<tr class="even">
<td></td>
<td>Compiler.hs</td>
<td>Main compiler</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/machine</em></td>
<td></td>
<td>Abstract Machine files</td>
</tr>
<tr class="odd">
<td></td>
<td>webpack.js</td>
<td>Webpack configuration file</td>
</tr>
<tr class="even">
<td></td>
<td>tester.html</td>
<td>HTML which includes output.js (testing purposes)</td>
</tr>
<tr class="odd">
<td></td>
<td>main.js</td>
<td>Main machine function</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/machine/components</em></td>
<td></td>
<td>Includes all components to construct Virtual Machine</td>
</tr>
<tr class="even">
<td></td>
<td>machine.js</td>
<td>Main component for Virtual Machine</td>
</tr>
<tr class="odd">
<td></td>
<td>printer.js</td>
<td>Component responsible for result printing</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/machine/dist</em></td>
<td></td>
<td>Generated files</td>
</tr>
<tr class="even">
<td></td>
<td>gen.js</td>
<td>Compiler generated code</td>
</tr>
<tr class="odd">
<td></td>
<td>output.js</td>
<td>Webpack generated code (every JS file is packed into one)</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><em>/Backend/Shonky</em></td>
<td></td>
<td>Shonky project directory</td>
</tr>
<tr class="even">
<td></td>
<td>Syntax.hs</td>
<td>Contains needed data structures</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/tests</em></td>
<td></td>
<td>Test framework</td>
</tr>
<tr class="odd">
<td></td>
<td>main.sh</td>
<td>Main file (launch file)</td>
</tr>
<tr class="even">
<td></td>
<td>testcases.sh</td>
<td>Contains all of the test cases</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/tests/test_cases</em></td>
<td></td>
<td>Actual programs to test</td>
</tr>
<tr class="odd">
<td><em>/Backend/tests/test_cases/old</em></td>
<td></td>
<td>Test programs lifted from Frankjnr</td>
</tr>
<tr class="even">
<td><em>/Backend/tests/test_cases/new</em></td>
<td></td>
<td>New test programs</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><em>/Backend/benchmark</em></td>
<td></td>
<td>Benchmarking scripts</td>
</tr>
</tbody>
</table>
<h2 id="compiler-1"><span class="header-section-number">5.3</span> Compiler</h2>
<p>The compiler is located in <em>final_implementation/Backend/Compiler.hs</em> and it is written in Haskell. It is initiated when Frank program is called with a flag &quot;output-js&quot;. Example with program named &quot;foo.fk&quot;:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> foo.fk --output-js</code></pre></div>
<p>Developed compiler uses Shonky data structures, located in <em>Syntax.hs</em> file, because it receives a list of program definitions from Frankjnr compiler in a form of Shonky syntax, in particular - &quot;[Def Exp]&quot;. &quot;Def Exp&quot; is a &quot;DF&quot; data structure shown below. And it essentially means definition of function (operator).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">DF</span> <span class="dt">String</span>   <span class="co">-- name of operator being defined</span>
  [[<span class="dt">String</span>]]    <span class="co">-- list of commands handled on each port</span>
  [([<span class="dt">Pat</span>], <span class="dt">Exp</span>)]  <span class="co">-- list of pattern matching rules</span></code></pre></div>
<p>The core goal of the compiler is to compile data types &quot;Exp&quot; to JavaScript structures (arrays of operators and resumptions). &quot;Exp&quot; is defined in Shonky's <em>Syntax.hs</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span>
  <span class="fu">=</span> <span class="dt">EV</span> <span class="dt">String</span>                    <span class="co">-- variable</span>
  <span class="fu">|</span> <span class="dt">EI</span> <span class="dt">Integer</span>                   <span class="co">-- integer</span>
  <span class="fu">|</span> <span class="dt">EA</span> <span class="dt">String</span>                    <span class="co">-- atom</span>
  <span class="fu">|</span> <span class="dt">Exp</span> <span class="fu">:&amp;</span> <span class="dt">Exp</span>                   <span class="co">-- pair</span>
  <span class="fu">|</span> <span class="dt">Exp</span> <span class="fu">:$</span> [<span class="dt">Exp</span>]                 <span class="co">-- application</span>
  <span class="fu">|</span> <span class="dt">Exp</span> <span class="fu">:!</span> <span class="dt">Exp</span>                   <span class="co">-- composition (;)</span>
  <span class="fu">|</span> <span class="dt">Exp</span> <span class="fu">://</span> <span class="dt">Exp</span>                  <span class="co">-- composition (o)</span>
  <span class="fu">|</span> <span class="dt">EF</span> [[<span class="dt">String</span>]] [([<span class="dt">Pat</span>], <span class="dt">Exp</span>)] <span class="co">-- operator</span>
  <span class="fu">|</span> <span class="dt">EX</span> [<span class="dt">Either</span> <span class="dt">Char</span> <span class="dt">Exp</span>]  <span class="co">-- string concatenation expression</span></code></pre></div>
<p>The compilation results of each &quot;DF&quot; are combined into one JavaScript data structure, forming &quot;resumptions&quot; and &quot;operators&quot; arrays in the process. Top level function for this is &quot;operatorCompile&quot;. It initiates chain reaction of function calls for each function definition (&quot;DF&quot;) and concatenates the results into one data structure. This chain reaction of function calls consist of &quot;oneCompile&quot;, which starts to compile single function definition and forms an &quot;operators&quot; array entry. Then it calls &quot;makeOperator&quot;, which sets the &quot;interface&quot; (all available commands for given operator) and &quot;implementation&quot; (JavaScript function definition) by calling &quot;funCompile&quot;. &quot;funCompile&quot; is responsible for forming the actual function implementation of the operator and it proceeds to initiate &quot;linesCompile&quot;, which forms a &quot;try&quot; and &quot;catch&quot; blocks and calls the final function &quot;lineCompile&quot;, who fills the lines with compiled expressions by calling &quot;patCompile&quot; and &quot;expCompile&quot; functions with data on function's patterns and expressions. Finally, &quot;lineCompile&quot; forms a return statement. To see how these expressions and patterns look compiled, see &quot;gen.js&quot; file. A figure 5.1 shows a lifecycle of a single compilation. In the example, the code compiles the <em>[DF &quot;main&quot; [] [([],EI 1)]</em> definition, which evaluates to a single integer equal to 1.</p>

<p>&quot;lineCompile&quot; will compile expressions &quot;Exp&quot;, however before it can do that, it must build an environment look-up table. The table is used to retrieve defined values, shown below.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EnvTable</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)] <span class="co">-- environment look-up table</span></code></pre></div>
<p>The compiler builds the lookup table by compiling list of patterns &quot;Pat&quot; with &quot;patCompile&quot; and &quot;vpatCompile&quot; functions. &quot;Pat&quot; values are retrieved from initial &quot;DF&quot; expression. Furthermore, there are two types of patterns. Patterns for computation - &quot;Pat&quot; and patterns for value - &quot;VPat&quot;. Patterns for computation can be thunk, command or &quot;VPat&quot; type. Functions &quot;patCompile&quot; and &quot;vpatCompile&quot; have been implemented using counter monad &quot;Counter&quot;, which is there to incrementally count each pattern and is used for indices of the environment lookup table.</p>
<p>In order to form the environment's lookup table entries compiler must match patterns. The core pattern matching principle used was &quot;match-this-or-bust&quot; described in PhD thesis &quot;Computer Aided Manipulation of Symbols&quot; <span class="citation">(F.V. McBride 1970)</span>. &quot;patCompile&quot; and &quot;vpatCompile&quot; functions, therefore, will generate series of checks for each individual pattern. If there is none failing tests, then patterns will be added to the environement, else it will throw an exception with &quot;match failed!&quot; message. As a consequence, the environment look-up table (&quot;EnvTable&quot;) will be formed with correspoding JavaScript matching tests, which will be later placed into a generated file. The code snippet below represents a case for matching &quot;VPat&quot; integer values. First element of the return statement is an empty environment, second is series of matching checks. In this case, the environment is empty because integers are not defined variables, so they can not be referenced anywhere else.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">vpatCompile v (<span class="dt">VPI</span> x) <span class="fu">=</span> <span class="kw">do</span> <span class="co">-- integer value</span>
  i <span class="ot">&lt;-</span> next
  return ([],
    <span class="st">&quot;if (&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;.tag!==\&quot;int\&quot;) ++</span>
<span class="st">        {&quot;</span> <span class="fu">++</span> matchFail <span class="fu">++</span><span class="st">&quot;};\n&quot;</span> <span class="fu">++</span>
    <span class="st">&quot;if (&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;.int!==&quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot;) ++</span>
<span class="st">        {&quot;</span> <span class="fu">++</span> matchFail <span class="fu">++</span><span class="st">&quot;};\n&quot;</span>
    )</code></pre></div>
<p>After the environment look-up table is ready, &quot;lineCompile&quot; function can now use it to compile expressions - &quot;Exp&quot; into computations (JavaScript objects), thus forming a &quot;return&quot; statement in JavaScript. This is achieved in &quot;expCompile&quot; function, which takes in an environment look-up table, function lookup table, stack (string data structure), expression (&quot;Exp&quot;) and outputs an JavaScript data structure encapsulated in monad &quot;CodeGen&quot;. This monad is lifted from earlier experiment and it is used here for the same reason, to construct function definitions and track their indices in &quot;funCompile&quot; function. The compilation process will differ for each type of expression, because each of them have to follow different rules to be compiled correctly. For example, atoms are compiled as shown below. A JavaScript object is returned, which contains a stack and a computation with atom's values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class="fu">$</span> <span class="st">&quot;{stack:&quot;</span> <span class="fu">++</span> stk <span class="fu">++</span> <span class="st">&quot;, comp:{tag:\&quot;value\&quot;,&quot;</span> <span class="fu">++</span>
           <span class="st">&quot;value:{tag:\&quot;atom\&quot;, atom:\&quot;&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot;\&quot;}}}&quot;</span></code></pre></div>
<p>On the other hand, for example, &quot;pair&quot; type of expressions are slightly more complicated, because the &quot;pair&quot; contains two expressions, so the compiler has to evaluate them both separately. The process is similar to experimental systems addition, since the compiler makes a resumption for the second component and keeps computing the first one.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">expCompile xis ftable stk (ecar <span class="fu">:&amp;</span> ecdr) <span class="fu">=</span> <span class="kw">do</span>
  fcdr <span class="ot">&lt;-</span> expFun xis ftable ecdr <span class="co">-- resumption</span>
  expCompile xis ftable  <span class="co">-- compute first component</span>
    (<span class="st">&quot;{prev: &quot;</span> <span class="fu">++</span> stk <span class="fu">++</span> <span class="st">&quot;, frame:{ tag:\&quot;car\&quot;, env:env, cdr:&quot;</span>
     <span class="fu">++</span> show fcdr <span class="fu">++</span> <span class="st">&quot;}}&quot;</span>)
    ecar </code></pre></div>
<p>Another interesting and crucial type of expression compilation is function application. Here, because the function is applied to list of arguments, compiler has to compile each of the arguments by forming a linked list data structure. And to form it the compiler utilizes a helper function, named &quot;tailCompile&quot;, which recursively builds a linked list. To look at all of the &quot;expCompile&quot; cases, see <em>Compiler.hs</em> file.</p>
<h3 id="full-compilation-example"><span class="header-section-number">5.3.1</span> Full compilation example</h3>
<p>This example will show how function definition <em>[DF &quot;main&quot; [] [([],EI 1)]</em> is compiled. Expected output is displayed below.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">operator[<span class="dv">0</span>] <span class="op">=</span> <span class="op">{</span>
    <span class="dt">interface</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
    <span class="dt">implementation</span><span class="op">:</span> <span class="kw">function</span> (stk<span class="op">,</span> env<span class="op">,</span> args) <span class="op">{</span>
        <span class="cf">try</span> <span class="op">{</span>
            <span class="cf">return</span> <span class="op">{</span>
                <span class="dt">stack</span><span class="op">:</span> stk<span class="op">,</span>
                <span class="dt">comp</span><span class="op">:</span> <span class="op">{</span>
                    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;value&quot;</span><span class="op">,</span>
                    <span class="dt">value</span><span class="op">:</span> <span class="op">{</span>
                        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;int&quot;</span><span class="op">,</span>
                        <span class="dt">int</span><span class="op">:</span> <span class="dv">1</span>
                    <span class="op">}</span>
                <span class="op">}</span>
            <span class="op">}</span>
        <span class="op">}</span> <span class="cf">catch</span> (err) <span class="op">{</span>
            <span class="cf">throw</span> (<span class="st">&quot;undefined function&quot;</span>)
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Compilation begins with &quot;operatorCompile&quot;, and it immediately, initiates &quot;oneCompile&quot; with prepared function table and single &quot;DF&quot; expression. In the context of this example, <em>&quot;main&quot; [] [([],EI 1)]</em> will be passed to &quot;oneCompile&quot;. As a result, &quot;oneCompile&quot; creates &quot;operator[0]=&quot; and initiates &quot;makeCompile&quot; function with counter equal to 0, in addition to previous parameters.</p>
<p>&quot;makeCompile&quot; creates two objects: &quot;interface&quot; and &quot;implementation&quot;. Furthermore, it adds all available commands to the interface object and initiates &quot;funCompile&quot; inside the &quot;implementation&quot; object. &quot;funCompile&quot; takes 0 (counter) and <em>[([],EI 1)]</em> as its parameters and adds &quot;function(stk,env,args){&quot;, before calling &quot;linesCompile&quot; function to form a &quot;try&quot; and &quot;catch&quot; blocks. And &quot;linesCompile&quot; call &quot;lineCompile&quot; inside &quot;try&quot; block, in order to form a return statement. Finally, &quot;lineCompile&quot; initiates &quot;patCompile&quot;, to form an environment look-up table, followed by &quot;expCompile&quot; in order to compile expression <em>EI 1</em>. At this point compilation is done, because there are no more &quot;DF&quot;'s in the list, thus &quot;operatorCompile&quot; is done.</p>
<h3 id="helper-functions"><span class="header-section-number">5.3.2</span> Helper functions</h3>
<p>This section will briefly explain functionality of few helper functions.</p>
<p><strong>parseShonky</strong> - is used for testing purposes, it takes Shonky syntax files (ending with &quot;uf&quot;), reads it, parses it utilizing the parse function located in <em>Syntax.hs</em> and runs the compiler on the result. Thus, generating new &quot;gen.js&quot; file.</p>
<p><strong>jsComplete</strong> - Takes the output of &quot;operatorCompile&quot;. Wraps compiled list of &quot;DF&quot; into one structure , formats it and writes the result of the compilation to the &quot;gen.js&quot; file.</p>
<h2 id="abstract-machine-1"><span class="header-section-number">5.4</span> Abstract machine</h2>
<p>The purpose of the abstract machine is to take in generated output of the compiler and run it on a browser, thus completing the main goal of the project. For full usage and installation instructions see <strong>Appendix 2</strong>.</p>
<p>Abstract machine modules are located in<br />
<em>final_implementation/Backend/machine</em> folder. They are written in JavaScript and are compiled to a single file<br />
<em>final_implementation/Backend/machine/dist/output.js</em> by utilizing <em>webpack</em> library.</p>
<h3 id="javascript-type-definitions"><span class="header-section-number">5.4.1</span> JavaScript type definitions</h3>
<p>This section explains the JavaScript types used by abstract machine to enforce the data structure of the compiled Frank programs. Firtly, &quot;JSEnv&quot; represents an environemnt, which is an array of &quot;JSVal&quot; values described below.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">JSEnv <span class="op">=</span> JSVal[]</code></pre></div>
<p>&quot;JSRun&quot; is an operator and it always returns a mode. Operators are located in &quot;operators&quot; array (in &quot;gen.js&quot;). Mode contains a stack and current computation. Top stack frame and current computation both determine what to do next in the machine's lifecycle.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSRun <span class="op">=</span> (JSStack<span class="op">,</span> JSEnv<span class="op">,</span> JSVal[]) <span class="op">-&gt;</span> JSMode
jstype JSMode <span class="op">=</span> <span class="op">{</span><span class="dt">stack</span><span class="op">:</span> JSStack<span class="op">,</span> <span class="dt">comp</span><span class="op">:</span> JSComp<span class="op">}</span>     </code></pre></div>
<p>Stack could be empty or consist of a frame and a link to previous frame. The idea of these links are applied from linked list data structure, where each element of the list has a link to the next element. Linked lists are used regularly throughout the project.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSStack 
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">prev</span><span class="op">:</span> JSStack<span class="op">,</span> <span class="dt">frame</span><span class="op">:</span> JSFrame <span class="op">}</span></code></pre></div>
<p>Below is a stack's frame type, which determines the operation that needs to be done when current computation is equal to &quot;value&quot;. The operation is decided depending on the value of the &quot;tag&quot;, so if the &quot;tag&quot; is equal to &quot;car&quot;, the machine will expect that &quot;env&quot; and &quot;cdr&quot; values are defined as well.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSFrame 
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;car&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">cdr</span><span class="op">:</span> Int <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;cdr&quot;</span><span class="op">,</span> <span class="dt">car</span><span class="op">:</span> JSVal <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;fun&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">args</span><span class="op">:</span> JSList Int <span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;arg&quot;</span><span class="op">,</span> <span class="dt">fun</span><span class="op">:</span> JSVal<span class="op">,</span> <span class="dt">ready</span><span class="op">:</span> JSComp[]<span class="op">,</span>
     <span class="dt">env</span><span class="op">:</span> JSEnv<span class="op">,</span> <span class="dt">waiting</span><span class="op">:</span> JSList Int<span class="op">,</span>
     <span class="dt">headles</span><span class="op">:</span> Int<span class="op">,</span> <span class="dt">waitingHandles</span><span class="op">:</span> JSList Int <span class="op">}</span></code></pre></div>
<p>Linked list data structure, where it could be empty or have a head element and tailing list of elements.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSList x
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">head </span><span class="op">:</span> x<span class="op">,</span> <span class="dt">tail </span><span class="op">:</span> JSList x<span class="op">}</span>    </code></pre></div>
<p>Computation could either be a &quot;value&quot; or a &quot;command&quot;, machine will know which one it is by checking its &quot;tag&quot; field and proceeding acordingly.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSComp
  <span class="op">=</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;value&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> JSVal<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;command&quot;</span><span class="op">,</span> <span class="dt">command</span><span class="op">:</span> String<span class="op">,</span>
     <span class="dt">args</span><span class="op">:</span> JSVal[]<span class="op">,</span> <span class="dt">callback</span><span class="op">:</span>JSCallBack<span class="op">}</span></code></pre></div>
<p>The linked list data structure is used again to form a call back structure. This structure is used when the machine begins to search for command's handler in the stack while building a &quot;JSCallBack&quot; by adding checked stack frames to it. After the handler is found and command is done executing, the machine uses &quot;JSCallBack&quot; to rebuild the stack to its original state.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSCallBack
  <span class="op">=</span> <span class="kw">null</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">frame</span><span class="op">:</span> JSFrame<span class="op">,</span> <span class="dt">callback</span><span class="op">:</span>JSCallBack<span class="op">}</span></code></pre></div>
<p>Possible value types are displayed below, their type is determined by the &quot;tag&quot; value. &quot;atom&quot; is just an value that cannot be deconstructed any further, however in a special case when &quot;atom&quot; is applied to a list of arguments a command is initiated, which is based on &quot;atom&quot; value. &quot;int&quot; represents an integer value. &quot;pair&quot; is a pair of two values, one is held in &quot;car&quot; object and the other is in &quot;cdr&quot;. &quot;operator&quot; is a top level function. &quot;callback&quot; holds a &quot;callback&quot; object which has stack frames waiting to be restored after machine finds a hadler of a command that it was looking for. &quot;thunk&quot; represents a suspended computation. And &quot;local&quot; represents local functions, which due to procedure called &quot;Lambda Lifting&quot; <span class="citation">(Thomas Jonson 1985)</span>, abstract machine will turn them into a top level functions and execute.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">jstype JSVal
  <span class="op">=</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;atom&quot;</span><span class="op">,</span> <span class="dt">atom</span><span class="op">:</span> String<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;int&quot;</span><span class="op">,</span> <span class="dt">int</span><span class="op">:</span> Int<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;pair&quot;</span><span class="op">,</span> <span class="dt">car</span><span class="op">:</span> JSVal<span class="op">,</span> <span class="dt">cdr</span><span class="op">:</span> JSVal<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;operator&quot;</span><span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> Int<span class="op">,</span> <span class="dt">env</span><span class="op">:</span>JSEnv<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;callback&quot;</span><span class="op">,</span> <span class="dt">callback</span><span class="op">:</span> JSCallBack<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;thunk&quot;</span><span class="op">,</span> <span class="dt">thunk</span><span class="op">:</span>JSComp<span class="op">}</span>
  <span class="op">|</span> <span class="op">{</span><span class="dt">tag</span><span class="op">:</span><span class="st">&quot;local&quot;</span><span class="op">,</span> <span class="dt">env</span><span class="op">:</span>JSEnv<span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> JSVal<span class="op">}</span></code></pre></div>
<h3 id="implementation-1"><span class="header-section-number">5.4.2</span> Implementation</h3>
<p>Abstract machine takes contents of &quot;gen.js&quot; as an input, which contains two different arrays: &quot;operators&quot; and &quot;resumptions&quot;. The operators are equivalent to top level functions in Frank, the resumptions are computations waiting to be executed. In current machine's implementation starting operator is always the first function; main method, thus, must be at the top of Frank's file. Operators return modes which are computation which keep track of stack. Below the machine defines initial mode with initial empty stack, no arguments and no environment.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mode <span class="op">=</span> operators[<span class="dv">0</span>].<span class="at">implementation</span>(<span class="kw">null</span><span class="op">,</span> []<span class="op">,</span> [])<span class="op">;</span></code></pre></div>
<p>The machine will keep executing in a while loop until stack becomes empty; before halting it will return the final mode and call printer helper function to display the output. In each while cycle the machine checks the current computation tag, it can either be a &quot;value&quot; or a &quot;command&quot; and depending on which one it is, the machine will act accordingly.</p>
<h4 id="computation---value"><span class="header-section-number">5.4.2.1</span> Computation - &quot;value&quot;</h4>
<p>If the &quot;mode.comp.tag&quot; is equal to &quot;value&quot; then the machine will look at the first frame of the stack to receive information on what to do next. There are four options depending on the frame tags, each of them will construct a new mode while altering the stack in the process (look at <em>JavaScript type definitions</em> section to see structure):</p>
<ul>
<li><p><strong>&quot;car&quot;</strong> - will construct mode out of calling a resumption based on &quot;mode.stack.frame.cdr&quot; value. For resumption to construct a new mode it needs two values, stack and an environment. Therefore, machine will pass in the stack and the environment as well. Although, it will alter the stack by removing top stack frame and creating a new one with a &quot;cdr&quot; tag and a car value. This procedure is similar to experimental system's addition operation.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> resumptions[<span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">cdr</span>]( 
    stack <span class="op">=</span> <span class="op">{</span> <span class="co">// new stack</span>
      <span class="dt">prev</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span> 
      <span class="dt">frame</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;cdr&quot;</span><span class="op">,</span>
        <span class="dt">car</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">value</span>
      <span class="op">},</span>
    <span class="op">},</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">env</span>)<span class="op">;</span> <span class="co">// environment</span></code></pre></div></li>
<li><p><strong>&quot;cdr&quot;</strong> - will reduce the stack and return a pair of <em>car</em> and <em>cdr</em> as its computation. It will take <em>car</em> value from the current stack frame and <em>cdr</em> from current computation value.</p></li>
<li><p><strong>&quot;fun&quot;</strong> - means application, so some pattern needs to be applied to a list of arguments, which is essentially list of resumptions. If the list of arguments is empty that means the machine is ready to initiate the function application by calling helper &quot;apply&quot; function without any arguments. If, however, the waiting argument list is not empty the machine needs to construct a new mode with frame tag equal to &quot;arg&quot;. It creates new mode out of first argument resumption &quot;resumptions[mode.stack.frame.args.head]&quot; and passes all the needed information in the new stack frame:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"> frame<span class="op">:</span> <span class="op">{</span>
   <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;arg&quot;</span><span class="op">,</span>
   <span class="dt">fun</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">value</span><span class="op">,</span>
   <span class="dt">env</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">env</span><span class="op">,</span>
   <span class="dt">ready</span><span class="op">:</span> []<span class="op">,</span>
   <span class="dt">waiting</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="va">args</span>.<span class="at">tail</span><span class="op">,</span>
   <span class="dt">handles</span><span class="op">:</span> <span class="at">headHandles</span>(intf)<span class="op">,</span>
   <span class="dt">waitingHandles</span><span class="op">:</span> <span class="at">tailHandles</span>(intf)
 <span class="op">},</span></code></pre></div>
<p>&quot;fun&quot; field is used to keep the pattern that will be applied when the arguments &quot;waiting&quot; list is empty. &quot;env&quot; is held to keep the environment. &quot;ready&quot; list is used to know which arguments have been parsed, initially it is empty. &quot;waiting&quot; is used to keep track of list of arguments that are left unchecked. And, lastly, &quot;handles&quot; with &quot;waitingHandles&quot; are used to keep track which argument handle what commands, so if handles list is empty it means that this argument doesn't handle any commands. It gets these values by applying helper functions, which return head and tail of the &quot;waitingHandles&quot; list. And the initial handle list is extracted from the operator's interface by utilizing helper function &quot;interfaceF&quot;, which simply returns given operators interface (list of commands that it can handle).</p></li>
<li><p><strong>&quot;arg&quot;</strong> - simply adds current head of arguments to the ready list and initiates helper function &quot;argRight&quot; which will return new mode (its functionality in detail is described in &quot;Helper functions&quot; section).</p></li>
</ul>
<h4 id="computation---command"><span class="header-section-number">5.4.2.2</span> Computation - &quot;command&quot;</h4>
<p>Because of command type computations, Frank is different from other functional languages. When command computation happens the current execution is interrupted and the control is given to the handler, which looks for the requested command in the stack while building a callback (checked stack frames) to restore the stack when the command is found and finished executing.</p>
<p>In this implementation, computations with a tag equal to &quot;command&quot; are created in a case when an atom is applied to a list arguments. Then the abstract machine goes down the stack while looking for the command's handler. Each time it does not find it, the machine will place top frame in the callback and move down by one frame:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">mode</span>.<span class="va">comp</span>.<span class="at">callback</span> <span class="op">=</span> <span class="op">{</span>
  <span class="dt">frame</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">frame</span><span class="op">,</span> <span class="co">// current frame</span>
  <span class="dt">callback</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">callback</span> 
<span class="op">}</span>
<span class="va">mode</span>.<span class="at">stack</span> <span class="op">=</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span> <span class="co">// new frame</span></code></pre></div>
<p>For the machine to find a command in a frame, it must be an &quot;arg&quot; frame. And it must contain the command that the handler is looking for in its &quot;handles&quot; list (it indicates which commands does given &quot;arg&quot; handle).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">tag</span> <span class="op">===</span> <span class="st">&quot;arg&quot;</span>) <span class="op">{</span>
  <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="va">handles</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">mode</span>.<span class="va">stack</span>.<span class="va">frame</span>.<span class="at">handles</span>[i] <span class="op">===</span> <span class="va">mode</span>.<span class="va">comp</span>.<span class="at">command</span>) <span class="op">{</span>
      ...</code></pre></div>
<p>When these conditions are met, the command handler is found. Therefore it will place the computation of the command on the &quot;ready&quot; argument list and will try to apply it by calling &quot;argRight&quot; helper function, which in turn will call &quot;apply&quot; helper function if there are no waiting resumptions.</p>
<h3 id="helper-functions-1"><span class="header-section-number">5.4.3</span> Helper functions</h3>
<p>This section will describe the functionality of two main helper functions.</p>
<p><strong>argRight</strong> - takes in stack tail, function to be applied, list of arguments which are ready, environment, list of arguments which are still waiting to be checked and list of handled commands. List of handled commands is kept for the machine to know what commands does the resumption handle. Same as in the &quot;fun&quot; case, if the &quot;waiting&quot; list of resumptions (arguments) is empty then the machine is ready to apply the function, thus it will call apply function. If the &quot;waiting&quot; list not empty then the machine will create new &quot;arg&quot; frame in the same fashion as in &quot;fun&quot; option. The key difference is that &quot;fun&quot; could be instantly applied if it did not have any arguments, thus not creating any &quot;arg&quot; frames. However, there is a potential to move all logic to &quot;argRight&quot; function without having any in &quot;fun&quot; case, improving code reuse and optimization.</p>
<p><strong>apply</strong> - Depending on a &quot;fun&quot; computation value, constructs a mode from which to continue execution. &quot;fun&quot; computation could be one of the following:</p>
<ul>
<li><p><strong>&quot;int&quot;</strong> - Applying &quot;int&quot; to an argument is not really sensible, however in this case it is possible because of built-in operations (see <em>Built-in functions</em> section). This custom functionality lets machine add and subtract integer values.</p></li>
<li><p><strong>&quot;local&quot;</strong> - Means a local function. The machine is turning a local function into top level operator, concept introduced by <span class="citation">(Thomas Jonson 1985)</span> and it is named &quot;Lambda Lifting&quot;. Mode is constructed out of an &quot;operator&quot; variable, which contains full function definition.</p></li>
<li><p><strong>&quot;operator&quot;</strong> - Means top level function, mode is constructed from an &quot;fun.operator&quot; value which is an index for operators array.</p></li>
<li><p><strong>&quot;atom&quot;</strong> - Applications of atoms mean a command is initiated; mode with &quot;command&quot; tag and command value should be created. It, also keeps the arguments and creates a &quot;callback&quot; value to be able to restore the stack successfully after finding required command in the stack. Definition of new mode is displayed below.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stk<span class="op">,</span>
      comp<span class="op">:</span> <span class="op">{</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;command&quot;</span><span class="op">,</span>
        <span class="dt">command</span><span class="op">:</span> <span class="va">fun</span>.<span class="at">atom</span><span class="op">,</span>
        <span class="dt">args</span><span class="op">:</span> vargs<span class="op">,</span>
        <span class="dt">callback</span><span class="op">:</span> <span class="kw">null</span>
      <span class="op">}</span></code></pre></div>
<ul>
<li><strong>&quot;thunk&quot;</strong> - Application of thunk pattern (suspended computation). Constructs a mode while ignoring any arguments; computation expression comes from &quot;fun.thunk&quot;. New mode is equal to:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stk<span class="op">,</span>
      comp<span class="op">:</span> <span class="va">fun</span>.<span class="at">thunk</span></code></pre></div>
<ul>
<li><strong>&quot;callback&quot;</strong> - This means command has been found and executed and now the machine has to restore the stack to its original position. It does this by looping through the &quot;callback&quot; while building the stack with callbacks frames. When it is done, machine returns a mode constructed of the restored stack and first element of arguments list.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      stack<span class="op">:</span> stack<span class="op">,</span>
      comp<span class="op">:</span> args[<span class="dv">0</span>]</code></pre></div>
<p><strong>printer</strong> - takes the mode of finished execution, parses it to make it readable and displays it on the browser's console.</p>
<h2 id="built-in-functions"><span class="header-section-number">5.5</span> Built-in functions</h2>
<p>Current built-in functions include &quot;plus&quot; and &quot;minus&quot;, in order to make integer manipulation possible. They are defined before the top-level function compilation begins in function <em>operatorCompile</em> and then just initialized together with them, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> fs <span class="fu">=</span> [(f, (h, pse)) <span class="fu">|</span> <span class="dt">DF</span> f h pse <span class="ot">&lt;-</span> ds] <span class="fu">++</span> builtins</code></pre></div>
<p>However their current definitions are a bit different. The compiler is not able to give them meaning because it does not know how to manipulate two integer expressions; instead compiler must pass this functionality to the abstract machine, which can interpret those expressions and apply wanted arithmetic operation. The compiler codes wanted arithmetic operation into the function definition, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">DF</span> <span class="st">&quot;minus&quot;</span> [] [<span class="fu">...</span>], <span class="dt">EV</span> <span class="st">&quot;x&quot;</span> <span class="fu">:$</span> [<span class="dt">EV</span> <span class="st">&quot;y&quot;</span>, <span class="dt">EV</span> <span class="st">&quot;y&quot;</span>]</code></pre></div>
<p>&quot;:$&quot; means application, compiler tries to apply integer variable &quot;x&quot; to a list of integer variables &quot;y&quot;, which initially does not make any sense. However, machine has encoded semantics for this situation. If integer, therefore, is applied to a list of arguments that could only mean one of two things, either that integer needs to be added to the first element of the list or subtracted from it. The machine determines the arithmetic operation by looking how many elements are in the argument list and applies the correct operation accordingly.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">args</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">2</span>) <span class="op">{</span> <span class="co">// minus</span>
  answ <span class="op">=</span> <span class="va">fun</span>.<span class="at">int</span> <span class="op">-</span> args[<span class="dv">0</span>].<span class="va">value</span>.<span class="at">int</span><span class="op">;</span>
<span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="co">// plus</span>
  answ <span class="op">=</span> <span class="va">fun</span>.<span class="at">int</span> <span class="op">+</span> args[<span class="dv">0</span>].<span class="va">value</span>.<span class="at">int</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Those were special cases when compiler is not able to deal with them, however other built-in functions, which do not require arithmetic operations can easily be added without machine knowing about them. Such as, pairing two elements or getting first element out of a pair.</p>
<h2 id="possible-improvements"><span class="header-section-number">5.6</span> Possible improvements</h2>
<p><strong>Abstract machine</strong></p>
<ul>
<li><p>To store stack frames in chunks of frames, where only the top frame of a given chunk could potentially handle a command. When searching for a command's handler this method would allow to jump through frames, which tags are not equal to &quot;arg&quot;, therefore improving performance and efficiency. This improvement is based on concepts described in &quot;Proceedings of the 1st International Workshop on Type-Driven Development&quot; <span class="citation">(Daniel Hillerström and Sam Lindley 2016)</span>;</p></li>
<li><p>Add string concatenation and built-in web feature support.</p></li>
</ul>
<p><strong>Compiler</strong></p>
<ul>
<li><p>Current state of JavaScript type definitions are not enforced by the compiler; so compiler trusts the programmer to encode them correctly. The improvement would be to enforce types with Haskell data structures, thus minimizing the risk of bugs in production;</p></li>
<li><p>To change pattern matching procedures from &quot;match-this-or-bust&quot; <span class="citation">(F.V. McBride 1970)</span> to building a tree of switches described in &quot;Functional Programming and Computer Architecture&quot; <span class="citation">(Lennart Augustsson 1985)</span>, in order to increase efficiency;</p></li>
<li><p>Implement string concatenation support.</p></li>
</ul>
<h1 id="verification-and-validation"><span class="header-section-number">6</span> Verification and Validation</h1>
<p>This project's verification and validation were done strictly throughout testing. Development was done in two parts, development of experimental system (for learning purposes) and development of the final system. Initial testing started at early stages of the project, by testing experimental system's abstract machine behavior without the interaction of the compiler. At that point it was done manually, by the author typing in expressions and looking through the output, however as development went on it quickly became too inefficient. An experimental testing framework, thus, was developed (February 10th, 2017), which would go through pre-set test cases one by one without any human interaction while giving feedback for the user in the process. Author then adapted the system and applied lessons learned to create improved framework for the final system.</p>
<p>During the implementation of both systems test cases were added regularly, after each newly developed component. Moreover, on the account of iterative and incremental development methodology (IDD) author was able to write targeted test cases for every component of the system. As a consequence, new bugs were identified and tracked faster, thus leading for faster software development. Test cases were initiated before every content push to git as well as during the development to check for any broken parts of the system.</p>
<p>After the implementation has ended, test framework was initiated again to see if all tests still pass, as well as some manual testing was done by the author to verify the state of the system. Furthermore, test programs from &quot;Frankjnr&quot; implementation were lifted and used to verify the behavior of the final system by confirming that the output of the tests are the same in both systems. More on this in <strong>Chapter 7</strong>.</p>
<p>Possible improvement would to be to use service similar to <em>Jenkins</em>, in order to automate tests by automatically launching them and giving back feedback after every push to git and once a day regularly.</p>
<p>For full list of test case expressions and programs see <strong>Appendix 3</strong>.</p>
<h2 id="experimental-testing-framework"><span class="header-section-number">6.1</span> Experimental testing framework</h2>
<p>This section will describe the implementation of the experimental testing framework. It consists of two files utilizing two different scripts: Bash script and Expect script. Its purpose is to automate the testing process. Below each of these scripts will be reviewed.</p>
<h3 id="bash-script-1"><span class="header-section-number">6.1.1</span> Bash script</h3>
<p>Bash script is the main script in the testing framework which stores test cases, then goes through them one by one. To launch the script user has to input <em>./tester.sh</em> in the terminal window. For full guide on installation and usage see <strong>Appendix 2</strong>.</p>
<p>Test cases are arrays which store free values: expression to be tested, the name of the test and expected output. Below sample test case is displayed:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test0=(</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 10&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_num&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;10&#39;</span>
)</code></pre></div>
<p>For each test case Bash script launches Expect script and passes test case parameters to it, in particular it passes the expression to be tested and the name of the test:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tests/helper.sh</span> <span class="va">${test[expr]}</span> <span class="va">${test[name]</span></code></pre></div>
<p>After, Expect script &quot;helper.sh&quot; finishes computing new program is generated, system must recompile abstract machine's code to use newly generated program. <em>Webpack</em> is used to compile JavaScript files to one and to manage their structure.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span> --hide-modules <span class="co">#recompile to output.js </span></code></pre></div>
<p>After successful compilation of JavaScript Bash script has to retrieve the output of the program by getting the last line of the console output, it does this by utilizing <em>Node</em> library and some string manipulation.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">output=$(</span><span class="ex">node</span> ./dist/output.js<span class="va">)</span>; <span class="co">#get output</span>
<span class="va">output=</span><span class="st">&quot;</span><span class="va">${output##</span>*<span class="st">$&#39;</span><span class="dt">\n</span><span class="st">&#39;</span><span class="va">}</span><span class="st">&quot;</span> <span class="co">#take only last line</span></code></pre></div>
<p>Finally, Bash script just compares the expected output with actual output and gives back the result for the user to see.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">if</span><span class="bu"> [</span> <span class="st">&quot;</span><span class="va">$output</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;</span><span class="va">${test[expected]}</span><span class="st">&quot;</span><span class="bu"> ]</span>; <span class="kw">then</span>
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${GREEN}</span><span class="st">Test passed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">else</span> 
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${RED}</span><span class="st">Test failed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre></div>
<h3 id="expect-script"><span class="header-section-number">6.1.2</span> Expect script</h3>
<p>Expect script is used because of its ability to send and receive commands to systems which have their own terminal, in this case <em>GHCI</em>. Developed script takes the name of the test and the expression to be tested. Since it is only possible to pass one array to Expect script, the script performs some array manipulation to retrieve the name and the expression which was passed by the Bash script.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">set</span> <span class="fu">expr</span> [lrange <span class="va">$argv</span> 0 end-1]
<span class="kw">set</span> <span class="ex">name</span> [lindex <span class="va">$argv</span> end 0]</code></pre></div>
<p>After that it launches <em>GHCI</em> terminal.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">spawn</span> ghci</code></pre></div>
<p>Then scripts waits for &quot;&gt;&quot; character before sending the command to load the &quot;Compiler.hs&quot; file, which is experimental system's compiler.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;:load Compiler.hs\r&quot;</span></code></pre></div>
<p>Finally, Expect script sends the two following commands with some variables (taken form the array) to generate the output of the compiler and quits to resume the Bash script execution.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;</span><span class="va">$b</span><span class="st">\r&quot;</span>

<span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;jsWrite (jsSetup </span><span class="dt">\&quot;</span><span class="va">$name</span><span class="dt">\&quot;</span><span class="st"> (compile xpr))\r&quot;</span> </code></pre></div>
<h3 id="possible-improvements-1"><span class="header-section-number">6.1.3</span> Possible improvements</h3>
<ul>
<li>Speed and efficiency;</li>
<li>Move test cases into separate file to improve structure;</li>
<li>More useful statistics at the end of test framework computation;</li>
</ul>
<h2 id="final-testing-framework"><span class="header-section-number">6.2</span> Final testing framework</h2>
<p>Contained in <em>final_implementation/Backend/tests</em> folder. Framework is designed to launch number of programs, located in <em>test_cases</em> folder, and give back feedback to the user on which test programs succeeded and which ones failed. This framework eliminates manual testing, lets identify bugs faster, thus speeding up development process and easing maintenance. It is, also, fully written in Bash script, unlike experimental testing framework. Some parts of the test framework were lifted from earlier experiment, however the key differences are that it is not using GHC compiler directly; so it eliminates the need for Expect script (previously located in &quot;helper.sh&quot; file),thus improving performance of the framework. Another change is that test cases don't take in expressions anymore, instead they take in paths to actual programs. This, therefore, provides an ability to launch complete programs and check their outputs.</p>
<p>For all test case programs see <strong>Appendix 3</strong>. For usage and installation instructions see <strong>Appendix 2</strong>.</p>
<h3 id="implementation-2"><span class="header-section-number">6.2.1</span> Implementation</h3>
<p>Similarly like in experimental system's testing framework, test cases are stored in an array. Each of the test cases are objects which store three values: path of the test program, name of the test and expected output. They are looped through one by one, displaying the name of the test to the user and recompiling the test with:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> <span class="va">${test[path]}</span> --output-js</code></pre></div>
<p>It generates the &quot;gen.js&quot; in <em>Backend/machine/dist</em> folder. At this point <em>Backend/machine/dist/output.js</em> needs to be compiled again to include new &quot;gen.js&quot; file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span> --hide-modules</code></pre></div>
<p>The script, then, just retrieves the output with <em>Node</em> and checks if it as expected or not while letting the user know if test failed or passed (same way as in experimental testing framework). Finally, some statistics are shown on how many tests in total have passed and failed with corresponding percentage values.</p>
<h3 id="possible-improvements-2"><span class="header-section-number">6.2.2</span> Possible improvements</h3>
<ul>
<li>Providing more statistics when all tests are executed;</li>
<li>Timestamp tests, letting the user know how much time it took to run individual tests and all of them together;</li>
<li>Improve performance by not trying to launch programs which fail to compile by &quot;Frankjnr&quot; compiler.</li>
</ul>
<h1 id="results-and-evaluation"><span class="header-section-number">7</span> Results and Evaluation</h1>
<h2 id="outcome"><span class="header-section-number">7.1</span> Outcome</h2>
<h3 id="experimental-system-1"><span class="header-section-number">7.1.1</span> Experimental system</h3>
<p>During the initial development stages, an experimental system was developed with its own language, compiler, virtual machine and testing framework in order to expand the author’s insight of the subject. The experimental system is able to compile and run a specific list of operations on the browser, particularly the sum of two expressions, &quot;Throw&quot; and &quot;Catch&quot;, &quot;Set&quot;, &quot;Next&quot;, &quot;Get&quot; and can also create a new reference. These operations were chosen because they each have a significantly different implementation, thus offering a broader learning experience for the author. The abstract machine is written in JavaScript; it is therefore able to communicate with compiled expressions on run-time. The defining quality of the abstract machine is that it utilizes stack as its core data structure, with support for interrupts. They have connected handlers which, when initiated, start going through the stack, in order to execute a particular operation; when finished, the handlers restore the stack to its original position and give back control.</p>
<p>Here is an example of an expression with many of the available operations in action. Initially, variable &quot;x&quot; is created with value of &quot;22&quot;; then it is assigned a new meaning which constitutes of the sum between the previous &quot;x&quot; value and the added value &quot;11&quot;. Moving on, &quot;Next&quot; (&quot;:&gt;&quot;) operation is used to initiate the last expression, where the new value of &quot;x&quot; is added with a value &quot;30&quot;. The virtual machine will return &quot;63&quot; in the browser for this expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WithRef</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Val</span> <span class="dv">22</span>) (
    <span class="st">&quot;x&quot;</span> <span class="fu">:=</span> (<span class="dt">Get</span> <span class="st">&quot;x&quot;</span> <span class="fu">:+:</span> <span class="dt">Val</span> <span class="dv">11</span>)
        <span class="fu">:&gt;</span> (<span class="dt">Get</span> <span class="st">&quot;x&quot;</span> <span class="fu">:+:</span> <span class="dt">Val</span> <span class="dv">30</span>))</code></pre></div>
<p>Lastly, the computation is interrupted on &quot;:=&quot; and &quot;Get&quot; commands and control is given to the handler, in order to search through the stack and retrieve or update the reference of &quot;x&quot;.</p>
<h3 id="final-system"><span class="header-section-number">7.1.2</span> Final system</h3>
<p>The style of the code and a few functions of the experimental system were adapted in creating the final system. The author was successful in implementing a new abstract machine and compiler for &quot;Shonky&quot; data structures, which were in turn integrated into the Frankjnr project. The final system supports variables, integer values, atoms, pairs, function application, local functions, commands, thunk patterns, top level functions, and also contains built-in semantics for addition and subtraction. All of these features together offer a nearly complete development package, allowing virtually any current Frank program to be compiled by the new compiler and successfully executed by the abstract machine in a browser.</p>
<p>Here is a quick example of how the compiler and abstract machine would work together and how user may use it. The user is able to execute Frank programs in four steps. The first step is to write a program in Frank with file ending in &quot;.fk&quot;, such as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> fib <span class="dv">5</span>

fib <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib <span class="dv">2</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p>The second step is to compile it with a flag &quot;output-js&quot; to initiate the new compiler; this will generate a &quot;gen.js&quot; file in <em>Backend/machine/dist</em> directory with resumptions and operators arrays, which may be used by the virtual machine.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> fib.fk --output-js</code></pre></div>
<p>The third step is to recompile the machine's code (in <em>machine</em> folder), to include the newly generated file, with the <em>webpack</em> command. Finally, the user needs to include the &quot;output.js&quot; from <em>dist</em> folder, in theirs project's HTML file. In this example, the user would see &quot;5&quot; as the computation result in the browser.</p>
<h4 id="limitations"><span class="header-section-number">7.1.2.1</span> Limitations</h4>
<p>All of the limitations are possible improvements and they are mainly present due to time constraints.</p>
<ul>
<li>The compilation of Frank programs with the new compiler can be initiated only from the base final_implementation folder, because the file generation path is fixed for testing purposes;</li>
<li>To be compiled successfully, a Frank program must have a &quot;main&quot; function and must also be the first one in the file;</li>
<li>There is a lack of current web functionality support. However, because of Frank's ability to suspend a current computation, to handle commands and to restart the machine afterwards, Frank's code has a potential to query or initiate DOM updates; this functionality could be achieved in the near future;</li>
<li>Some features are still in prototype stages and a few have not been implemented, such as string concatenation.</li>
</ul>
<h2 id="evaluation"><span class="header-section-number">7.2</span> Evaluation</h2>
<p>An experimental evaluation was chosen for this project, done in two parts. The first part was benchmarking the performance of the developed system against two other similar systems (automatic evaluation); the second part was comparing the functionality of the developed system to Frankjnr’s original components.</p>
<h3 id="benchmark"><span class="header-section-number">7.2.1</span> Benchmark</h3>
<p>The benchmarking framework can be found in<br />
<em>final_implementation/Backend/benchmark</em> folder. Benchmark tests can be initiated in a terminal window by typing <em>./evalNewBackend.sh</em>, <em>./evalVole.sh</em> or <em>./evalFrankjnr.sh</em>. The requirements for launching the benchmark tests are the same as the ones for the final system; however, the scripts must have valid permissions.</p>
<p>This benchmark was solely focused on the performance of the systems. Two types of times were taken into account: the compilation time and the execution time. The compilation time describes how fast a given program is parsed and compiled; the execution time reveals how fast a virtual machine returns the final result. A Vagrant (Virtual Box) environment with two gigabytes of allocated memory was used for running the tests. These environments are known to be considerably slower than real ones; chosen systems might perform faster in the real world; however, in this case, systems were only compared against each other. The following systems were benchmarked:</p>
<ul>
<li>Final system (developed by the author of this project);</li>
<li>Frankjnr original system;</li>
<li>Vole.</li>
</ul>
<p>A single test included the compilation and the execution of a given program, done 100 times, repeated 5 times for each system. The program which was executed had the same semantics for all systems. Shown below is the program used to benchmark Fraknjr and a new back-end.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">List</span> (<span class="dt">List</span> <span class="dt">Num</span>)
main<span class="fu">!</span> <span class="fu">=</span> map {x <span class="ot">-&gt;</span> cons (wrap x) nil} (cons <span class="dt">Num</span> (cons <span class="dt">Num</span> (cons <span class="dt">Num</span> nil)))

<span class="kw">data</span> <span class="dt">Num</span> <span class="fu">=</span> <span class="dt">Num</span> <span class="fu">|</span> wrap <span class="dt">Num</span>

map <span class="fu">:</span> {a <span class="ot">-&gt;</span> b} <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
map f nil <span class="fu">=</span> nil
map f (cons x xs) <span class="fu">=</span> cons (f x) (map f xs)</code></pre></div>
<table>
<caption>Benchmark result table</caption>
<thead>
<tr class="header">
<th>Test Nr.</th>
<th>Final system</th>
<th>Original system</th>
<th>Vole</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Test 1</td>
<td>2.787 sec.</td>
<td>0.754 sec.</td>
<td>1.261 sec.</td>
</tr>
<tr class="even">
<td>Test 2</td>
<td>2.847 sec.</td>
<td>0.882 sec.</td>
<td>1.293 sec.</td>
</tr>
<tr class="odd">
<td>Test 3</td>
<td>3.005 sec.</td>
<td>0.993 sec.</td>
<td>1.226 sec.</td>
</tr>
<tr class="even">
<td>Test 4</td>
<td>2.962 sec.</td>
<td>1.046 sec.</td>
<td>1.248 sec.</td>
</tr>
<tr class="odd">
<td>Test 5</td>
<td>2.976 sec.</td>
<td>1.029 sec.</td>
<td>1.227 sec.</td>
</tr>
<tr class="even">
<td>Average</td>
<td>2.915 sec.</td>
<td>0.941 sec.</td>
<td>1.251 sec.</td>
</tr>
</tbody>
</table>

<p>The concerns and challenges included:</p>
<ul>
<li>Vole uses a different compiler with its own terminal; expect script was therefore used, which might have affected performance;</li>
<li>The final system is dependent on the Frankjnr compiler;</li>
<li>The final system uses a JavaScript-powered machine as opposed to others, which use Haskell abstract machines.</li>
</ul>
<p>This evaluation gives an explicit illustration of the state of the system in terms of performance, in comparison with other similar systems. These results were anticipated, however, as performance was not one of the core goals of the project. The developed benchmark framework could be effectively reused after further development to efficiently check for changes in performance.</p>
<h3 id="functionality-comparison"><span class="header-section-number">7.2.2</span> Functionality comparison</h3>
<p>One of the main goals in creating the final system was for it to support the same functionality as Frankjnr’s original components, while also adding web development features. The known main features of both systems were extracted and compared; the table below illustrates the outcomes of the comparison.</p>
<table>
<caption>Supported functionality</caption>
<thead>
<tr class="header">
<th>Feature</th>
<th>Final system</th>
<th>Original system</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Integer support</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>String concatenation</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Local functions</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Functions</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Commands</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Variables</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Atoms</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Pairs</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Application</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Composition</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Built-in functions</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Parse Shonky files</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Web development support</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>A new test program was created and executed by both systems to collect the results for each feature. If the program threw an exception, or the output was not as expected, the tested feature would not be supported by the system. In addition, the author took Frankjnr’s original test cases from tests folder and initiated them against the final system, in order to see the results from a different perspective. Out of the twelve original tests, four did not pass on the final system; this was because all of them were connected to functionality, such as string concatenation, which had not been implemented at the time. For a more detailed overview of testing, see <strong>chapter 6</strong>.</p>
<p>This evaluation positively illustrates that the developed system can directly compete with the original Frankjnr back-end in terms of functionality, and that most goals of the project have been attained.</p>
<h1 id="summary-conclusion"><span class="header-section-number">8</span> Summary &amp; Conclusion</h1>
<h2 id="summary"><span class="header-section-number">8.1</span> Summary</h2>
<p>Overall, the outcome of the project was successful. The author developed two systems with their own matching compilers and virtual machines. The initial system was developed as an experiment, to provide the author with practical knowledge on the subject, which he then applied into the development of the final system. The system is able to compile Frank code and to run it in the browser. Virtually all current Frank programs can be compiled and executed successfully by the system; the overarching goal of the project was therefore effectively obtained. However, due to time constraints, the final system is yet in prototype stages, as it does not support all of Frank's features and contains a few fixable limitations, highlighted in the <strong>Future work</strong> section.</p>
<p>During the course of the project, the author learned a variety of concepts. First of all, he expanded his knowledge on functional programming by coding the compiler with Haskell while utilizing various data types, such as monads. Secondly, the author was able to learn the infrastructure, the functionality and the implementation of compilers and abstract machines through research and participation in numerous discussions with his supervisor, Conor McBride. The author also gained a greater insight into Bash script while creating the testing frameworks for both systems and working on the project evaluation. Finally, the author learned the language of Frank and the implementation of its defining qualities.</p>
<h2 id="future-work"><span class="header-section-number">8.2</span> Future work</h2>
<ul>
<li>Implement missing features, such as string concatenation;</li>
<li>Improve the testing framework so that it show more statistics and uses timestamps;</li>
<li>Expand the support for web features, such as HTTP request handling support or the handling of DOM updates;</li>
<li>Improve the abstract machine's performance by storing stack frames in chunks, which would speed up searching and restoring stack, idea is based on &quot;Proceedings of the 1st International Workshop on Type-Driven Development&quot; <span class="citation">(Daniel Hillerström and Sam Lindley 2016)</span>;</li>
<li>Enforce JavaScript type definitions with Haskell structures, in order to decrease the risk of bugs;</li>
<li>Increase compiler efficiency by updating pattern-matching procedures; building a tree of switches as described in &quot;Functional Programming and Computer Architecture&quot; <span class="citation">(Lennart Augustsson 1985)</span>;</li>
<li>Improve building procedures;</li>
<li>Further optimize the compiler and the abstract machine;</li>
</ul>
<h1 id="appendix-1-progress-log" class="unnumbered">Appendix 1: Progress log</h1>
<p><strong>JANUARY</strong></p>
<p>January 4th:<br />
<em>Research:</em><br />
Looked over Frankjnr, Shonky, Vole implementations.</p>
<p>January 5th:<br />
Tried to install Frankjnr for a period of time, however couldn’t resolve all the errors.</p>
<p>January 7th:<br />
<em>Research:</em><br />
Looked at Vole with a bit more detail.</p>
<p>January 9th:<br />
Tried to install Frankjnr by using Cabal dependency management tool, no success (deprecated dependencies).<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 10th:<br />
<em>Research:</em><br />
Looked at Vole, in particular Machine.lhs, Compile.lhs and Vole.js.</p>
<p>January 11th:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 16th:<br />
<em>Research:</em><br />
Looked at Shonky stack implementation, tried to output it on the screen.</p>
<p>January 17th:<br />
<em>Machine Development:</em><br />
Implemented simple linked list stack in JavaScript, just as a practice.</p>
<p>January 18th:<br />
<em>Research:</em><br />
Looked again at Shonky’s Abstract Machine, particularly the order the input is parsed.</p>
<p>January 24th:<br />
<em>Machine Development:</em><br />
Implemented simple Abstract Machine, which can sum 2 numbers.</p>
<p>January 25th:<br />
<em>Machine Development:</em><br />
Machine now works with stack larger than 2.<br />
Updated the way it stores functions, now it uses Array data structure.<br />
<em>Research:</em><br />
Looking into how to implement throw, catch and compiler.</p>
<p>January 26th:<br />
<em>Compiler Development:</em><br />
Created basic language in Haskell. Which supports expressions and sum of expressions.<br />
Developed monadic structure for the compiler.</p>
<p>January 30th:<br />
<em>Compiler Development:</em><br />
Finished the basic layout, however it doesn’t display any results yet.<br />
Presentation &amp; Report Work:<br />
Setup of latex with lex2tex.</p>
<p>January 31th:<br />
<em>Machine Development:</em><br />
Implemented Throw and Catch for Abstract Machine.<br />
Presentation &amp; Report work:<br />
Worked on structure of the report.</p>
<p><strong>FEBRUARY</strong></p>
<p>February 01:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on latex configurations.</p>
<p>February 02:<br />
<em>Machine Development:</em><br />
Implemented early versions of stack saving, restoring and support for Set command.</p>
<p>February 04:<br />
<em>Presentation &amp; Report work:</em><br />
Report work - Introduction sections.</p>
<p>February 06:<br />
<em>Compiler Development:</em><br />
Tried to implement Show instance for CodeGen function.</p>
<p>February 07:<br />
<em>Research:</em><br />
Looked at the lifecycle and expected behaviour of the Compiler.<br />
<em>Compiler Development:</em><br />
Implemented Compiler Catch and Throw.</p>
<p>February 08:<br />
<em>Compiler Development:</em><br />
Implemented Get, Next, WithRef commands.<br />
<em>Machine Development:</em><br />
Implemented support for Next commands.<br />
Added new examples of working programs.</p>
<p>February 09:<br />
<em>Machine development:</em><br />
Implemented early version of stack saving and restoring.<br />
Implemented support for Set commands.<br />
Added new working examples.<br />
Reworked Next command support, should work as expected.</p>
<p>February 10:<br />
<em>Test Framework development:</em><br />
Implemented test framework by utilizing Bash and Expect scripts.<br />
<em>Machine development:</em><br />
Divided code into separate classes and files.<br />
Added printer class, which just outputs the current stack to the console.</p>
<p>February 13:<br />
Started to rework Abstract Machine, to closer match the implementation required.<br />
<em>Machine development:</em><br />
Reworked Catch and Throw command support.<br />
<em>Compiler development:</em><br />
Small efficiency adjustments.<br />
Test Framework development:<br />
Added more test cases.<br />
General bug fixes.</p>
<p>February 14: <em>Test Framework development:</em><br />
Fixed major bug with string parsing.<br />
Added more test cases.<br />
<em>Machine development:</em><br />
Completely reworked support for Get, Set and WithRef commands.<br />
General bug fixes.</p>
<p>February 15:<br />
Progress report.</p>
<p>February 16:<br />
Progress report.</p>
<p>February 24:<br />
<em>Final Compiler development:</em><br />
Outputting generated code to js file.<br />
Researched top level functions.<br />
<em>Project</em><br />
Updated project structure.</p>
<p><strong>March</strong></p>
<p>March 05:<br />
<em>Report</em><br />
Chapter 4 almost done.<br />
<em>Project</em><br />
Improvements all around: bug fixes, documentation updates.</p>
<p>March 07:<br />
<em>Report</em><br />
Related work section<br />
Introduction chapter summarization<br />
<em>Final Compiler development:</em><br />
Attempt to implement operators array<br />
Looking into how to compile operator variables</p>
<p>March 08:<br />
<em>Report</em><br />
Background section<br />
<em>Final Compiler development:</em><br />
Various fixes<br />
operatorCompile function adjustment<br />
File Writer adjustment</p>
<p>March 09:<br />
<em>Report</em><br />
Related work section<br />
<em>Final Compiler development:</em><br />
Adjusted file generation<br />
Fixed operatorCompile function<br />
<em>Final Abstract Machine development:</em><br />
Initialized project structure with webpack<br />
Initial implementation of final Machine (support for CAR and CDR operations)</p>
<p>March 10:<br />
<em>Final Compiler development:</em><br />
Adjusted type definitions<br />
Added one layer of structure to Computations<br />
<em>Final Abstract Machine development:</em><br />
Fixed bugs regarding CAR and CDR<br />
Optimization- &quot;go&quot; tag is not needed, creating modes directly<br />
CDR now returns pair</p>
<p>March 11:<br />
<em>Final Compiler development:</em><br />
Added needed functionality to compiler to support 'application' operations<br />
<em>Final Abstract Machine development:</em><br />
Added functionality for FUN and ARG, still need to figure out how to apply a function to ready list</p>
<p>March 12:<br />
<em>Final Compiler development:</em><br />
Added parser functions, now the compiler is able to covert Shonky language to its syntax<br />
<em>Final Testing Framework development:</em><br />
Created initial structure of the framework as well as sample test case<br />
<em>Report</em><br />
Problem overview section</p>
<p>March 13:<br />
<em>Final Compiler development:</em><br />
Commands development<br />
<em>Final Abstract Machine development:</em><br />
Commands development<br />
<em>Report</em><br />
Specification section</p>
<p>March 14:<br />
<em>Final Compiler development:</em><br />
Bug fixes<br />
<em>Final Abstract Machine development:</em><br />
Bug fixes, command support implemented<br />
<em>Report</em><br />
Requirement analysis section<br />
<em>Project structure</em><br />
Frankjnr now uses new back end</p>
<p>March 15:<br />
Project structure updates<br />
Report work</p>
<p>March 16:<br />
Local functions development</p>
<p>March 17:<br />
Test framework development<br />
Compiler and Machine - added Built in function support<br />
Machine Print function development</p>
<p>March 18:<br />
Report work - Final implementation section and appendixes</p>
<p>March 19:<br />
Report:<br />
Abstract machine section</p>
<p>March 20:<br />
Report:<br />
Testing and validation sections</p>
<p>March 21:<br />
Benchmarking and evaluation sections</p>
<p>March 22:<br />
Evaluation and conclusion</p>
<p>March 23:<br />
User guide and report work</p>
<p>March 24:<br />
Report work</p>
<p>March 25:<br />
Report work</p>
<h1 id="appendix-2-usage-installation-instructions" class="unnumbered">Appendix 2: Usage &amp; installation instructions</h1>
<h2 id="final-system-1" class="unnumbered">Final system</h2>
<h3 id="requirements" class="unnumbered">Requirements</h3>
<ul>
<li>Node (https://nodejs.org/en/)</li>
<li>npm (https://www.npmjs.com/)</li>
<li>webpack (https://webpack.github.io/)</li>
<li>ghc (https://www.haskell.org/ghc/)</li>
<li>Frank</li>
</ul>
<h3 id="setup-frank" class="unnumbered">Setup Frank</h3>
<p>After installing <em>Node, </em>npm<em>, </em>webpack* and <em>ghc</em> to used environment. User needs to navigate to <em>final_implementation</em> folder and install Frank by typing following commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">stack</span> setup
<span class="ex">stack</span> install</code></pre></div>
<p>User might need to edit their machine's environment path, to include Frank.</p>
<h3 id="compiling-and-executing-programs" class="unnumbered">Compiling and executing programs</h3>
<p>User is able to compile any Frank program from <em>final_implementation</em> directory or sub directories with flag &quot;output-js&quot;. Example:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> examples/foo.fk --output-js</code></pre></div>
<p>This will generate &quot;gen.js&quot; in <em>final_implementation/Backend/machine/dist</em> directory. Now user has to recompile the machine's code. In the <em>/final_implementation/Backend/machine</em> folder execute command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span></code></pre></div>
<p>&quot;output.js&quot; will be generated in the same folder as &quot;gen.js&quot; was, user can place it in their HTML file to initiate execution and see results of the compiled program.</p>
<h3 id="tests" class="unnumbered">Tests</h3>
<p>Script initiates test cases and outputs the result in the terminal window.</p>
<h4 id="usage" class="unnumbered">Usage</h4>
<p>Folder: <em>final_implementation/Backend/tests</em>.</p>
<p>Run test cases:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tester.sh</span></code></pre></div>
<h4 id="troubleshooting" class="unnumbered">Troubleshooting</h4>
<p>If <em>tester.sh</em> have issues with permissions - possible solution:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">chmod</span> +x tester.sh
<span class="fu">chmod</span> +x testcases.sh</code></pre></div>
<h3 id="benchmark-1" class="unnumbered">Benchmark</h3>
<p>In the <em>final_implementation/Backend/benchamrk</em> directory initiate any of the benchmarks by executing the Bash script. Example:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./evalFrankjnr.sh</span></code></pre></div>
<h2 id="experimental-system-2" class="unnumbered">Experimental system</h2>
<h3 id="requirements-1" class="unnumbered">Requirements</h3>
<ul>
<li>Node (https://nodejs.org/en/)</li>
<li>npm (https://www.npmjs.com/)</li>
<li>webpack (https://webpack.github.io/)</li>
<li>ghc (https://www.haskell.org/ghc/)</li>
<li>Expect script - required for testing, install command:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    <span class="ex">apt-get</span> install expect</code></pre></div>
<h3 id="usage-1" class="unnumbered">Usage</h3>
<p>Initiates the compiler in the <em>simple_implementation</em> directory:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">ghci</span> Compiler.hs</code></pre></div>
<p>Define and compile valid expression, providing the name of the expression to &quot;jsSetup&quot; function in the process. Example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> xpr <span class="fu">=</span> <span class="dt">WithRef</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Val</span> <span class="dv">2</span>) (<span class="dt">Val</span> <span class="dv">5</span> <span class="fu">:+:</span> (<span class="dt">Get</span> <span class="st">&quot;x&quot;</span>))
jsWrite (jsSetup <span class="st">&quot;example_program&quot;</span> (compile xpr))</code></pre></div>
<p>This will generate &quot;generated.js&quot; file in <em>simple_implementation/dist&quot; directory. Now user has to recompile the abstract machine for it to include newly generated file. The user can do this by executing </em>webpack* command in the <em>simple_implementation</em> folder. Finally, &quot;output.js&quot; will be generated in *simple_implementation/dist&quot; directory, which user can include in your their project to see results of the compilation.</p>
<h3 id="tests-1" class="unnumbered">Tests</h3>
<p>In the <em>simple_implementation/tests</em> directory execute:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tester.sh</span></code></pre></div>
<h4 id="troubleshooting-1" class="unnumbered">Troubleshooting</h4>
<p>If files have issues with permissions:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">chmod</span> +x tester.sh
<span class="fu">chmod</span> +x helper.sh</code></pre></div>
<h1 id="appendix-3-test-cases" class="unnumbered">Appendix 3: Test cases</h1>
<h2 id="experimental-system-3" class="unnumbered">Experimental system</h2>
<p>This is a full list of experimental system's test cases. &quot;expr&quot; - is expression to be tested, &quot;name&quot; - the name of the test and &quot;expected&quot; is expected output.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test0=(</span> <span class="co">#value</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 10&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_num&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;10&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test1=(</span> <span class="co">#addition</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :+: (Val 4 :+: Val 8)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_sum&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;14&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test2=(</span> <span class="co"># Throw</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :+: (Val 4 :+: Throw)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_throw&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;Unhandled exception!&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test3=(</span> <span class="co"># Catch</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Catch (Val 2 :+:</span>
<span class="st">             (Val 4 :+: Throw)) (Val 2)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_catch&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;2&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test4=(</span> <span class="co"># Catch with previous stack</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = ((Val 5) :+: (Catch (Val 2 :+:</span>
<span class="st">                         (Val 4 :+: Throw)) (Val 2)))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_catch_stack&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;7&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test5=(</span> <span class="co"># Simple WithRef, value is not used</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2) </span>
<span class="st">                            (Val 5 :+: Val 3)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_simple_withref&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;8&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test6=(</span> <span class="co">#undifined variable</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Get &quot;x&quot; :+: Val 2&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_get_false&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;Exception: Undifined expression: x&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test7=(</span> <span class="co">#adding defined variable </span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2)</span>
<span class="st">                         (Val 5 :+: (Get &quot;x&quot;))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;7&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test8=(</span> <span class="co"># composition and variable defintion</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 2)</span>
<span class="st">                 ((&quot;x&quot; := (Get &quot;x&quot; :+: Val 11))</span>
<span class="st">                  :&gt; Get &quot;x&quot;)&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get_set&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;13&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test9=(</span> <span class="co"># same as test 8 but plus addition </span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 22)</span>
<span class="st">                         (&quot;x&quot; := (Get &quot;x&quot; :+: Val 11)</span>
<span class="st">                             :&gt; (Get &quot;x&quot; :+: Val 30))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get_set_next&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;63&#39;</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test10=(</span> <span class="co"># composition test</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 2 :&gt; Val 5 :+: Val 8</span>
<span class="st">                     :&gt; Val 1000 :&gt; Val 20 :+: Val 3&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_next&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;23&#39;</span>
)</code></pre></div>
<h2 id="final-system-2" class="unnumbered">Final system</h2>
<p>Below is a list of all test programs for the final system:</p>
<h3 id="new-test-programs" class="unnumbered">New test programs</h3>
<p><strong>Test program 1:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/add.fk&quot;.<br />
Description: Peano number addition.<br />
Expected result: [suc[suc[zero]]].</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> add (suc zero) (suc zero) 

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero <span class="fu">|</span> suc <span class="dt">Nat</span>

add <span class="fu">:</span> {<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>}
add zero b <span class="fu">=</span> b
add (suc a) b <span class="fu">=</span> suc (add a b)   </code></pre></div>
<p><strong>Test program 2:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/command.fk&quot;.<br />
Description: command test.<br />
Expected result: [pr[zero][suc[zero]]].<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 3:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/int.fk&quot;.<br />
Description: integer value test.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p><strong>Test program 4:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intAdd.fk&quot;.<br />
Description: integer addition test.<br />
Expected result: 20.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">10</span> <span class="fu">+</span> <span class="dv">10</span></code></pre></div>
<p><strong>Test program 5:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intMinus.fk&quot;.<br />
Description: integer minus test.<br />
Expected result: 10.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> <span class="dv">20</span> <span class="fu">-</span> <span class="dv">10</span></code></pre></div>
<p><strong>Test program 6:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intCommand.fk&quot;.<br />
Description: integer values with commands.<br />
Expected result: [pr01].<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 7:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intList.fk&quot;.<br />
Description: list with integer values.<br />
Expected result: [cons1[cons2[cons3[nil]]]].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">List</span> <span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p><strong>Test program 8:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intLocal.fk&quot;.<br />
Description: local functions with integer values.<br />
Expected result: [pr[cons0[cons1[cons2[nil]]]][cons0[cons1[cons2[nil]]]]].</p>
<p><em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 9:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/intOperator.fk&quot;.<br />
Description: operator call with integer value.<br />
Expected result: 3.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> plusOne(<span class="dv">2</span>)

plusOne <span class="fu">:</span> {<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>}
plusOne x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p><strong>Test program 10:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/lists.fk&quot;.<br />
Description: list test.<br />
Expected result: [cons[zero][cons[suc[zero]][cons[zero][nil]]]].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">List</span> <span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> [zero, suc zero, zero]

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero 
         <span class="fu">|</span> suc <span class="dt">Nat</span></code></pre></div>
<p><strong>Test program 11:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/local.fk&quot;.<br />
Description: local function test.<br />
Expected result:<br />
[pr[cons[zero][cons[suc[zero]][cons[suc[suc[zero]]][nil]]]]<br />
[cons[zero][cons[suc[zero]][cons[suc[suc[zero]]][nil]]]]].</p>
<p><em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 12:</strong></p>
<p>path: &quot;Backend/tests/test_cases/new/operator.fk&quot;.<br />
Description: list test.<br />
Expected result: [suc[zero]].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Nat</span>}
main<span class="fu">!</span> <span class="fu">=</span> plusOne(zero)

plusOne <span class="fu">:</span> {<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>}
plusOne x <span class="fu">=</span> suc x

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> zero 
         <span class="fu">|</span> suc <span class="dt">Nat</span></code></pre></div>
<h3 id="old-test-programs" class="unnumbered">Old test programs</h3>
<p>These programs are all lifted from &quot;Frankjnr&quot; implementation tests folder.</p>
<p><strong>Test program 13:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/app.fk&quot;.<br />
Description: application test.<br />
Expected result: 42.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Int</span>}
main<span class="fu">!</span> <span class="fu">=</span> app {f <span class="ot">-&gt;</span> f <span class="dv">42</span>} {x <span class="ot">-&gt;</span> x}

app <span class="fu">:</span> {{<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>} <span class="ot">-&gt;</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>}
app f x <span class="fu">=</span> f x</code></pre></div>
<p><strong>Test program 14:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/evalState.fk&quot;.<br />
Description: hello world.<br />
Expected result: &quot;Hello World!&quot;.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">String</span>
main<span class="fu">!</span> <span class="fu">=</span> evalState <span class="st">&quot;Hello&quot;</span> (put (append get<span class="fu">!</span> <span class="st">&quot; World!&quot;</span>); get<span class="fu">!</span>)

append <span class="fu">:</span> <span class="dt">List</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">X</span>
append nil ys <span class="fu">=</span> ys
append (cons x xs) ys <span class="fu">=</span> cons x (append xs ys)

interface <span class="dt">State</span> <span class="dt">X</span> <span class="fu">=</span> get <span class="fu">:</span> <span class="dt">X</span>
              <span class="fu">|</span> put <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>

evalState <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="fu">&lt;</span><span class="dt">State</span> <span class="dt">X</span><span class="fu">&gt;</span><span class="dt">Y</span>    <span class="ot">-&gt;</span> <span class="dt">Y</span>
evalState   x    <span class="fu">&lt;</span>put x&#39; <span class="ot">-&gt;</span> k<span class="fu">&gt;</span>  <span class="fu">=</span> evalState x&#39; (k unit)
evalState   x    <span class="fu">&lt;</span>get    <span class="ot">-&gt;</span> k<span class="fu">&gt;</span>  <span class="fu">=</span> evalState x (k x)
evalState   x         y         <span class="fu">=</span> y</code></pre></div>
<p><strong>Test program 15:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/fact.fk&quot;.<br />
Description: factorial.<br />
Expected result: 120.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> fact <span class="dv">5</span>

mult <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
mult <span class="dv">0</span> y <span class="fu">=</span> <span class="dv">0</span>
mult x y <span class="fu">=</span> y <span class="fu">+</span> mult (x<span class="fu">-</span><span class="dv">1</span>) y

fact <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> mult n (fact (n <span class="fu">-</span> <span class="dv">1</span>))</code></pre></div>
<p><strong>Test program 16:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/fib.fk&quot;.<br />
Description: Fibonacci generation and negative integer test.<br />
Expected result: 5.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> fib <span class="dv">5</span>

fib <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib <span class="dv">2</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)

minusTwoOnZero <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
minusTwoOnZero <span class="dv">0</span> <span class="fu">=</span> <span class="fu">-</span><span class="dv">2</span>
minusTwoOnZero n <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p><strong>Test program 17:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/flex-ab-eq.fk&quot;.<br />
Description: Regression for unifying effect-parametric datatype with flexible.<br />
Expected result: [unit].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> {<span class="dt">Unit</span>}
main<span class="fu">!</span> <span class="fu">=</span> boo foo<span class="fu">!</span>

interface <span class="dt">Eff</span> <span class="dt">X</span> <span class="fu">=</span> bang <span class="fu">:</span> <span class="dt">Unit</span>

<span class="kw">data</span> <span class="dt">Bar</span> <span class="fu">=</span> bar {<span class="dt">Unit</span>}

foo <span class="fu">:</span> [<span class="dt">Eff</span> <span class="dt">Bar</span>]<span class="dt">Unit</span>
foo<span class="fu">!</span> <span class="fu">=</span> unit

boo <span class="fu">:</span> <span class="fu">&lt;</span><span class="dt">Eff</span> <span class="dt">S</span><span class="fu">&gt;</span><span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>
boo   <span class="fu">&lt;</span>bang <span class="ot">-&gt;</span> k<span class="fu">&gt;</span> <span class="fu">=</span> boo k<span class="fu">!</span>
boo   unit        <span class="fu">=</span> unit</code></pre></div>
<p><strong>Test program 18:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/listMap.fk&quot;.<br />
Description: map a pure (addition) function over a list.<br />
Expected result:<br />
[cons[cons2[nil]][cons[cons3[nil]][cons[cons4[nil]][nil]]]].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">List</span> (<span class="dt">List</span> <span class="dt">Int</span>)
main<span class="fu">!</span> <span class="fu">=</span> map {x <span class="ot">-&gt;</span> cons (x<span class="fu">+</span><span class="dv">1</span>) nil} (cons <span class="dv">1</span> (cons <span class="dv">2</span> (cons <span class="dv">3</span> nil)))

interface <span class="dt">State</span> <span class="dt">X</span> <span class="fu">=</span> get <span class="fu">:</span> <span class="dt">X</span>
              <span class="fu">|</span> put <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span>

map <span class="fu">:</span> {a <span class="ot">-&gt;</span> b} <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
map f nil <span class="fu">=</span> nil
map f (cons x xs) <span class="fu">=</span> cons (f x) (map f xs)</code></pre></div>
<p><strong>Test program 19:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/paper.fk&quot;.<br />
Description: examples from the paper<br />
Expected result: &quot;do be &quot;.<br />
<em>Test program is too long to show, check provided path for the code.</em></p>
<p><strong>Test program 20:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r3.fk&quot;.<br />
Description: compiler Nontermination Issue No. 3.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> iffy <span class="dt">True</span> {<span class="dv">1</span>} {<span class="dv">2</span>}

<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>

iffy <span class="fu">:</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> {<span class="dt">X</span>} <span class="ot">-&gt;</span> {<span class="dt">X</span>} <span class="ot">-&gt;</span> <span class="dt">X</span>
iffy <span class="dt">True</span> t _  <span class="fu">=</span> t<span class="fu">!</span>
iffy <span class="dt">False</span> _ f <span class="fu">=</span> f<span class="fu">!</span></code></pre></div>
<p><strong>Test program 21:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r4.fk&quot;.<br />
Description: problem with unifying abilities identified by Jack Williams (No. 4).<br />
Expected result: 42.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> [<span class="dt">Console</span>]<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> apply foo<span class="fu">!</span>

<span class="kw">data</span> <span class="dt">Bar</span> <span class="fu">=</span> <span class="dt">One</span> {<span class="dt">Int</span>}

apply <span class="fu">:</span> <span class="dt">Bar</span> [<span class="dt">Console</span>] <span class="ot">-&gt;</span> [<span class="dt">Console</span>]<span class="dt">Int</span>
apply (<span class="dt">One</span> f) <span class="fu">=</span> f<span class="fu">!</span>

foo <span class="fu">:</span> {<span class="dt">Bar</span> [<span class="dt">Console</span>]}
foo<span class="fu">!</span> <span class="fu">=</span> <span class="dt">One</span> {<span class="dv">42</span>}</code></pre></div>
<p><strong>Test program 22:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r5.fk&quot;.<br />
Description: Suspended computation datatype argument.<br />
Expected result: [unit].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Unit</span>
main<span class="fu">!</span> <span class="fu">=</span> foo (just {unit})

<span class="kw">data</span> <span class="dt">Maybe</span> <span class="dt">X</span> <span class="fu">=</span> just <span class="dt">X</span> <span class="fu">|</span> nothing

foo <span class="fu">:</span> <span class="dt">Maybe</span> {<span class="dt">Unit</span>} <span class="ot">-&gt;</span> <span class="dt">Unit</span>
foo (just x) <span class="fu">=</span> x<span class="fu">!</span></code></pre></div>
<p><strong>Test program 23:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/r7.fk&quot;.<br />
Description: issue with recursive call in suspended comp..<br />
Expected result: [unit].<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Unit</span>
main<span class="fu">!</span> <span class="fu">=</span> unit

interface <span class="dt">Receive</span> <span class="dt">X</span> <span class="fu">=</span> receive <span class="fu">:</span> <span class="dt">X</span>

on <span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> {<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>} <span class="ot">-&gt;</span> <span class="dt">Y</span>
on x f <span class="fu">=</span> f x

receivePassthrough <span class="fu">:</span> <span class="fu">&lt;</span><span class="dt">Receive</span> <span class="dt">String</span><span class="fu">&gt;</span><span class="dt">X</span> <span class="ot">-&gt;</span> [<span class="dt">Receive</span> <span class="dt">String</span>]<span class="dt">X</span>
receivePassthrough x              <span class="fu">=</span> x
receivePassthrough <span class="fu">&lt;</span>receive <span class="ot">-&gt;</span> r<span class="fu">&gt;</span> <span class="fu">=</span>
  on receive<span class="fu">!</span> { s <span class="ot">-&gt;</span> receivePassthrough (r s) }</code></pre></div>
<p><strong>Test program 24:</strong></p>
<p>path: &quot;Backend/tests/test_cases/old/str.fk&quot;.<br />
Description: pattern matching list of strings.<br />
Expected result: 1.<br />
</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">:</span> []<span class="dt">Int</span>
main<span class="fu">!</span> <span class="fu">=</span> foo (cons <span class="st">&quot;abcd&quot;</span> nil)

foo <span class="fu">:</span> <span class="dt">List</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
foo (cons <span class="st">&quot;ab&quot;</span> (cons <span class="st">&quot;cd&quot;</span> nil)) <span class="fu">=</span> <span class="dv">0</span>
foo (cons <span class="st">&quot;abcd&quot;</span> nil) <span class="fu">=</span> <span class="dv">1</span>
foo _ <span class="fu">=</span> <span class="dv">2</span></code></pre></div>
<h1 id="appendix-4-relevant-readme-files" class="unnumbered">Appendix 4: Relevant README files</h1>
<h2 id="run-frank-in-browser" class="unnumbered">Run Frank in Browser</h2>
<h2 id="frankjnr-1" class="unnumbered">Frankjnr</h2>
<p>An implementation of the Frank programming language described in the paper ``Do be do be do'' by Sam Lindley, Conor McBride, and Craig McLaughlin, to appear at POPL 2017; preprint: https://arxiv.org/abs/1611.09259</p>
<p>Installation procedure</p>
<p>The easiest way to install <code>frank</code> is to use stack https://www.haskellstack.org), https://github.com/commercialhaskell/stack):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">stack</span> setup</code></pre></div>
<p>The above command will setup a sandboxed GHC system with the required dependencies for the project.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">stack</span> install</code></pre></div>
<p>The above command builds the project locally (<code>./.stack-work/...</code>) and then installs the executable <code>frank</code> to the local bin path (executing <code>stack path --local-bin</code> will display the path).</p>
<p>Running a Frank program</p>
<p>To run a <code>frank</code> program <code>foo.fk</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">frank</span> foo.fk</code></pre></div>
<p>By default the entry point is <code>main</code>. Alternative entry points can be selected using the <code>--entry-point</code> option.</p>
<p>Some example <code>frank</code> programs can be found in <code>examples</code>. They should each be invoked with <code>--entry-point tXX</code> for an appropriate number <code>XX</code>. See the source code for details.</p>
<p>Optionally a https://github.com/pigworker/shonky file can be output with the <code>--output-shonky</code> option.</p>
<p>Limitations with respect to the paper</p>
<ul>
<li><p>Only top-level mutually recursive computation bindings are supported</p></li>
<li><p>Coverage checking is not implemented</p></li>
</ul>
<h2 id="report-template" class="unnumbered">Report template</h2>
<p>Template for writing a PhD thesis in Markdown</p>
<p>This repository provides a framework for writing a PhD thesis in Markdown. I used the template for my PhD submission to University College London (UCL), but it should be straightforward to adapt suit other universities too.</p>
<p>Citing the template</p>
<p>If you have used this template in your work, please cite the following publication:</p>
<blockquote>
<p>Tom Pollard et al. (2016). Template for writing a PhD thesis in Markdown. Zenodo. http://dx.doi.org/10.5281/zenodo.58490</p>
</blockquote>
<p>Why write my thesis in Markdown?</p>
<p>Markdown is a super-friendly plain text format that can be easily converted to a bunch of other formats like PDF, Word and Latex. You'll enjoy working in Markdown because:</p>
<ul>
<li>it is a clean, plain-text format...</li>
<li>...but you can use Latex when you need it (for example, in laying out mathematical formula).</li>
<li>it doesn't suffer from the freezes and crashes that some of us experience when working with large, image-heavy Word documents.</li>
<li>it automatically handles the table of contents, bibliography etc with Pandoc.</li>
<li>comments, drafts of text, etc can be added to the document by wrapping them in &lt;!-- --&gt;</li>
<li>it works well with Git, so keeping backups is straightforward. Just commit the changes and then push them to your repository.</li>
<li>there is no lock-in. If you decide that Markdown isn't for you, then just output to Word, or whatever, and continue working in the new format.</li>
</ul>
<p>Are there any reasons not to use Markdown?</p>
<p>There are some minor annoyances:</p>
<ul>
<li>if you haven't worked with Markdown before then you'll find yourself referring to the style-guide fairly often at first.</li>
<li>it isn't possible to add a short caption to tables <del>and figures</del> (<a href="https://github.com/tompollard/phd_thesis_markdown/pull/47">figures are now fixed</a>). This means that /listoftables includes the long-caption, which probably isn't what you want. If you want to include the list of tables, then you'll need to write it manually.</li>
<li>the style documents in this framework could be improved. The PDF and HTML outputs are acceptable, but <del>HTML and</del> Word needs work if you plan to output to this format.</li>
<li>... if there are more, please add them here.</li>
</ul>
<p>How is the template organised?</p>
<ul>
<li>README.md =&gt; these instructions.</li>
<li>License.md =&gt; terms of reuse (MIT license).</li>
<li>Makefile =&gt; contains instructions for using Pandoc to produce the final thesis.</li>
<li>output/ =&gt; directory to hold the final version.</li>
<li>source/ =&gt; directory to hold the thesis content. Includes the references.bib file.</li>
<li>source/figures/ =&gt; directory to hold the figures.</li>
<li>style/ =&gt; directory to hold the style documents.</li>
</ul>
<p>How do I get started?</p>
<ol style="list-style-type: decimal">
<li>Install the following software:
<ul>
<li>A text editor, like Sublime, which is what you'll use write the thesis.</li>
<li>A LaTex distribution.</li>
<li>Pandoc, for converting the Markdown to the output format of your choice. You may also need to install <a href="http://pandoc.org/demo/example19/Extension-citations.html">Pandoc cite-proc</a> to create the bibliography.</li>
<li>Install shortcaption module for Pandoc, with <code>pip install pandoc-shortcaption</code></li>
<li>Git, for version control.</li>
</ul></li>
<li>https://github.com/tompollard/phd_thesis_markdown/fork<br />
</li>
<li>Clone the repository onto your local computer (or <a href="https://github.com/tompollard/phd_thesis_markdown/archive/master.zip">download the Zip file</a>).<br />
</li>
<li><p>Navigate to the directory that contains the Makefile and type &quot;make pdf&quot; (or &quot;make html&quot;) at the command line to update the PDF (or HTML) in the output directory.<br />
<strong>In case of an error</strong> (e.g. <code>make: *** [pdf] Error 43</code>) run the following commands:</p>
<pre><code>sudo tlmgr install truncate
sudo tlmgr install tocloft
sudo tlmgr install wallpaper
sudo tlmgr install morefloats
sudo tlmgr install sectsty
sudo tlmgr install siunitx
sudo tlmgr install threeparttable
sudo tlmgr update l3packages
sudo tlmgr update l3kernel
sudo tlmgr update l3experimental</code></pre></li>
<li><p>Edit the files in the 'source' directory, then goto step 4.</p></li>
</ol>
<p>What else do I need to know?</p>
<p>Some useful points, in a random order:</p>
<ul>
<li>each chapter must finish with at least one blank line, otherwise the header of the following chapter may not be picked up.</li>
<li>add two spaces at the end of a line to force a line break.</li>
<li>the template uses <a href="http://johnmacfarlane.net/pandoc/README.html">John Macfarlane's Pandoc</a> to generate the output documents. Refer to this page for Markdown formatting guidelines.</li>
<li>PDFs are generated using the Latex templates in the style directory. Fonts etc can be changed in the tex templates.</li>
<li>To change the citation style, just overwrite ref_format.csl with the new style. Style files can be obtained from <a href="http://citationstyles.org/">citationstyles.org/</a></li>
<li>For fellow web developers, there is a Grunt task file (Gruntfile.js) which can be used to 'watch' the markdown files. By running <code>$ npm install</code> and then <code>$ npm run watch</code> the PDF and HTML export is done automatically when saving a Markdown file.</li>
<li>You can automatically reload the HTML page on your browser using LiveReload with the command <code>$ npm run livereload</code>. The HTML page will automatically reload when saving a Markdown file after the export is done.</li>
</ul>
<p>Contributing</p>
<p>Contributions to the template are encouraged! There are lots of things that could improved, like:</p>
<ul>
<li>finding a way to add short captions for the tables, so that the lists of tables can be automatically generated.</li>
<li>cleaning up the Latex templates, which are messy at the moment.</li>
<li>improving the style of Word and Tex outputs.</li>
</ul>
<p>Please fork and edit the project, then send a pull request.</p>
<h1 id="appendix-5-initial-project-specification-and-plan" class="unnumbered">Appendix 5: Initial project specification and plan</h1>
<p>During the development of the project initial specification and plan was completely reworked. Thus, following information is deprecated or out of date.</p>
<h2 id="functional-requirements-1" class="unnumbered">Functional requirements</h2>
<p>To create new back end for Frankjnr:</p>
<ul>
<li><p>To create Abstract Machine which supports newest Frankjnr implementation, representing the state of Frank execution process; Compiler which works with implemented Abstract Machine and compiles Frank code to working JavaScript which can run in the browser;</p></li>
<li><p>To facilitate client-side communication of events and DOM updates between Frank code and the browser;</p></li>
</ul>
<h2 id="non-functional-requirements-1" class="unnumbered">Non-functional requirements</h2>
<ul>
<li><p>To create tests which should always pass, in order to test new releases of the system;</p></li>
<li><p>To measure performance (in comparison with the existing back-end and with other kinds of generated JS);</p></li>
<li><p>Easier client-side programming (example, complex parser of a text field);</p></li>
</ul>
<h2 id="technologies" class="unnumbered">Technologies</h2>
<p>Haskell - main functional programming language to be used;</p>
<p>JavaScript - main client-side language to be used;</p>
<p>Frank - built on Haskell, targeted language by the compiler;<br />
https://github.com/cmcl/frankjnr</p>
<p>Stack - Dependency manager and build tool for Frank;<br />
https://github.com/commercialhaskell/stack</p>
<p>Vole - Compiles functional language to JavaScript;<br />
https://github.com/pigworker/Vole</p>
<p>Shonky - Current Frankjnr compiler;<br />
https://github.com/pigworker/shonky</p>
<p>GHC - Haskell compiler;<br />
https://github.com/ghc/ghc</p>
<h2 id="software-development-process" class="unnumbered">Software development process</h2>
<ul>
<li>Gathering requirements and working on project specification (week 1);</li>
<li>Learning, researching Frank and any other related technologies (week 2);</li>
<li>Understanding the implementation to reach the end goal (week 2-4);</li>
<li>Updating project specification, plan if necessary (week 4);</li>
<li>Working on project architecture, to be able to meet all the requirements (week 5);</li>
<li>Working on the implementation (week 5 - 11);</li>
<li>Testing (week 11);</li>
<li>Project evaluation (week 12);</li>
<li>Final report and presentation (week 12);</li>
<li>Maintenance, if necessary (week 12+);</li>
</ul>
<p>During every stage of the software development process I will update my progress log, which then I’ll include in the final report. Also, I’ll try to implement some tests during the software implementation stage. And, finally, all code will be stored in a github repository, where it will be well documented and publicly available.</p>
<h2 id="project-evaluation" class="unnumbered">Project evaluation</h2>
<p>Project will be evaluated by other researchers who have a clear view of how the software should function. They will test the system and give their feedback and assessment. Evaluators will expect that the existing body of Frank examples should work in my implementation of the system the same way they do in other implementations, as well as client-side programming should become easier, example, writing parsers for data in web forms. Furthermore, project will use continuous evaluation technique, so it will be evaluated, for example, every two weeks by at least one researcher, in order to follow Agile software development practices.</p>
<h2 id="risks" class="unnumbered">Risks</h2>
<ul>
<li>Dependence on Frank implementation (Frankjnr);</li>
<li>Estimating and scheduling development time. As I have never worked on any similar project before, correctly estimating and scheduling time might be difficult;</li>
<li>Planning before fully understanding the implementation process. For example, there might be conflict requirements or just in general incomplete specification as I don’t yet have full understanding of technologies I’m going to use.</li>
</ul>

<!-- 
Do not edit this page.

References are automatically generated from the BibTex file (References.bib)

...which you should create using your reference manager.
-->
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Plotkin5">
<p>B. C. Pierce and D. N. Turner, 2000. <em>Local type inference</em>,</p>
</div>
<div id="ref-Chunks1">
<p>Daniel Hillerström and Sam Lindley, 2016. <em>Proceedings of the 1st International Workshop on Type-Driven Development</em>,</p>
</div>
<div id="ref-MathsProgContruction">
<p>Dexter Kozen and Carron Shankland, 2004. <em>Mathematics of Program Construction</em>,</p>
</div>
<div id="ref-Match-bust">
<p>F.V. McBride, 1970. <em>Computer Aided Manipulation of Symbols</em>,</p>
</div>
<div id="ref-Plotkin7">
<p>G. D. Plotkin and J. Power, 2001a. <em>Adequacy for algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin2">
<p>G. D. Plotkin and J. Power, 2003. <em>Algebraic operations and generic effects</em>,</p>
</div>
<div id="ref-Plotkin3">
<p>G. D. Plotkin and J. Power, 2009. <em>Handlers of algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin">
<p>G. D. Plotkin and J. Power, 2002. <em>Notions of computation determine monads</em>,</p>
</div>
<div id="ref-Plotkin6">
<p>G. D. Plotkin and J. Power, 2001b. <em>Semantics for algebraic operations</em>,</p>
</div>
<div id="ref-Plotkin4">
<p>G. D. Plotkin and M. Pretnar, 2013. <em>Handling algebraic effects</em>,</p>
</div>
<div id="ref-CompilingCorrectly">
<p>Graham Hutton and Joel J. Wright, 2004. <em>Compiling Exceptions Correctly</em>,</p>
</div>
<div id="ref-Tree-switching">
<p>Lennart Augustsson, 1985. <em>Functional Programming and Computer Architecture</em>,</p>
</div>
<div id="ref-FrankPaper">
<p>Sam Lindley, Conor McBride &amp; Craig McLaughlin, 2016. <em>Do be do be do</em>,</p>
</div>
<div id="ref-LambdaLifting">
<p>Thomas Jonson, 1985. <em>Springer LNCS 201</em>,</p>
</div>
</div>
            </body>
</html>

