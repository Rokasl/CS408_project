<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <title></title>
        <style type="text/css">code{white-space: pre;}</style>
                            <style type="text/css">
            div.sourceCode { overflow-x: auto; }
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
              margin: 0; padding: 0; vertical-align: baseline; border: none; }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code > span.dt { color: #902000; } /* DataType */
            code > span.dv { color: #40a070; } /* DecVal */
            code > span.bn { color: #40a070; } /* BaseN */
            code > span.fl { color: #40a070; } /* Float */
            code > span.ch { color: #4070a0; } /* Char */
            code > span.st { color: #4070a0; } /* String */
            code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code > span.ot { color: #007020; } /* Other */
            code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code > span.fu { color: #06287e; } /* Function */
            code > span.er { color: #ff0000; font-weight: bold; } /* Error */
            code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            code > span.cn { color: #880000; } /* Constant */
            code > span.sc { color: #4070a0; } /* SpecialChar */
            code > span.vs { color: #4070a0; } /* VerbatimString */
            code > span.ss { color: #bb6688; } /* SpecialString */
            code > span.im { } /* Import */
            code > span.va { color: #19177c; } /* Variable */
            code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code > span.op { color: #666666; } /* Operator */
            code > span.bu { } /* BuiltIn */
            code > span.ex { } /* Extension */
            code > span.pp { color: #bc7a00; } /* Preprocessor */
            code > span.at { color: #7d9029; } /* Attribute */
            code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            </style>
                                            <style>
            body {
                font-family: Georgia;
                max-width: 800px;
                margin: 0 auto;
                line-height: 30px;
                font-size: 18px;
                padding-left: 350px;
                padding-right: 50px;
                color: #111;
            }
            
            h1, h2, h3, h4, h5, h6 {
                font-family: Arial;
            }
            
            h1 {
                padding-top: 200px;
                line-height: 50px;
            }
            h2 {
                padding-top: 30px;
            }
            h3 {
                padding-top: 20px;
            }
            h4 {
                padding-top: 10px;
            }
            p {
                text-align: justify;
            }
            p a {
                word-wrap: break-word;
                white-space: pre;
            }
            code {
                word-wrap: break-word;
            }
            blockquote {
                border-left: 3px solid #eee;
                margin-left: 20px;
                padding-left: 20px;
            }
            
            ::selection {
                background-color: #E4E4E4;
            }
            
            table {
                width: 100%;
            }
            table caption {
                font-weight: bold;
            }
            table tr {
                padding: 0;
                margin: 0;
                background-color: #f0f0f0;
            }
            table tr.even {
                background-color: #fafafa;
            }
            table td {
                margin: 0;
                padding: 3px 5px;
            }
            
            p span.added {
                color: green;
                background-color: #FFF3C5;
            }
            p span.removed {
                color: red;
                background-color: #FFF3C5;
            }
            
            #title-page {
                padding: 80px 0;
            }
            
            #TOC {
                position: fixed;
                left: 0;
                top: 0;
                overflow-y: scroll;
                height: 100%;
                background: #fafafa;
                max-width: 300px;
                font-family: Arial;
                font-size: 15px;
                line-height: 30px;
            }
            ::-webkit-scrollbar {
                width: 8px;
            }
            ::-webkit-scrollbar-track {
                background-color: #ECECEC;
            }
            ::-webkit-scrollbar-thumb {
                background-color: #B0B0B0;
                border-radius: 8px;
            }
            #TOC > ul {
                padding-right: 10px;
            }
            #TOC ul {
                list-style: none;
                padding-left: 20px;
            }
            #TOC ul li a {
                text-decoration: none;
                color: #364149;
                text-overflow: ellipsis;
                display: block;
                white-space: nowrap;
                overflow: hidden;
            }
            #TOC ul li a:hover {
                color: #008cff;
            }
            
            .figure {
                text-align: center;
            }
            .figure p {
                text-align: center;
                font-style: italic;
            }
            .figure img {
                  width: 100%;
            }
            </style>
                <script src="js/jquery.js"></script>
        <script src="js/diff.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
                <!--
                -->
        <div id="title-page">
            <h1>This is the title of the thesis</h1>
            <h2>Firstname Surname</h2>
        </div>
                    <div id="TOC">
                <ul>
                <li><a href="#abstract">Abstract</a></li>
                <li><a href="#acknowledgements">Acknowledgements</a></li>
                <li><a href="#list-of-figures">List of figures</a></li>
                <li><a href="#list-of-tables">List of tables</a></li>
                <li><a href="#abbreviations">Abbreviations</a></li>
                <li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
                <li><a href="#background"><span class="toc-section-number">1.1</span> Background</a></li>
                <li><a href="#objectives"><span class="toc-section-number">1.2</span> Objectives</a></li>
                <li><a href="#project-outcome"><span class="toc-section-number">1.3</span> Project Outcome</a></li>
                <li><a href="#summary-of-chapters"><span class="toc-section-number">1.4</span> Summary of chapters</a></li>
                </ul></li>
                <li><a href="#related-work"><span class="toc-section-number">2</span> Related Work</a><ul>
                <li><a href="#vole"><span class="toc-section-number">2.1</span> Vole</a></li>
                <li><a href="#shonky"><span class="toc-section-number">2.2</span> Shonky</a></li>
                <li><a href="#frankjnr"><span class="toc-section-number">2.3</span> Frankjnr</a><ul>
                <li><a href="#frankjnr-limitations"><span class="toc-section-number">2.3.1</span> Frankjnr limitations</a></li>
                </ul></li>
                <li><a href="#ocaml"><span class="toc-section-number">2.4</span> Ocaml</a></li>
                <li><a href="#haste"><span class="toc-section-number">2.5</span> Haste</a></li>
                <li><a href="#conclusion"><span class="toc-section-number">2.6</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#problem-description-and-specification"><span class="toc-section-number">3</span> Problem Description and Specification</a><ul>
                <li><a href="#problem-overview"><span class="toc-section-number">3.1</span> Problem overview</a><ul>
                <li><a href="#project-risks"><span class="toc-section-number">3.1.1</span> Project risks</a></li>
                </ul></li>
                <li><a href="#requirements-analysis"><span class="toc-section-number">3.2</span> Requirements Analysis</a><ul>
                <li><a href="#development-tools-and-languages"><span class="toc-section-number">3.2.1</span> Development Tools and Languages</a></li>
                <li><a href="#vagrant"><span class="toc-section-number">3.2.2</span> Vagrant</a></li>
                <li><a href="#webpack"><span class="toc-section-number">3.2.3</span> Webpack</a></li>
                <li><a href="#javascript"><span class="toc-section-number">3.2.4</span> JavaScript</a></li>
                <li><a href="#haskell"><span class="toc-section-number">3.2.5</span> Haskell</a></li>
                <li><a href="#report-markdown"><span class="toc-section-number">3.2.6</span> Report Markdown</a></li>
                </ul></li>
                <li><a href="#specification"><span class="toc-section-number">3.3</span> Specification</a><ul>
                <li><a href="#functional-requirements"><span class="toc-section-number">3.3.1</span> Functional requirements</a></li>
                <li><a href="#non-functional-requirements"><span class="toc-section-number">3.3.2</span> Non-functional requirements</a></li>
                <li><a href="#use-cases"><span class="toc-section-number">3.3.3</span> Use Cases</a></li>
                </ul></li>
                <li><a href="#design-methodology"><span class="toc-section-number">3.4</span> Design Methodology</a></li>
                </ul></li>
                <li><a href="#initial-development-experimental-system"><span class="toc-section-number">4</span> Initial development &amp; experimental system</a><ul>
                <li><a href="#introduction-1"><span class="toc-section-number">4.1</span> Introduction</a></li>
                <li><a href="#simple-system"><span class="toc-section-number">4.2</span> Simple system</a><ul>
                <li><a href="#language"><span class="toc-section-number">4.2.1</span> Language</a></li>
                <li><a href="#compiler"><span class="toc-section-number">4.2.2</span> Compiler</a></li>
                <li><a href="#abstract-machine"><span class="toc-section-number">4.2.3</span> Abstract machine</a></li>
                <li><a href="#testing-framework"><span class="toc-section-number">4.2.4</span> Testing framework</a></li>
                </ul></li>
                <li><a href="#conclusion-1"><span class="toc-section-number">4.3</span> Conclusion</a></li>
                </ul></li>
                <li><a href="#detailed-design-and-implementation-of-the-final-system"><span class="toc-section-number">5</span> Detailed Design and Implementation of the final system</a><ul>
                <li><a href="#introduction-2"><span class="toc-section-number">5.1</span> Introduction</a></li>
                <li><a href="#project-folder-structure"><span class="toc-section-number">5.2</span> Project folder structure</a></li>
                <li><a href="#abstract-machine-1"><span class="toc-section-number">5.3</span> Abstract machine</a></li>
                <li><a href="#compiler-1"><span class="toc-section-number">5.4</span> Compiler</a></li>
                <li><a href="#testing-framework-1"><span class="toc-section-number">5.5</span> Testing framework</a></li>
                <li><a href="#possible-improvements"><span class="toc-section-number">5.6</span> Possible improvements</a></li>
                </ul></li>
                <li><a href="#results-and-evaluation"><span class="toc-section-number">6</span> Results and Evaluation</a></li>
                <li><a href="#summary-conclusion"><span class="toc-section-number">7</span> Summary &amp; Conclusion</a><ul>
                <li><a href="#summary"><span class="toc-section-number">7.1</span> Summary</a></li>
                <li><a href="#future-work"><span class="toc-section-number">7.2</span> Future work</a></li>
                </ul></li>
                <li><a href="#appendix-1-progress-log">Appendix 1: Progress log</a></li>
                <li><a href="#appendix-2-some-more-extra-stuff">Appendix 2: Some more extra stuff</a></li>
                <li><a href="#references">References</a></li>
                </ul>
            </div>
                                
<h1 id="abstract" class="unnumbered">Abstract</h1>
<!-- This is the abstract -->
<p>Frank is strongly typed, strict functional programming language invented by Sam Lindley and Conor McBride and it is influenced by Paul Blain Levy’s call-by-push-value calculus. Featuring a bidirectional effect type system, effect polymorphism, and effect handlers. This means that Frank supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when command is complete depending on the handler the system could resume from the point it was suspended. Handlers are very similar to typical functions but their argument processes can communicate in more advanced ways. So the idea is to utilize this functionality in the web. Side-effects might be various events such as mouse actions, http requests etc. and the handler would be the application in the web page.</p>
<p>The main top-level goal of the project is to compile Frank to JavaScript and run it in the browser. Thus, users would be able to use Frank for web development purposes. This involves creating a Compiler and Virtual Machine (abstract machine) which can support compiled Frank structure.</p>
<p> </p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<!-- This is for acknowledging all of the people who helped out -->
<p>I would like to express my special thanks of gratitude to my supervisor, Conor Mcbride for his guidance, support and patients throughout this project.</p>
<p>Also, I would like to thank my friends for helping me think with our numerous technical discussions and contemplations.</p>
<!-- Use the \newpage command to force a new page -->




<h1 id="list-of-figures" class="unnumbered">List of figures</h1>
<!--
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.


Figure 4.1  This is an example figure . . .              \hfill{pp}  
Figure x.x  Short title of the figure . . .              \hfill{pp}  
-->
<p> </p>

<h1 id="list-of-tables" class="unnumbered">List of tables</h1>
<!-- 
For me, this was the only drawback of writing in Markdown: it is not possible to add a short caption to figures and tables. This means that the \listoftables and \listoffigures commands will generate lists using the full titles, which is probably isn't what you want. For now, the solution is to create the lists manually, when everything else is finished.
-->
<p>Table 5.1 This is an example table . . . <br />
Table x.x Short title of the figure . . . </p>
<h1 id="abbreviations" class="unnumbered">Abbreviations</h1>


<p> </p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This chapter focuses on explaining the project motivation, objectives and outcome. Also, in the last section report structure is displayed.</p>
<h2 id="background"><span class="header-section-number">1.1</span> Background</h2>
<!--In current modern times web development is one of the most important and successful spheres of engineering,
because the accessibility to the Internet is periodically increasing and its undeniable benefits to both the
consumer and the supplier. -->
<p>Functional languages are evolving, they are constantly changing to innovate and adapt to ever changing needs of software engineering. Thus, concept of Frank language was created by Prof. Conor McBride and Prof. Sam Lindley followed by its implementation called Frank and more recently newer release - Frankjnr.</p>
<p>Frank is strongly typed, strict functional programming language designed around Plotkin and Pretnar’s effect handler abstraction, strongly influenced by <span class="citation">(B. C. Pierce and D. N. Turner 2000)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001b)</span>, <span class="citation">(G. D. Plotkin and J. Power 2001a)</span>, <span class="citation">(G. D. Plotkin and J. Power 2002)</span>, <span class="citation">(G. D. Plotkin and J. Power 2003)</span>, <span class="citation">(G. D. Plotkin and J. Power 2009)</span>, <span class="citation">(G. D. Plotkin and M. Pretnar 2013)</span> papers on algebraic effects and handlers for algebraic effects. It is, also, influenced by Paul Blain Levy’s call-by-push-value calculus. Frank features a bidirectional effect type system, effect polymorphism, and effect handlers. This means that Frank supports type-checked side-effects which only occur where permitted. Side-effects are comparable to exceptions which suspend the evaluation of the expression where they occur and give control to a handler which interprets the command. However, when command is complete depending on the handler the system could resume from the point it was suspended. Handlers are very similar to typical functions but their argument processes can communicate in more advanced ways.</p>
<p>Because of the district features of Frank, in particular its capability to support effects and handlers, it has potential to be used in web development context. However, neither of Frank implementations currently support this. Thus this projects motivation is to be able to use Frank for web development. Using functional language for web development could greatly ease the process of writing parsers and form validations in the web. Furthermore, Frank code would be essentially converted into JavaScript because of its support for functional programming. This means Frank would potentially gain all the JavaScript functionality and could even use JavaScript libraries. For example, Frank would be able to handle different http requests, such as GET or POST, Frank could fire events (ex. alert boxes) or handle events (ex. mouse clicks).</p>
<p>The most convenient way to achieve this is to utilize existing Frankjnr implementation, rewriting its Compiler and Abstract Machine. Compiler would take in parsed Frank code and output JavaScript which could be used by Abstract Machine at Run-time.</p>
<p>This projects requires knowledge how Compilers and Abstract Machines work and how to use them together them. Author chose this project while knowing that it would be extremely challenging but most effective learning experience.</p>
<h2 id="objectives"><span class="header-section-number">1.2</span> Objectives</h2>
<ul>
<li>Utilize Frankjnr implementation of Frank and Shonky language;</li>
<li>Utilize Shonky syntax and data structures;</li>
<li>Develop Code Compiler which compiles Shonky's code to JavaScript program;</li>
<li>Develop Abstract Machine implementation which supports the output of the Compiler;</li>
<li>Completed system must facilitate client-side communication of events and DOM updates between Frank code and the browser;</li>
</ul>
<h2 id="project-outcome"><span class="header-section-number">1.3</span> Project Outcome</h2>
<p>During initial development stages experimental system was developed with its own language, compiler, virtual machine and testing framework in order to expand authors insight of the subject. Lessons learned and code style with few functions of experimental system were adapted in creation of the final system. Because of it, Author was successful in implementing new Abstract Machine and Compiler for Frankjnr. They were, also, successfully integrated into Frankjnr project. However, newly developed components are very much in prototype stage as they don't yet have full support of all Frank's features. Moreover, the project can still improve on variaty of things, such as performance, building procedures and testing.</p>
<h2 id="summary-of-chapters"><span class="header-section-number">1.4</span> Summary of chapters</h2>
<p><strong>Chapter 2 - Related Work</strong></p>
<p>The point of the chapter is to highlight work done by others that somehow ties in with this project. It may be work that author is basing his work of, work that shows others attempts to solve similar problems or connected projects which were partially used in the final implementation of the project.</p>
<p><strong>Chapter 3 - Problem Description and Specification</strong></p>
<p>This chapter briefly overviews the main problems and challenges of the project. It briefly explains requirement analysis stage and development tools, languages chosen. It, also, expands upon functional and non-functional requirements, followed by detailed specification and explanation of design methodology.</p>
<p><strong>Chapter 4 - Initial development &amp; experimental system</strong></p>
<p>This chapter is focused on initial experimental system. It highlights the reasoning behind it, purpose of each component, their implementation, drawbacks and any possible improvements.</p>
<p><strong>Chapter 5 - Detailed Design and Implementation of the final system</strong></p>
<p>Chapter reflects upon implementation and design of the final compiler and abstract machine. It, also, explains project structure, developed testing framework, project connections between Shonky and Frankjnr as well as possible improvements and considered alternative approaches.</p>
<p><strong>Chapter 6 - Verification and Validation</strong></p>
<p>This chapter explains how the outcome of the project was validated and what testing procedures were followed during and after the project.</p>
<p><strong>Chapter 7 - Results and Evaluation</strong></p>
<p>Main idea of the chapter is to highlight summarized outcome of the project, how it was evaluated and explain relevant future work.</p>
<h1 id="related-work"><span class="header-section-number">2</span> Related Work</h1>
<!-- Literature review ??? -->
<h2 id="vole"><span class="header-section-number">2.1</span> Vole</h2>
<p>Vole is lightweight functional programming language with its own Compiler and two Abstract Machines. One Machine is written in Haskell and provides opportunity to run compiled Vole programs on the local machine. Other Virtual Machine is written in JavaScript, because of this it is possible to run Vole programs on the web, there are few working examples in the Git repository of Vole. It, also, has some support for effects and handlers, so it utilizes the ability to communicate between compiled Vole programs and application front-end on run-time.</p>
<p>In the context of this project - Vole is extremely useful resource, because Vole essentially tries to solve the same problem but for a different language. Author had to study Vole, to understand its technical implementation, usage of resources and to expand his knowledge of Compilers and Abstract Machines. Lastly, Vole is used for evaluation purposes as another benchmark comparison.</p>
<h2 id="shonky"><span class="header-section-number">2.2</span> Shonky</h2>
<p>Shonky is untyped and impure functional programming language. The key feature of Shonky is that it supports local handling of computational effect, using the regular application syntax. This means one process can coroutine many other subprocesses. In that sense it is very similar to Frank, just without type support. Its interpreter is written in Haskell, although it has potential to be ported to JavaScript or PHP to support web operations.</p>
<p>In the context of the project Shonky language data structures are used by the Abstract Machine, in Chapter 5 it is explained in great detail of how exactly were they used and for what purpose. However, Shonky interpreter is completely scrapped and is only used as a reference in solving any Abstract Machine or Compiler difficulties.</p>
<h2 id="frankjnr"><span class="header-section-number">2.3</span> Frankjnr</h2>
<p>Frankjnr is an newest implementation of Frank functional programming language described in &quot;<em>Do be do be do</em>&quot; <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span> paper. Frankjnr has a parser for Frank syntax, thus the user is able to use Frank to write expressions. After parsing Frank code it performs type check and other necessary operations followed by compilation to Shonky supported data structures which are then used by Shonky interpreter to run Frank.</p>
<h3 id="frankjnr-limitations"><span class="header-section-number">2.3.1</span> Frankjnr limitations</h3>
<ul>
<li>Only top-level mutually recursive computation bindings are supported;</li>
<li>Coverage checking is not implemented;</li>
</ul>
<h2 id="ocaml"><span class="header-section-number">2.4</span> Ocaml</h2>
<h2 id="haste"><span class="header-section-number">2.5</span> Haste</h2>
<!--http://haste-lang.org/ -->
<p>Haste is an implementation of the Haskell functional programming language, designed for web applications and it is being used in the industry. It supports the full Haskell language, including GHC extensions because it is based on GHC compiler. Haste support modern web technologies such as WebSockets, LocalStorage, Canvas, etc. . Haste, also, has support for effects and handlers. Furthermore, Haste programs can be compiled to a single JavaScript file. Haste wasn't used as a direct resource, however it provided Author with detailed description of another solution to similar problem.</p>
<h2 id="conclusion"><span class="header-section-number">2.6</span> Conclusion</h2>
<p>Three main related projects are Vole, Shonky and Frankjnr. Vole was used as an working example of a solution for similar problem, which got author thinking of different ways to approach the problem. Shonky and Frankjnr were used directly, because Frankjnr is the newest implementation of Frank language and it uses Shonky's Abstract Machine (interpreter). So the idea was to take existing Frankjnr and replace the Shonky's interpreter with new Compiler and Abstract Machine which would support web development while keeping Shonky's syntax data structures. Other related work were used as examples of different solutions to overcome similar obstacles.</p>
<h1 id="problem-description-and-specification"><span class="header-section-number">3</span> Problem Description and Specification</h1>
<p>This section discusses the project problem, challenges, requirements and involved risks.</p>
<h2 id="problem-overview"><span class="header-section-number">3.1</span> Problem overview</h2>
<p>The main aim of the project was to develop new Compiler and corresponding Abstract Machine for existing functional language Frank implementation called Frankjnr. The difference from the old ones was that new Compiler and Abstract Machine would support web development. Many different challenges follow from that. First one being authors initial lack of knowledge on Frank language. Frank being full and complex language author had to study it and overcome any difficulties regarding the language by researching the paper on Frank &quot;<em>Do be do be do</em>&quot; <span class="citation">(Sam Lindley, Conor McBride &amp; Craig McLaughlin 2016)</span>.</p>
<p>A second challenge was overcoming the complexity of existing systems. Because this project is not standalone, it strictly depends on the Shonky Syntax implementation as well as Frankjnr handling Frank's code. Author had to take time and carefully research existing systems, to understand how everything fits together and how efficiently replace exiting Shonky interpreter with new Compiler and Abstract Machine.</p>
<p>Another challenge was the difficult nature of compilers and abstract machines. This was the most difficult challenge to overcome due to the depth and the amount of detail each of them have. Thus, the incremental approach was adapted, in order to for the author to learn step by step, starting with simpler things. Author started the project by developing experimental system with its own language,compiler and virtual machine to understand the crucial concepts of compiler and abstract machines.</p>
<p>Fourth challenge was testing and validation. Because the project is focused on developing completely new system without any usage of frameworks, testing framework had to be developed which could run test cases and check their correctness without any interaction of the user. Testing framework was developed by utilizing Bash Script, Expect Script languages and Node, Webpack, Ghci commands. It was firstly, created for experimental system and then based on observation and testing, altered and improved for the final system. In the end, it dramatically improved development time by constantly locating bugs and validating the correctness of the outputs.</p>
<p>The project was extremely broad and involved great deal of initial research as well as constant analysis of next steps, thus development was slow but effective. However, due to time constrains development time had to be planned very carefully, because of this some acknowledged directions of development had to be ignored to finish the prototype in time. For example, one of those directions was Haskell enforced type checker. Haskell compiler could have had a type checker which would prevent any bugs regarding generated JavaScript programs by enforcing its types. Now such bugs are spotted by the console window of the browser or testing framework.</p>
<h3 id="project-risks"><span class="header-section-number">3.1.1</span> Project risks</h3>
<ul>
<li>Dependence on Frank implementation (Frankjnr). Instances of Frank code will be tested to make sure it behaves as expected;</li>
<li>Estimating and scheduling development time. Due to authors inexperience with the subject of the project, correctly estimating and scheduling time is difficult. However, meetings with supervisor are organized regularly, to make sure the project is on track;</li>
<li>Lack of resources, supervisor Conor McBride is the only resource of relevant and accurate information;</li>
<li>Authors lack of experience with languages being used and overall analyzed concepts (compiler and virtual machines).</li>
</ul>
<h2 id="requirements-analysis"><span class="header-section-number">3.2</span> Requirements Analysis</h2>
<p>Before any development could begin requirements needed to be gathered, author did this by discussing how the system should behave and what technologies it should utilize with the supervisor. He, also, attended programming languages seminar where Frank language was discussed, gaining different perspective on the whole project. Lastly, author read papers on relevant topics, such as &quot;Compiling Exceptions Correctly&quot; <span class="citation">(Graham Hutton and Joel Wrigh 2004)</span>,to expand his knowledge and gain more insight in what to do. Further research was made to ensure the appropriateness of chosen languages and technologies.</p>
<h3 id="development-tools-and-languages"><span class="header-section-number">3.2.1</span> Development Tools and Languages</h3>
<p>This section will briefly explain used tools and languages and reasoning behind each of them.</p>
<h3 id="vagrant"><span class="header-section-number">3.2.2</span> Vagrant</h3>
<!--https://www.vagrantup.com/-->
<p>Vagrant is an optional tool to create separate development environment for the project. It runs on Virtual Box and it is essentially a server on your local computer which you can boot up and work on. Furthermore, Vagrant comes with up to date relevant libraries out of the box. Author used it to avoid installing software and managing libraries on local machine, thus speeding up development.</p>
<h3 id="webpack"><span class="header-section-number">3.2.3</span> Webpack</h3>
<!--https://webpack.github.io/-->
<p>Webpack is a module builder and it is available as npm package. In this project it is used for Abstract Machine development as it adds some wanted features to plain JavaScript, and in the end everything is compiled to a single light JavaScript file. The most important is an ability to create and export different modules, for example, module could be a function or a variable. This lets for improved project structure as you are able to keep JavaScript components in separate files, thus making it easer to develop and navigate through code.</p>
<h3 id="javascript"><span class="header-section-number">3.2.4</span> JavaScript</h3>
<p>JavaScript is a client side scripting language. In this project output of the compiler is generated in JavaScript, which is then used by Virtual Machine which is, also, written in JavaScript so that both could cooperate on run time without any further compilations.</p>
<p>JavaScript is used because of its key features. Firstly, it has support for functional programming by letting function arguments be other functions. Secondly, it is supported by all popular browsers. And finally, there are lots of libraries and features to support web development.</p>
<h4 id="alternative---coffescript"><span class="header-section-number">3.2.4.1</span> Alternative - CoffeScript</h4>
<p>CoffeScript is much newer language and it improves upon JavaScript syntax, allowing for neater declarations, introduces new features and reinforces the structure of the code. CoffeScript can run in any environment where JavaScript can run, because in the end it is compiled to JavaScript. It is available as npm package. However, it wasn't used because author didn't want another layer of compilation going on in the background.</p>
<h3 id="haskell"><span class="header-section-number">3.2.5</span> Haskell</h3>
<!--https://wiki.haskell.org
https://www.haskell.org/-->
<p>Haskell is a statically, implicitly typed, lazy, standardized functional programming language with non-strict semantics. Haskell features include support for recursive functions, data types, pattern matching, and list comprehensions.</p>
<p>Haskell was a clear choice for compiler development because of its functional language features, like pattern-matching, efficient recursion, support for monadic structures. Moreover, Frankjnr and Shonky are written in Haskell, so it was easy to cooperate with those projects.</p>
<h3 id="report-markdown"><span class="header-section-number">3.2.6</span> Report Markdown</h3>
<!--https://github.com/tompollard/phd_thesis_markdown-->
<!--http://pandoc.org/-->
<p>This report adapted the template of markdown developed by Tom Pollard, because of its flexible structure and features, such as support for Pandoc markdown and latex expressions. Everything is compiled to a single PDF by utilizing npm.</p>
<h2 id="specification"><span class="header-section-number">3.3</span> Specification</h2>
<h3 id="functional-requirements"><span class="header-section-number">3.3.1</span> Functional requirements</h3>
<ul>
<li>To create new back end for Frankjnr implementation:
<ul>
<li>Develop Compiler which uses Shonky's language (Syntax file) and outputs a sensible and correct JavaScript code structure;</li>
<li>Develop Abstract Machine which can run previously compiled JavaScript code in the browser;</li>
</ul></li>
<li>To facilitate client-side communication of events and DOM updates between Frank code and the browser;</li>
</ul>
<h3 id="non-functional-requirements"><span class="header-section-number">3.3.2</span> Non-functional requirements</h3>
<ul>
<li>To create set of tests which should always pass, before each new release of the system. Test cases should be increased after every iteration to validate new features and ensure the previous features are not broken;</li>
<li>To develop testing framework, which tests the system using the list of predetermine test cases;</li>
<li>To measure performance (in comparison with the existing back end and with other kinds of generated JavaScript);</li>
<li>Client-side programming should become possible (example, complex parser of a text field);</li>
</ul>
<h3 id="use-cases"><span class="header-section-number">3.3.3</span> Use Cases</h3>
<p>Use cases are not really relevant to this project, since the developed compiler and abstract machine support full Frank language, which potentially can be used in infinite number of ways. But generally, the user puts sensible Frank code into a Frank file then initiate compilation by using project's compiler, the compiler will generate a JavaScript file which user can include in their web project. Furthermore, user needs to include the machine, which utilizes previously compiled code, into their project. For mode detailed information on how to use the system, check usage instruction in the Appendix ???.</p>
<h2 id="design-methodology"><span class="header-section-number">3.4</span> Design Methodology</h2>
<p>The implementation of the project is fully focused on back end development. The adopted design methodology was iterative and incremental development (IID). The main reasons behind it were the difficult nature of the project and author's initial lack of knowledge on the subject; this methodology allows the developer to focus on few features at a time building the system incrementally, thus making it easier to learn as you go.</p>
<p>Iterative and incremental development (IID) is a process which grows the system incrementally, feature by feature during self-contained cycles of analysis, design, implementation and testing which end when the system is finished. Meaning, the system is improved (more functionality added) through every iteration.</p>
<p>The core benefits of this methodology are:</p>
<ul>
<li>Regression testing is conducted after each iteration, where only few changes are made through single iteration, because of this faulty elements of the software are easily identified and fixed before starting the next iteration;</li>
<li>Testing of systems features is a bit easier, because this methodology allows for targeted testing of each element within the system;</li>
<li>System could easily shift directions of development after each iteration;</li>
<li>Learning curve is much flatter than usual, because developer is focusing on few features at a given time.</li>
</ul>
<p>Another big decision was to start with simpler system, an experimental throughout which the author could learn the basics and adapt gained knowledge in the development of the final system. The experiment took about four weeks and used the same methodology - iterative and incremental development.</p>
<h1 id="initial-development-experimental-system"><span class="header-section-number">4</span> Initial development &amp; experimental system</h1>
<h2 id="introduction-1"><span class="header-section-number">4.1</span> Introduction</h2>
<p>Because of the complexity of overall project and the lack of initial author knowledge in the field the most optimal plan was to start with something small and expand gradually. The intricacies consist of:</p>
<ul>
<li>Frank is a complex functional language;</li>
<li>Frankjnr adds another layer of complexity, since author needs to be aware of the implementation and compilation process;</li>
<li>Dependence on Shonky's language, because the final implementation of the Compiler must be able to understand and compile Shonky language;</li>
<li>Complexity of the Compilers and their implementation;</li>
<li>Complexity of Abstract Machines and their implementation;</li>
</ul>
<p>Thus, simpler language was developed with matching Compiler and Abstract Machine. Both, the Compiler and the Machine were developed while keeping in mind that their key parts will be used for the final product. So efficiency, reliability, structure were all key factors.</p>
<h2 id="simple-system"><span class="header-section-number">4.2</span> Simple system</h2>
<p>It consists of:</p>
<ul>
<li>Compiler - written in Haskell;</li>
<li>Language - written in Haskell;</li>
<li>Machine - written in JavaScript;</li>
<li>Testing Framework - written in Bash and Expect scripts;</li>
</ul>
<h3 id="language"><span class="header-section-number">4.2.1</span> Language</h3>
<p>A simple language written in Haskell, which syntax supports few specific operations, such as, sum of two expressions, Throw &amp; Catch, Set, Next, Get, new reference.</p>
<p><strong>Full language definition</strong></p>
<p>This section will focus on the exact definition of the language. Language is defined as Haskell data type. In this case it supports only different types of expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> </code></pre></div>
<p>Experimental language is focused on Integer manipulation, thus it only supports integer values. Here is a definition of a Integer value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Val</span> <span class="dt">Int</span></code></pre></div>
<p>Definition of sum of two expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:+:</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of a Throw and Catch commands. If the first expression of Catch is equal to Throw, meaning something went wrong then the second expression will be evaluated.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Throw</span>
        <span class="fu">|</span> <span class="dt">Catch</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of WithRef command. It creates new reference with a given value. First string variable of the command defines name of new reference. Second value is an expression which defines how to compute initial value of new reference. And the third value is the context in which the reference is valid. WithRef stack frame is the handler for &quot;Get&quot; and &quot;:=&quot; commands.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">WithRef</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Syntax definition of getting the value of a defined reference.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Get</span> <span class="dt">String</span> </code></pre></div>
<p>Syntax definition of setting defined reference value to new expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">String</span> <span class="fu">:=</span> <span class="dt">Expr</span> </code></pre></div>
<p>Syntax definition for evaluating two expressions one by one and taking value of the second. In most programming languages it is defined as &quot;;&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">        <span class="fu">|</span> <span class="dt">Expr</span> <span class="fu">:&gt;</span> <span class="dt">Expr</span></code></pre></div>
<p>Each of the operations were carefully selected, where their implementation in the Abstract Machine varies significantly. Because the implementation of these operations will be generalized in the final system, for instance, code for sum of two expressions will cope with all arithmetic calculations of two expressions.</p>
<h3 id="compiler"><span class="header-section-number">4.2.2</span> Compiler</h3>
<p>Purpose of the Compiler is to take an expression of the simple, experimental language described above and output a JavaScript working program, array of functions, which could be used by the Abstract Machine.</p>
<p>Below is a definition of code generation monad. It contains a constructor MkCodeGen and deconstructor codeGen.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">CodeGen</span> val <span class="fu">=</span> <span class="dt">MkCodeGen</span> {
<span class="ot">            codeGen ::</span> <span class="dt">Int</span> <span class="co">-- next available number (for naming helper functions)</span>
                       <span class="ot">-&gt;</span> ([(  <span class="dt">Int</span>        <span class="co">-- this number...</span>
                            ,  <span class="dt">String</span>     <span class="co">-- ...defined as this JS code</span>
                           )]
                          ,  <span class="dt">Int</span>       <span class="co">-- next available number after compilation</span>
                          ,  val       <span class="co">-- result of compilation process</span>
                          )  <span class="co">-- usually the list of definitions will start with</span>
        }                    <span class="co">-- the input &quot;next number&quot; and go up to just before</span>
                             <span class="co">-- the output &quot;next number&quot;</span></code></pre></div>
<p>MkCodeGen is used to construct a definition in genDef function displayed below. genDef returns the definition number.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genDef ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span> 
genDef code <span class="fu">=</span> <span class="dt">MkCodeGen</span> <span class="fu">$</span> \ next <span class="ot">-&gt;</span> ([(next, code)],next <span class="fu">+</span> <span class="dv">1</span>, next)</code></pre></div>
<p>genDef is used by compile function to make new function definitions. Below is the type of compile function. compile function takes in a valid language expression and outputs entry point of the compilation as well as compilation process which can be separated into chucks of JavaScript code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CodeGen</span> <span class="dt">Int</span></code></pre></div>
<p>compile function is either used to create new function definitions...</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">help s (<span class="dt">Val</span> n) <span class="fu">=</span> genDef <span class="fu">$</span>
        <span class="st">&quot;function(s){return{stack:&quot;</span><span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;, tag:\&quot;num\&quot;, data:&quot;</span><span class="fu">++</span> show n <span class="fu">++</span><span class="st">&quot;}}&quot;</span></code></pre></div>
<p>or to compile expressions to JavaScript.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">help s (e1 <span class="fu">:+:</span> e2) <span class="fu">=</span> <span class="kw">do</span> 
    f2 <span class="ot">&lt;-</span> compile e2
    help (<span class="st">&quot;{prev:&quot;</span> <span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;, tag:\&quot;left\&quot;, data:&quot;</span><span class="fu">++</span> show f2 <span class="fu">++</span><span class="st">&quot;}&quot;</span>) e1</code></pre></div>
<p><strong>Formating and outputting to file</strong></p>
<p>jsSetup takes a name of the array, the output of compile function and outputs a JavaScript formatted string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsSetup  ::</span>  <span class="dt">String</span>       <span class="co">-- array name</span>
         <span class="ot">-&gt;</span>  <span class="dt">CodeGen</span> x    <span class="co">-- compilation process</span>
         <span class="ot">-&gt;</span>  (  <span class="dt">String</span>    <span class="co">-- JavaScript code</span>
             ,  x         <span class="co">-- result</span>
             )</code></pre></div>
<p>jsWrite takes an output of jsSetup and writes everything to a file &quot;generated.js&quot; which can be safely used by Abstract Machine.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsWrite ::</span> (<span class="dt">String</span>, x) <span class="ot">-&gt;</span> <span class="dt">IO</span>()
jsWrite (code, x) <span class="fu">=</span> writeFile <span class="st">&quot;dist/generated.js&quot;</span> code</code></pre></div>
<h3 id="abstract-machine"><span class="header-section-number">4.2.3</span> Abstract machine</h3>
<p>Purpose of the Abstract Machine is to take in a compiled program and run it in the browser. It gradually builds a stack from the given program, where each frame of the stack has a link to another frame. The elegant part of this is that, stack frames can be saved, updated, deleted and restored; thus, making the Machines data structure flexible.</p>
<p><strong>Program Structure</strong></p>
<p>Each program is an array and its entries are functions which take in a stack. This way it is possible to nest them while keeping track of the stack.</p>
<p>Below is an example of a compiled program ready to be used by Abstract Machine. This particular program is simple, it only adds two numbers &quot;2 + 3&quot;, so the expected output is &quot;5&quot;.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ProgramFoo <span class="op">=</span> []<span class="op">;</span>

ProgramFoo[<span class="dv">0</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// stack</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">//expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">3</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span>
ProgramFoo[<span class="dv">1</span>] <span class="op">=</span> <span class="kw">function</span> (s) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">stack</span><span class="op">:</span> <span class="op">{</span> <span class="co">// stack </span>
            <span class="dt">prev</span><span class="op">:</span> s<span class="op">,</span> <span class="co">// link to previous frame </span>
            <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="co">// command used for adding numbers</span>
            <span class="dt">data</span><span class="op">:</span> <span class="dv">0</span> <span class="co">// index of next operation </span>
        <span class="op">},</span>
        <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="co">// expression type</span>
        <span class="dt">data</span><span class="op">:</span> <span class="dv">2</span> <span class="co">// expression value</span>
    <span class="op">}</span>
<span class="op">};</span></code></pre></div>
<p><strong>Abstract Machine Implementation</strong></p>
<p>This section will explain detailed implementation of the experimental Abstract Machine. It is defined as a function which takes in a compiled program as an argument.</p>
<p>Initial definition of mode with starting values. Because the starting stack is empty the &quot;stack&quot; parameter is defined as &quot;null&quot;; the tag is an expression type and if it is equal to &quot;go&quot;, the Machine must evaluate next function. Finally, the &quot;data&quot; parameter holds an index of next function, so the initial value is the index of last function in a program array.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;go&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">f</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>
    <span class="op">}</span></code></pre></div>
<p>Mode is a function in a program array which takes in a stack as a parameter. Abstract Machine will operate until mode.tag is equal to &quot;go&quot;. If it is then mode must be reinitialized by getting getting a next function from program array and passing stack to it, so that the mode has access to previous stack.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">===</span> <span class="st">&quot;go&quot;</span>) <span class="op">{</span>
        mode <span class="op">=</span> f[<span class="va">mode</span>.<span class="at">data</span>](<span class="va">mode</span>.<span class="at">stack</span>)<span class="op">;</span></code></pre></div>
<p>After the mode is reinitialized mode.tag can't be equal to &quot;go&quot; and mode stack can't be empty. If these requirements aren't met then it means that execution is over.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="cf">while</span> (<span class="va">mode</span>.<span class="at">tag</span> <span class="op">!=</span> <span class="st">&quot;go&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">mode</span>.<span class="at">stack</span> <span class="op">!=</span> <span class="kw">null</span>) <span class="op">{</span></code></pre></div>
<p>If the execution is still going then the behaviour of the Abstract Machine will differ based on mode's tag parameter. Tag could be equal to these values:</p>
<ul>
<li><strong>&quot;num&quot;</strong> - all of the basic evaluations of given expression:
<ul>
<li>Addition (&quot;left&quot; and &quot;right&quot;) - creates a stack frame with tag &quot;right&quot;, if the top of the stack tag is equal to &quot;right&quot; it means that Abstract Machine can add two of the top frames together, because all of the other computations are done.</li>
<li>Catch - creates a stack frame with tag &quot;catcher&quot; and places it on the top of the stack. Its data parameter is equal to the index of second expression which will be evaluated if first expressions throws an exception.</li>
<li>New reference - creates a stack frame with tag &quot;WithRefRight&quot;, it is different from other stack frames because it has a &quot;name&quot; parameter, which is needed to identify between different references. It, also, holds the value of the reference in its &quot;data&quot; parameter.</li>
<li>Next (:&gt;left and :&gt;right) - implementation is similar to addition, however the key difference is that if the top stack frame tag is equal to &quot;:&gt;right&quot; the Abstract Machine will take its data without adding anything and it will delete the used stack frame.<br />
</li>
<li>Set (:=) - very similar to &quot;Get&quot; command, key difference is that it alters the stack frame which has tag &quot;WithRefRight&quot; and the given name of the reference. This command utilizes linked list stack saving to be able to restore the stack while saving any changes made. It could throw an exception if the reference is undefined.</li>
</ul></li>
<li><strong>&quot;throw&quot;</strong> - it defines that something went wrong so the Abstract Machine will look for a &quot;catch&quot; usage in the previous stack, if it doesn't find it then it will output an exception.</li>
</ul>
<p>Machine checks if the top of the stack is equal to &quot;catcher&quot;, if it is then it means exception was handled, so Abstract Machine reinitializes mode to continue executions by taking &quot;catcher&quot; values of &quot;stack&quot; and &quot;data&quot;.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;num&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">data</span>
    <span class="op">}</span></code></pre></div>
<p>Else Machine drops the top of the stack and continues to look for &quot;catcher&quot; until stack is empty.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">mode <span class="op">=</span> <span class="op">{</span>
    <span class="dt">stack</span><span class="op">:</span> <span class="va">mode</span>.<span class="va">stack</span>.<span class="at">prev</span><span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="st">&quot;throw&quot;</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="st">&quot;Unhandled exception!&quot;</span>
    <span class="op">}</span></code></pre></div>
<ul>
<li><strong>&quot;get&quot;</strong> - goes through stack while looking for a reference, output's either a value of the reference if it does find it or tries to throw an exception if it doesn't. It, also, utilizes linked stack saving and restoring functions, in order to restore the stack if it does find a reference.</li>
</ul>
<p>After the Abstract Machine finishes running it will output the final stack to the console by invoking a custom printer function for the user to clearly see the stack.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">printer</span>(mode)<span class="op">;</span></code></pre></div>
<p>And finally, Abstract Machine outputs final value of the execution on the separate line for testing purposes, it is used by Testing framework to check for expected and actual output of a test.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(<span class="va">mode</span>.<span class="at">data</span>)<span class="op">;</span></code></pre></div>
<p><strong>Linked Stack Saving and Restoring</strong></p>
<p>Abstract Machine uses saver function in &quot;get&quot; and &quot;:=&quot; implementations. This function lets the Machine not only to inspect the depths of the stack but, also, to assign new values to existing frames of the stack. To achieve this, Abstract Machine saves each frame of the stack from top until it finds the frame it is looking for. Below &quot;saveStack&quot; function is displayed, the &quot;m&quot; variable represents the current stack frame.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">save <span class="op">=</span> <span class="op">{</span>
    <span class="dt">prev</span><span class="op">:</span> save<span class="op">,</span>
    <span class="dt">tag</span><span class="op">:</span> <span class="va">m</span>.<span class="at">tag</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:</span> <span class="va">m</span>.<span class="at">data</span><span class="op">,</span>
    <span class="dt">name</span><span class="op">:</span> <span class="va">m</span>.<span class="at">name</span>
<span class="op">}</span></code></pre></div>
<p>The save is reverse linked list of stack frames, thus it is possible to restore the original stack including all the changes made. After stack is successfully restored all of the save data must be destroyed and parameters reseted to keep future saves unaffected.</p>
<p>Limitations:</p>
<ul>
<li>Only one Stack save can exist at a given time.</li>
</ul>
<p><strong>Final Remarks</strong></p>
<p>The Abstract Machine currently supports functionality for adding expressions, creating a reference, getting the value of a reference, setting new value of a given reference, throwing &amp; catching an exception.</p>
<p>Room for improvement:</p>
<ul>
<li>Efficiency and optimization;</li>
<li>Documentation;</li>
<li>Functionality;</li>
</ul>
<p>All of these are addressed in the final implementation.</p>
<h3 id="testing-framework"><span class="header-section-number">4.2.4</span> Testing framework</h3>
<p>Testing framework consists of two files utilizing two different scripts: Bash script and Expect script. Its purpose is to automate the testing process. Below each of these scripts will be reviewed.</p>
<h4 id="bash-script"><span class="header-section-number">4.2.4.1</span> Bash script</h4>
<p>Bash script is the main script in the testing framework which stores all test cases, then goes through them one by one.</p>
<p>Sample test case:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test0=(</span>
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = Val 10&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_num&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;10&#39;</span>
)</code></pre></div>
<p>Complex test case:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">declare</span> -A <span class="va">test9=(</span>  
    [<span class="ex">expr</span>]=<span class="st">&#39;let xpr = WithRef &quot;x&quot; (Val 22) (&quot;x&quot; := (Get &quot;x&quot; :+: Val 11) :&gt; (Get &quot;x&quot; :+: Val 30))&#39;</span>
    [<span class="ex">name</span>]=<span class="st">&#39;test_withref_get_set_next&#39;</span>
    [<span class="ex">expected</span>]=<span class="st">&#39;63&#39;</span>
)</code></pre></div>
<p>Each test case must store three values: expression to be tested, the name of the test and expected output.</p>
<p>For each test case it launches Expect script and passes parameters to it. It passes the expression to be tested and the name of the test.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./tests/helper.sh</span> <span class="va">${test[expr]}</span> <span class="va">${test[name]</span></code></pre></div>
<p>After, Expect script &quot;helper.sh&quot; finishes computing and generates new program, system must recompile Abstract Machines code to use newly generated program. Webpack is used for all JavaScript code compilations, dependencies and overall structure.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">webpack</span> --hide-modules <span class="co">#recompile code to output.js </span></code></pre></div>
<p>After successful recompilation of JavaScript Bash script has to retrieve the output of the program by retrieving the last line of the console output utilizing Node functionality and some string manipulation.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">output=$(</span><span class="ex">node</span> ./dist/output.js<span class="va">)</span>; <span class="co">#get output</span>
<span class="va">output=</span><span class="st">&quot;</span><span class="va">${output##</span>*<span class="st">$&#39;</span><span class="dt">\n</span><span class="st">&#39;</span><span class="va">}</span><span class="st">&quot;</span> <span class="co">#take only last line</span></code></pre></div>
<p>Finally, Bash script just compares the expected output with actual output and gives back the result for the user to see.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">if</span><span class="bu"> [</span> <span class="st">&quot;</span><span class="va">$output</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;</span><span class="va">${test[expected]}</span><span class="st">&quot;</span><span class="bu"> ]</span>; <span class="kw">then</span>
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${GREEN}</span><span class="st">Test passed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">else</span> 
    <span class="bu">echo</span> -e <span class="st">&quot;</span><span class="va">${RED}</span><span class="st">Test failed</span><span class="va">${NC}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre></div>
<h4 id="expect-script"><span class="header-section-number">4.2.4.2</span> Expect script</h4>
<p>Expect script is used because of its ability to send and receive commands to programs which have their own terminal, in this case GHCI.</p>
<p>Expect script takes the name of the test and the expression to be tested. Because it is only possible to pass one array to Expect script, the script performs some array manipulation to retrieve the name and the expression.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">set</span> <span class="fu">expr</span> [lrange <span class="va">$argv</span> 0 end-1]
<span class="kw">set</span> <span class="ex">name</span> [lindex <span class="va">$argv</span> end 0]</code></pre></div>
<p>After that it launches GHCI terminal.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">spawn</span> ghci</code></pre></div>
<p>And waits for &quot;&gt;&quot; character before sending the command to load the Compiler.hs file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;:load Compiler.hs\r&quot;</span></code></pre></div>
<p>Finally, Expect script sends the two following commands to generate the output of the Compiler and quits to resume the Bash script execution.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;</span><span class="va">$b</span><span class="st">\r&quot;</span>

<span class="ex">expect</span> <span class="st">&quot;Main&gt;&quot;</span>
<span class="ex">send</span> <span class="st">&quot;jsWrite (jsSetup </span><span class="dt">\&quot;</span><span class="va">$name</span><span class="dt">\&quot;</span><span class="st"> (compile xpr))\r&quot;</span> </code></pre></div>
<p>Possible improvements for the final testing framework:</p>
<ul>
<li>Speed &amp; efficiency;</li>
<li>Move test cases into separate file;</li>
<li>More useful statistics at the end of computation;</li>
</ul>
<p><strong>Usage</strong></p>
<p>To use the testing framework just run ./tester.sh in the terminal window. If there is a permission issue do &quot;chmod +x helper.sh&quot;.</p>
<h2 id="conclusion-1"><span class="header-section-number">4.3</span> Conclusion</h2>
<p>A preliminary experiment, implementing the essence of Frank-like execution for much simpler language, has been completed successfully. The key lessons were:</p>
<ul>
<li>Haskell syntax;</li>
<li>Language creation and its syntax development;</li>
<li>Compiler - parsing the input and generating valid JavaScript code;</li>
<li>Machine - executing given program, and managing its resources, such as mode, stack and saved stack.</li>
</ul>
<p>Key things to improve:</p>
<ul>
<li>Optimization</li>
</ul>
<p>The further plan is to roll out the lessons learned for more of the &quot;Shonky&quot; intermediate language that is generated by Frank compiler. This will be covered in the next chapter.</p>
<h1 id="detailed-design-and-implementation-of-the-final-system"><span class="header-section-number">5</span> Detailed Design and Implementation of the final system</h1>
<p>Chapter focuses on implementation, design of the final compiler and abstract machine, as well as, any topics connected to them.</p>
<h2 id="introduction-2"><span class="header-section-number">5.1</span> Introduction</h2>
<p>Final system started to develop on week six of the second semester after the end of experimental system development. Some parts of the code were lifted from the earlier experiment and main concepts of how virtual machines and compilers should work are reused.</p>
<p><strong>Disclaimer</strong></p>
<p>Final system uses two other systems in its code base, thus not all of the code is written by the author of this project. Author's code will be clearly indicated. Two projects connected to the system are:</p>
<ul>
<li><strong>Frankjnr</strong> - developed by Craig???. Final system is essentially new back end for Frankjnr. So the whole Frankjnr project was used and new back end was placing in 'Backend' folder. Parts of Frankjnr code were slightly updated to let the user choose between the old back end and the new one. Updated files were: Compile.hs and Frank.hs, updates are clearly indicated with comments;</li>
<li><strong>Shonky</strong> - developed by Conor McBride. Final compiler uses Shonky's syntax file for its supported data structures and parse functions;</li>
</ul>
<p>More detailed descriptions can be found at 'Related work' section of the report or at their Github pages.</p>
<h2 id="project-folder-structure"><span class="header-section-number">5.2</span> Project folder structure</h2>
<h2 id="abstract-machine-1"><span class="header-section-number">5.3</span> Abstract machine</h2>
<h2 id="compiler-1"><span class="header-section-number">5.4</span> Compiler</h2>
<h2 id="testing-framework-1"><span class="header-section-number">5.5</span> Testing framework</h2>
<h2 id="possible-improvements"><span class="header-section-number">5.6</span> Possible improvements</h2>
<p>use chunks of stacks when top of the chunk is possible needed stack frame and others are not (speedup)</p>
<p>turn local functions into top level operators is called &quot;Lambda-lifting&quot; it was invented by Thomas Jonson in 1985 (Springer LNCS 201). it's used in eg. GHC</p>
<p>Match-this-or-bust pattern matching is late 60s technology:</p>
<p>Computer Aided Manipulation of Symbols F.V. McBride PhD thesis, 1970, Queen's University Belfast</p>
<p>The more efficient compilation by building a tree of switches is</p>
<p>Compiling Pattern Matching Lennart Augustsson in Functional Programming and Computer Architecture 1985 Springer LNCS 209 # Verification and Validation</p>
<h1 id="results-and-evaluation"><span class="header-section-number">6</span> Results and Evaluation</h1>
<h1 id="summary-conclusion"><span class="header-section-number">7</span> Summary &amp; Conclusion</h1>
<!-- 
A chapter that concludes the thesis by summarising the learning points
and outlining future areas for research
-->
<h2 id="summary"><span class="header-section-number">7.1</span> Summary</h2>
<h2 id="future-work"><span class="header-section-number">7.2</span> Future work</h2>
<h1 id="appendix-1-progress-log" class="unnumbered">Appendix 1: Progress log</h1>
<p><strong>JANUARY</strong></p>
<p>January 4th:<br />
<em>Research:</em><br />
Looked over Frankjnr, Shonky, Vole implementations.</p>
<p>January 5th:<br />
Tried to install Frankjnr for a period of time, however couldn’t resolve all the errors.</p>
<p>January 7th:<br />
<em>Research:</em><br />
Looked at Vole with a bit more detail.</p>
<p>January 9th:<br />
Tried to install Frankjnr by using Cabal dependency management tool, no success (deprecated dependencies).<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 10th:<br />
<em>Research:</em><br />
Looked at Vole, in particular Machine.lhs, Compile.lhs and Vole.js.</p>
<p>January 11th:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on project specification, plan and presentation.</p>
<p>January 16th:<br />
<em>Research:</em><br />
Looked at Shonky stack implementation, tried to output it on the screen.</p>
<p>January 17th:<br />
<em>Machine Development:</em><br />
Implemented simple linked list stack in JavaScript, just as a practice.</p>
<p>January 18th:<br />
<em>Research:</em><br />
Looked again at Shonky’s Abstract Machine, particularly the order the input is parsed.</p>
<p>January 24th:<br />
<em>Machine Development:</em><br />
Implemented simple Abstract Machine, which can sum 2 numbers.</p>
<p>January 25th:<br />
<em>Machine Development:</em><br />
Machine now works with stack larger than 2.<br />
Updated the way it stores functions, now it uses Array data structure.<br />
<em>Research:</em><br />
Looking into how to implement throw, catch and compiler.</p>
<p>January 26th:<br />
<em>Compiler Development:</em><br />
Created basic language in Haskell. Which supports expressions and sum of expressions.<br />
Developed monadic structure for the compiler.</p>
<p>January 30th:<br />
<em>Compiler Development:</em><br />
Finished the basic layout, however it doesn’t display any results yet.<br />
Presentation &amp; Report Work:<br />
Setup of latex with lex2tex.</p>
<p>January 31th:<br />
<em>Machine Development:</em><br />
Implemented Throw and Catch for Abstract Machine.<br />
Presentation &amp; Report work:<br />
Worked on structure of the report.</p>
<p><strong>FEBRUARY</strong></p>
<p>February 01:<br />
<em>Presentation &amp; Report work:</em><br />
Worked on latex configurations.</p>
<p>February 02:<br />
<em>Machine Development:</em><br />
Implemented early versions of stack saving, restoring and support for Set command.</p>
<p>February 04:<br />
<em>Presentation &amp; Report work:</em><br />
Report work - Introduction sections.</p>
<p>February 06:<br />
<em>Compiler Development:</em><br />
Tried to implement Show instance for CodeGen function.</p>
<p>February 07:<br />
<em>Research:</em><br />
Looked at the lifecycle and expected behaviour of the Compiler.<br />
<em>Compiler Development:</em><br />
Implemented Compiler Catch and Throw.</p>
<p>February 08:<br />
<em>Compiler Development:</em><br />
Implemented Get, Next, WithRef commands.<br />
<em>Machine Development:</em><br />
Implemented support for Next commands.<br />
Added new examples of working programs.</p>
<p>February 09:<br />
<em>Machine development:</em><br />
Implemented early version of stack saving and restoring.<br />
Implemented support for Set commands.<br />
Added new working examples.<br />
Reworked Next command support, should work as expected.</p>
<p>February 10:<br />
<em>Test Framework development:</em><br />
Implemented test framework by utilizing Bash and Expect scripts.<br />
<em>Machine development:</em><br />
Divided code into separate classes and files.<br />
Added printer class, which just outputs the current stack to the console.</p>
<p>February 13:<br />
Started to rework Abstract Machine, to closer match the implementation required.<br />
<em>Machine development:</em><br />
Reworked Catch and Throw command support.<br />
<em>Compiler development:</em><br />
Small efficiency adjustments.<br />
Test Framework development:<br />
Added more test cases.<br />
General bug fixes.</p>
<p>February 14: <em>Test Framework development:</em><br />
Fixed major bug with string parsing.<br />
Added more test cases.<br />
<em>Machine development:</em><br />
Completely reworked support for Get, Set and WithRef commands.<br />
General bug fixes.</p>
<p>February 15:<br />
Progress report.</p>
<p>February 16:<br />
Progress report.</p>
<p>February 24:<br />
<em>Final Compiler development:</em><br />
Outputting generated code to js file.<br />
Researched top level functions.<br />
<em>Project</em><br />
Updated project structure.</p>
<p><strong>March</strong></p>
<p>March 05:<br />
<em>Report</em><br />
Chapter 4 almost done.<br />
<em>Project</em><br />
Improvements all around: bug fixes, documentation updates.</p>
<p>March 07:<br />
<em>Report</em><br />
Related work section<br />
Introduction chapter summarization<br />
<em>Final Compiler development:</em><br />
Attempt to implement operators array<br />
Looking into how to compile operator variables</p>
<p>March 08:<br />
<em>Report</em><br />
Background section<br />
<em>Final Compiler development:</em><br />
Various fixes<br />
operatorCompile function adjustment<br />
File Writer adjustment</p>
<p>March 09:<br />
<em>Report</em><br />
Related work section<br />
<em>Final Compiler development:</em><br />
Adjusted file generation<br />
Fixed operatorCompile function<br />
<em>Final Abstract Machine development:</em><br />
Initialized project structure with webpack<br />
Initial implementation of final Machine (support for CAR and CDR operations)</p>
<p>March 10:<br />
<em>Final Compiler development:</em><br />
Adjusted type definitions<br />
Added one layer of structure to Computations<br />
<em>Final Abstract Machine development:</em><br />
Fixed bugs regarding CAR and CDR<br />
Optimization- &quot;go&quot; tag is not needed, creating modes directly<br />
CDR now returns pair</p>
<p>March 11:<br />
<em>Final Compiler development:</em><br />
Added needed functionality to compiler to support 'application' operations<br />
<em>Final Abstract Machine development:</em><br />
Added functionality for FUN and ARG, still need to figure out how to apply a function to ready list</p>
<p>March 12:<br />
<em>Final Compiler development:</em><br />
Added parser functions, now the compiler is able to covert Shonky language to its syntax<br />
<em>Final Testing Framework development:</em><br />
Created initial structure of the framework as well as sample test case<br />
<em>Report</em><br />
Problem overview section</p>
<p>March 13:<br />
<em>Final Compiler development:</em><br />
Commands development<br />
<em>Final Abstract Machine development:</em><br />
Commands development<br />
<em>Report</em><br />
Specification section</p>
<p>March 14:<br />
<em>Final Compiler development:</em><br />
Bug fixes<br />
<em>Final Abstract Machine development:</em><br />
Bug fixes, command support implemented<br />
<em>Report</em><br />
Requirement analysis section<br />
<em>Project structure</em><br />
Frankjnr now uses new back end</p>
<h1 id="appendix-2-some-more-extra-stuff" class="unnumbered">Appendix 2: Some more extra stuff</h1>

<!-- 
Do not edit this page.

References are automatically generated from the BibTex file (References.bib)

...which you should create using your reference manager.
-->
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-Plotkin5">
<p>B. C. Pierce and D. N. Turner, 2000. <em>Local type inference</em>,</p>
</div>
<div id="ref-Plotkin7">
<p>G. D. Plotkin and J. Power, 2001a. <em>Adequacy for algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin2">
<p>G. D. Plotkin and J. Power, 2003. <em>Algebraic operations and generic effects</em>,</p>
</div>
<div id="ref-Plotkin3">
<p>G. D. Plotkin and J. Power, 2009. <em>Handlers of algebraic effects</em>,</p>
</div>
<div id="ref-Plotkin">
<p>G. D. Plotkin and J. Power, 2002. <em>Notions of computation determine monads</em>,</p>
</div>
<div id="ref-Plotkin6">
<p>G. D. Plotkin and J. Power, 2001b. <em>Semantics for algebraic operations</em>,</p>
</div>
<div id="ref-Plotkin4">
<p>G. D. Plotkin and M. Pretnar, 2013. <em>Handling algebraic effects</em>,</p>
</div>
<div id="ref-CompilingCorrectly">
<p>Graham Hutton and Joel Wrigh, 2004. <em>Compiling Exceptions Correctly</em>,</p>
</div>
<div id="ref-FrankPaper">
<p>Sam Lindley, Conor McBride &amp; Craig McLaughlin, 2016. <em>Do be do be do</em>,</p>
</div>
</div>
            </body>
</html>

